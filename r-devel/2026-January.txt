From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Fri Jan  2 09:54:19 2026
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Fri, 2 Jan 2026 08:54:19 +0000
Subject: [Rd] Plans for the pipe bind operator?
Message-ID: <66a0952283344d6cb87ab339bfe4c31f@ap-hm.fr>

Hello,

The experimental (undocumented?) pipe bind operator (=>) was introduced in January 2021 (https://stat.ethz.ch/pipermail/r-devel/2021-January/080396.html). In December 2021, Luke Tierney said that it might be dropped (https://stat.ethz.ch/pipermail/r-devel/2021-December/081384.html).

It is still present in R-devel (to become R 4.6):

mtcars |> (\(x) lm(mpg ~ disp, data = x))()
mtcars$mpg |> quantile() |> (\(x) sprintf("%.1f (%.1f, %.1f)", x[3], x[2], x[4]))()

Sys.setenv("_R_USE_PIPEBIND_" = TRUE)
mtcars |> x => lm(mpg ~ disp, data = x)
mtcars$mpg |> quantile() |> x => sprintf("%.1f (%.1f, %.1f)", x[3], x[2], x[4])

Since a few years have passed, are there now any plans regarding the pipe bind operator?

I still hope it will be officially supported, as I find it a very readable alternative to anonymous functions in pipe chains (for cases where the placeholder is not supported). It might be easily adopted, since similar syntax exists in other widely used languages (e.g., arrow functions in ES6/JS).

Best,
Thomas


From iuke-tier@ey m@iii@g oii uiow@@edu  Fri Jan  2 17:07:05 2026
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Fri, 2 Jan 2026 10:07:05 -0600 (CST)
Subject: [Rd] [External]  Plans for the pipe bind operator?
In-Reply-To: <66a0952283344d6cb87ab339bfe4c31f@ap-hm.fr>
References: <66a0952283344d6cb87ab339bfe4c31f@ap-hm.fr>
Message-ID: <7dd1a496-5f2d-868c-fbef-769481f9264f@uiowa.edu>

No current plans, too many more pressing issues.

Best,

luke

On Fri, 2 Jan 2026, SOEIRO Thomas via R-devel wrote:

> Hello,
>
> The experimental (undocumented?) pipe bind operator (=>) was introduced in January 2021 (https://stat.ethz.ch/pipermail/r-devel/2021-January/080396.html). In December 2021, Luke Tierney said that it might be dropped (https://stat.ethz.ch/pipermail/r-devel/2021-December/081384.html).
>
> It is still present in R-devel (to become R 4.6):
>
> mtcars |> (\(x) lm(mpg ~ disp, data = x))()
> mtcars$mpg |> quantile() |> (\(x) sprintf("%.1f (%.1f, %.1f)", x[3], x[2], x[4]))()
>
> Sys.setenv("_R_USE_PIPEBIND_" = TRUE)
> mtcars |> x => lm(mpg ~ disp, data = x)
> mtcars$mpg |> quantile() |> x => sprintf("%.1f (%.1f, %.1f)", x[3], x[2], x[4])
>
> Since a few years have passed, are there now any plans regarding the pipe bind operator?
>
> I still hope it will be officially supported, as I find it a very readable alternative to anonymous functions in pipe chains (for cases where the placeholder is not supported). It might be easily adopted, since similar syntax exists in other widely used languages (e.g., arrow functions in ES6/JS).
>
> Best,
> Thomas
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu/

From |kry|ov @end|ng |rom d|@root@org  Sat Jan  3 22:25:05 2026
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Sun, 4 Jan 2026 00:25:05 +0300
Subject: [Rd] non-API ATTRIB and SET_ATTRIB will be dropped soon
In-Reply-To: <53ffc423-b184-fc87-6f98-5f0b952bf473@uiowa.edu>
References: <53ffc423-b184-fc87-6f98-5f0b952bf473@uiowa.edu>
Message-ID: <20260104002505.147944ea@Tarkus>

Dear Luke,

On Sat, 20 Dec 2025 08:10:30 -0600 (CST)
luke-tierney--- via R-devel <r-devel at r-project.org> wrote:

> The 'Working with attributes' section in the 'Writing R Extensions'
> list some alternatives. Additional functions for working with
> attributes, without exposing internal attributes structure, could be
> added if they are needed.

Two tangentially related questions:

1. Should packages use the return value of Rf_setAttrib()? I've noticed
that some branches taken by the code (e.g. setAttrib(foo,
R_CommentSymbol, bar)) return R_NilValue, while others return the newly
installed attribute value.

I'm asking because data.table needs to resize a temporary data frame
that it owns, and for this purpose it needs to mutate its 'row.names'
attribute in compact integer form. The current code walks the ATTRIB()
list in search of the desired attribute, since Rf_getAttrib() would
return an ALTREP form instead. We'll probably replace it with
R_mapAttrib(), but I'm curious about alternatives.

2. In R_mapAttrib(), while walking ATTRIB(), the code always protects
the current pair 'a', and then it protects CAR(a) and TAG(a) before
calling the user-provided callback. Why protect TAG(a)? Because it's a
good practice to protect arguments of user callbacks, or because it's
really possible for TAG() of an attribute pair to become
garbage-collected?

-- 
Best regards,
Ivan


From j|r|@c@mor@vec @end|ng |rom gm@||@com  Mon Jan  5 04:30:43 2026
From: j|r|@c@mor@vec @end|ng |rom gm@||@com (=?UTF-8?B?SmnFmcOtIE1vcmF2ZWM=?=)
Date: Mon, 5 Jan 2026 16:30:43 +1300
Subject: [Rd] Assign in place and reference counting
Message-ID: <c785d3f9-9b02-4ef1-bd90-306fd38f88ec@gmail.com>

I am trying to figure out limits of R with respect to assign in place.

Canonically, only environments are fully pass-by-reference.
However, there is an optimization that allows assign-in-place in a 
certain context:

 ??? vec = vector("numeric", 8)
 ??? vec[1] = 5

assign 5 to position 1 without changing the address of `vec`,
this can be verified either by first running tracemem(vec) or
calling `.Internal(inspect(vec))` before and after the assignment.

The mechanismus used to be NAMED, but was replaced by `reference counting`.
Unfortunately, I have failed to find the full documentation of it.
But the way it seems to be working is that if there is only a single 
reference to the given object,
the object will be updated in place (if the types permit this).

However, this doesn't seem to be guaranteed, the following doesn't work
(at least on my computer):

 ??? env = new.env(parent = emptyenv()
 ??? env$vec = vector("numeric", 8)
 ??? env$vec[1] = 5 # so far so good, but
 ??? env2 = env # env is passed by reference
 ??? env$vec[2] = 6 # memory changed

Aliasing env as env2, normally safe thing for environments, seems to 
"confuse"
the reference counter which stops performing the optimization despite 
`vec` having REF(1).

---

1. Is there documentation of `reference counting`?
2. Is the demonstrated behaviour a bug?
3. I would guess that assign in place in this case is 
implementation-specific detail and not specified behaviour, so one 
shouldn't rely on it.
4. Is there way how to do this (i.e., fixed buffer) in base R without 
relying on C with .Call?

The following pages mention this behaviour, but don't fully describe it:

* 
https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Named-objects-and-copying
* 
https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Rest-of-header
* 
https://cran.r-project.org/doc/manuals/r-release/R-ints.html#Argument-evaluation
* 
https://cran.r-project.org/doc/manuals/r-release/R-ints.html#g_t_002eInternal-vs-_002ePrimitive


Thanks,
Jirka


From |kry|ov @end|ng |rom d|@root@org  Tue Jan  6 11:39:01 2026
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Tue, 6 Jan 2026 13:39:01 +0300
Subject: [Rd] Assign in place and reference counting
In-Reply-To: <c785d3f9-9b02-4ef1-bd90-306fd38f88ec@gmail.com>
References: <c785d3f9-9b02-4ef1-bd90-306fd38f88ec@gmail.com>
Message-ID: <20260106133901.24ed7f8c@Tarkus>

? Mon, 5 Jan 2026 16:30:43 +1300
Ji?? Moravec <jiri.c.moravec at gmail.com> ?????:

> 1. Is there documentation of `reference counting`?

There is a short description at
<https://developer.r-project.org/Refcnt.html>. The general rule for
package developers is "Except in very special and well understood
circumstances, an argument passed down to C code should not be modified
if it has a positive reference count, even if that count is equal to
one".

For an example of when a reference count of 1 is not safe, consider:

foo <- bar <- baz <- list(x = 42+0) # make a fresh numeric vector
.Call(modify_me, foo$x)

foo$x has a reference count of only 1, so NOT_SHARED() is true. On the
other hand, since the bindings 'foo', 'bar', 'baz' all share the same
list (whose reference count is 3), altering foo$x by reference from C
code would also change the values of 'bar' and 'baz', which violates
the value semantics of lists in R.

> 2. Is the demonstrated behaviour a bug?

In this particular case, you've shown the duplication could have been
avoided, so at the very least you've got a feature request to make
complex assignment more efficient. Now the question is, why does the
duplication happen and how hard it is to avoid performing it without
breaking anything?

The complex assignment rules are described here:

https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Subset-assignment-1

If you call tracemem(env$vec) and set a breakpoint in
memtrace_report(), you can see that env$vec is duplicated in eval.c,
function evalseq():

(gdb) l evalseq
(gdb) b 3201
Breakpoint 2 at 0x55555569dacb: file eval.c, line 3201.
(gdb) commands 2
>call Rf_PrintValue(nexpr)
>c
>end
(gdb) b 3209
Breakpoint 3 at 0x55555569dad3: file eval.c, line 3209.
(gdb) commands 3
>call R_inspect(nval)
>call R_inspect(val)
>c
>end

In both cases, the expression being evaluated is `*tmp*`$vec, with
`*tmp*` aliased to `env` without incrementing its reference count. When
evaluating the first assignment, `env$vec[1] <- 5`, `nval` is the
vector being updated, and `val` is a special, non-reference-counting
pairlist containing `env` and `as.name("env")`:

Breakpoint 3, evalseq <...> at eval.c:3209
# first the 'nval', note REF(1)
@55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
# next the 'val', note REF(1) for its first element
@555557df5fb0 02 LISTSXP g0c0 [STP]
  @555557d0a3b8 04 ENVSXP g0c0 [REF(1)] <0x555557d0a3b8>
<...>
  @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1785)] "env"

Next, after `env2 <- env`, we attempt an assignment again:

Breakpoint 3, evalseq <...> at eval.c:3209
# again, 'nval' has a reference count of 1
@55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
# but now 'env' has a reference count of 2
@555557dfd108 02 LISTSXP g0c0 [STP]
  @555557d0a3b8 04 ENVSXP g0c0 [REF(2)] <0x555557d0a3b8> # <-- here
<...>
  @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1787)] "env"

Since `env` is referenced twice, it's MAYBE_SHARED, so the condition

if (MAYBE_REFERENCED(nval) &&
    (MAYBE_SHARED(nval) || MAYBE_SHARED(CAR(val))))

is true, and `nval` (env$x) is duplicated before the assignment.

This would've been necessary if 'env' was a list (or another
value-semantics object; see the first example above).

> 3. I would guess that assign in place in this case is 
> implementation-specific detail and not specified behaviour, so one 
> shouldn't rely on it.

True. R's copy-on-write is an optimisation, although a very useful one.

> 4. Is there way how to do this (i.e., fixed buffer) in base R without 
> relying on C with .Call?

This is a kludge, but if you allow your environment to be enclosed by
the base environment, you can perform the sub-assignment directly
inside it, without invoking complex assignment:

env3 <- new.env(parent = baseenv())
env3$vec <- vector("numeric", 8)
tracemem(env3$vec)
eval(substitute(vec[i] <- v, list(i = 1, v = 5)), env3)
env4 <- env3
eval(substitute(vec[i] <- v, list(i = 2, v = 6)), env3)
# still not duplicated

(I've also tried substitute(..., list(`<-` = base::`<-`)) for use in an
empty environment, but that breaks when it tries to invoke `[<-`.)

What is the overall problem you would like to solve?

-- 
Best regards,
Ivan


From j|r|@c@mor@vec @end|ng |rom gm@||@com  Tue Jan  6 21:29:11 2026
From: j|r|@c@mor@vec @end|ng |rom gm@||@com (=?UTF-8?B?SmnFmcOtIE1vcmF2ZWM=?=)
Date: Wed, 7 Jan 2026 09:29:11 +1300
Subject: [Rd] Assign in place and reference counting
In-Reply-To: <20260106133901.24ed7f8c@Tarkus>
References: <c785d3f9-9b02-4ef1-bd90-306fd38f88ec@gmail.com>
 <20260106133901.24ed7f8c@Tarkus>
Message-ID: <7d00d979-1c4f-4f31-9df7-5e473f3ba566@gmail.com>

Hi Ivan,

can't say that I fully understand yet the described mechanism,
namely given what you have described at the end,
something I found myself with:

 ? env = parent.env() # doesn't work with emptyenv()
 ? env$vec = c("a","b")
 ? .Internal(address(env$vec))
 ? env2 = env
 ? with(env, {vec[1] = "foo"})

Where `with` runs eval(substitute())` internally.

---

I am just playing with fixed buffers or stacks, I previously was able to 
do stack with:

 ??? new_stack = function(){
 ??????? size = 0
 ??????? items = vector("character", 8)

 ??????? add = function(x){
 ??????????? size <<- size + 1
 ??????????? items[size] <<- x
 ??????????? }

 ??????? get = function(){
 ??????????? items[seq_len(size)]
 ??????????? }

 ??????? environment()
 ??????? }

 ??? stack = new_stack()
 ??? tracemem(stack$items)
 ??? stack2 = stack
 ??? .Internal(address(stack$items))
 ??? stack$add("foo")
 ??? stack$add("bar")
 ??? # Memory is the same
 ??? .Internal(address(stack$items))
 ??? # stack2 is the same as stack
 ??? stack2$get() # [1] "foo" "bar"

Which works, is really cool, and allows memory efficient (or so I hope) 
shared resources with reference-like schematic with other type that 
environments.
I just hoped that further simplification would be possible.

I believe this works because the function "add" is evaluated in the same 
environment (a with the `with`), but I don't fully get _why_.

I will spend some time reading the subset assignment section.


On 6/01/26 23:39, Ivan Krylov wrote:
> ? Mon, 5 Jan 2026 16:30:43 +1300
> Ji?? Moravec <jiri.c.moravec at gmail.com> ?????:
>
>> 1. Is there documentation of `reference counting`?
> There is a short description at
> <https://developer.r-project.org/Refcnt.html>. The general rule for
> package developers is "Except in very special and well understood
> circumstances, an argument passed down to C code should not be modified
> if it has a positive reference count, even if that count is equal to
> one".
>
> For an example of when a reference count of 1 is not safe, consider:
>
> foo <- bar <- baz <- list(x = 42+0) # make a fresh numeric vector
> .Call(modify_me, foo$x)
>
> foo$x has a reference count of only 1, so NOT_SHARED() is true. On the
> other hand, since the bindings 'foo', 'bar', 'baz' all share the same
> list (whose reference count is 3), altering foo$x by reference from C
> code would also change the values of 'bar' and 'baz', which violates
> the value semantics of lists in R.
>
>> 2. Is the demonstrated behaviour a bug?
> In this particular case, you've shown the duplication could have been
> avoided, so at the very least you've got a feature request to make
> complex assignment more efficient. Now the question is, why does the
> duplication happen and how hard it is to avoid performing it without
> breaking anything?
>
> The complex assignment rules are described here:
>
> https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Subset-assignment-1
>
> If you call tracemem(env$vec) and set a breakpoint in
> memtrace_report(), you can see that env$vec is duplicated in eval.c,
> function evalseq():
>
> (gdb) l evalseq
> (gdb) b 3201
> Breakpoint 2 at 0x55555569dacb: file eval.c, line 3201.
> (gdb) commands 2
>> call Rf_PrintValue(nexpr)
>> c
>> end
> (gdb) b 3209
> Breakpoint 3 at 0x55555569dad3: file eval.c, line 3209.
> (gdb) commands 3
>> call R_inspect(nval)
>> call R_inspect(val)
>> c
>> end
> In both cases, the expression being evaluated is `*tmp*`$vec, with
> `*tmp*` aliased to `env` without incrementing its reference count. When
> evaluating the first assignment, `env$vec[1] <- 5`, `nval` is the
> vector being updated, and `val` is a special, non-reference-counting
> pairlist containing `env` and `as.name("env")`:
>
> Breakpoint 3, evalseq <...> at eval.c:3209
> # first the 'nval', note REF(1)
> @55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
> # next the 'val', note REF(1) for its first element
> @555557df5fb0 02 LISTSXP g0c0 [STP]
>    @555557d0a3b8 04 ENVSXP g0c0 [REF(1)] <0x555557d0a3b8>
> <...>
>    @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1785)] "env"
>
> Next, after `env2 <- env`, we attempt an assignment again:
>
> Breakpoint 3, evalseq <...> at eval.c:3209
> # again, 'nval' has a reference count of 1
> @55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
> # but now 'env' has a reference count of 2
> @555557dfd108 02 LISTSXP g0c0 [STP]
>    @555557d0a3b8 04 ENVSXP g0c0 [REF(2)] <0x555557d0a3b8> # <-- here
> <...>
>    @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1787)] "env"
>
> Since `env` is referenced twice, it's MAYBE_SHARED, so the condition
>
> if (MAYBE_REFERENCED(nval) &&
>      (MAYBE_SHARED(nval) || MAYBE_SHARED(CAR(val))))
>
> is true, and `nval` (env$x) is duplicated before the assignment.
>
> This would've been necessary if 'env' was a list (or another
> value-semantics object; see the first example above).
>
>> 3. I would guess that assign in place in this case is
>> implementation-specific detail and not specified behaviour, so one
>> shouldn't rely on it.
> True. R's copy-on-write is an optimisation, although a very useful one.
>
>> 4. Is there way how to do this (i.e., fixed buffer) in base R without
>> relying on C with .Call?
> This is a kludge, but if you allow your environment to be enclosed by
> the base environment, you can perform the sub-assignment directly
> inside it, without invoking complex assignment:
>
> env3 <- new.env(parent = baseenv())
> env3$vec <- vector("numeric", 8)
> tracemem(env3$vec)
> eval(substitute(vec[i] <- v, list(i = 1, v = 5)), env3)
> env4 <- env3
> eval(substitute(vec[i] <- v, list(i = 2, v = 6)), env3)
> # still not duplicated
>
> (I've also tried substitute(..., list(`<-` = base::`<-`)) for use in an
> empty environment, but that breaks when it tries to invoke `[<-`.)
>
> What is the overall problem you would like to solve?
>


From @|mon@urb@nek @end|ng |rom R-project@org  Tue Jan  6 23:12:51 2026
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Wed, 7 Jan 2026 11:12:51 +1300
Subject: [Rd] Assign in place and reference counting
In-Reply-To: <7d00d979-1c4f-4f31-9df7-5e473f3ba566@gmail.com>
References: <c785d3f9-9b02-4ef1-bd90-306fd38f88ec@gmail.com>
 <20260106133901.24ed7f8c@Tarkus>
 <7d00d979-1c4f-4f31-9df7-5e473f3ba566@gmail.com>
Message-ID: <D8ACFFD3-68A6-4F11-9007-648B383195B9@R-project.org>



> On 7/01/2026, at 09:29, Ji?? Moravec <jiri.c.moravec at gmail.com> wrote:
> 
> Hi Ivan,
> 
> can't say that I fully understand yet the described mechanism,
> namely given what you have described at the end,
> something I found myself with:
> 
>   env = parent.env() # doesn't work with emptyenv()
>   env$vec = c("a","b")
>   .Internal(address(env$vec))
>   env2 = env
>   with(env, {vec[1] = "foo"})
> 
> Where `with` runs eval(substitute())` internally.
> 
> ---
> 
> I am just playing with fixed buffers or stacks, I previously was able to do stack with:
> 
>     new_stack = function(){
>         size = 0
>         items = vector("character", 8)
> 
>         add = function(x){
>             size <<- size + 1
>             items[size] <<- x
>             }
> 
>         get = function(){
>             items[seq_len(size)]
>             }
> 
>         environment()
>         }
> 
>     stack = new_stack()
>     tracemem(stack$items)
>     stack2 = stack
>     .Internal(address(stack$items))
>     stack$add("foo")
>     stack$add("bar")
>     # Memory is the same
>     .Internal(address(stack$items))
>     # stack2 is the same as stack
>     stack2$get() # [1] "foo" "bar"
> 
> Which works, is really cool, and allows memory efficient (or so I hope) shared resources with reference-like schematic with other type that environments.
> I just hoped that further simplification would be possible.
> 


You are re-inventing the reference classes (or R6 if you prefer package space). By definition, environments are the only mutable objects in R, no other objects are, so what you are doing is adding a reference wrapper around an immutable object.

The fact that `items` can be modified in place is orthogonal to that: as Ivan said, that's just an under-the-hood optimization. The language definition says that the `items` before and after the subassignment are two different objects - both immutable. From user's perspective there is no difference, but R is smart enough to optimize away the copy if it is safe, i.e., when it knows for sure that no one can access the original object so it can cheat and re-use the original object instead, but that fact is intended to be entirely invisible to the user.

Clearly, for the example above the entire discussion is irrelevant, since copies are much cheaper than function calls so unless you have a stack of billions it makes no difference. In addition, your get() will always return a copy regardless, because you are forcing it by the subsetting, so, paradoxically, the na?ve (yet more readable) implementation

        items = character()
        add = function(x) items <<- c(items, x)
        get = function() items

is actually faster if you have comparable number of gets and adds since gets don't need to copy (and uses less memory). My recommendation would be to not worry about internal optimisations because a) they change all the time so your assumptions about undefined behavior may be broken and backfire, b) the time you spend on it is many orders of magnitude more than any potential savings and c) trying to exploit specific behavior makes code less readable and thus more error-prone.

Cheers,
?imon


> I believe this works because the function "add" is evaluated in the same environment (a with the `with`), but I don't fully get _why_.
> 
> I will spend some time reading the subset assignment section.
> 
> 
> On 6/01/26 23:39, Ivan Krylov wrote:
>> ? Mon, 5 Jan 2026 16:30:43 +1300
>> Ji?? Moravec <jiri.c.moravec at gmail.com> ?????:
>> 
>>> 1. Is there documentation of `reference counting`?
>> There is a short description at
>> <https://developer.r-project.org/Refcnt.html>. The general rule for
>> package developers is "Except in very special and well understood
>> circumstances, an argument passed down to C code should not be modified
>> if it has a positive reference count, even if that count is equal to
>> one".
>> 
>> For an example of when a reference count of 1 is not safe, consider:
>> 
>> foo <- bar <- baz <- list(x = 42+0) # make a fresh numeric vector
>> .Call(modify_me, foo$x)
>> 
>> foo$x has a reference count of only 1, so NOT_SHARED() is true. On the
>> other hand, since the bindings 'foo', 'bar', 'baz' all share the same
>> list (whose reference count is 3), altering foo$x by reference from C
>> code would also change the values of 'bar' and 'baz', which violates
>> the value semantics of lists in R.
>> 
>>> 2. Is the demonstrated behaviour a bug?
>> In this particular case, you've shown the duplication could have been
>> avoided, so at the very least you've got a feature request to make
>> complex assignment more efficient. Now the question is, why does the
>> duplication happen and how hard it is to avoid performing it without
>> breaking anything?
>> 
>> The complex assignment rules are described here:
>> 
>> https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Subset-assignment-1
>> 
>> If you call tracemem(env$vec) and set a breakpoint in
>> memtrace_report(), you can see that env$vec is duplicated in eval.c,
>> function evalseq():
>> 
>> (gdb) l evalseq
>> (gdb) b 3201
>> Breakpoint 2 at 0x55555569dacb: file eval.c, line 3201.
>> (gdb) commands 2
>>> call Rf_PrintValue(nexpr)
>>> c
>>> end
>> (gdb) b 3209
>> Breakpoint 3 at 0x55555569dad3: file eval.c, line 3209.
>> (gdb) commands 3
>>> call R_inspect(nval)
>>> call R_inspect(val)
>>> c
>>> end
>> In both cases, the expression being evaluated is `*tmp*`$vec, with
>> `*tmp*` aliased to `env` without incrementing its reference count. When
>> evaluating the first assignment, `env$vec[1] <- 5`, `nval` is the
>> vector being updated, and `val` is a special, non-reference-counting
>> pairlist containing `env` and `as.name("env")`:
>> 
>> Breakpoint 3, evalseq <...> at eval.c:3209
>> # first the 'nval', note REF(1)
>> @55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
>> # next the 'val', note REF(1) for its first element
>> @555557df5fb0 02 LISTSXP g0c0 [STP]
>>   @555557d0a3b8 04 ENVSXP g0c0 [REF(1)] <0x555557d0a3b8>
>> <...>
>>   @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1785)] "env"
>> 
>> Next, after `env2 <- env`, we attempt an assignment again:
>> 
>> Breakpoint 3, evalseq <...> at eval.c:3209
>> # again, 'nval' has a reference count of 1
>> @55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
>> # but now 'env' has a reference count of 2
>> @555557dfd108 02 LISTSXP g0c0 [STP]
>>   @555557d0a3b8 04 ENVSXP g0c0 [REF(2)] <0x555557d0a3b8> # <-- here
>> <...>
>>   @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1787)] "env"
>> 
>> Since `env` is referenced twice, it's MAYBE_SHARED, so the condition
>> 
>> if (MAYBE_REFERENCED(nval) &&
>>     (MAYBE_SHARED(nval) || MAYBE_SHARED(CAR(val))))
>> 
>> is true, and `nval` (env$x) is duplicated before the assignment.
>> 
>> This would've been necessary if 'env' was a list (or another
>> value-semantics object; see the first example above).
>> 
>>> 3. I would guess that assign in place in this case is
>>> implementation-specific detail and not specified behaviour, so one
>>> shouldn't rely on it.
>> True. R's copy-on-write is an optimisation, although a very useful one.
>> 
>>> 4. Is there way how to do this (i.e., fixed buffer) in base R without
>>> relying on C with .Call?
>> This is a kludge, but if you allow your environment to be enclosed by
>> the base environment, you can perform the sub-assignment directly
>> inside it, without invoking complex assignment:
>> 
>> env3 <- new.env(parent = baseenv())
>> env3$vec <- vector("numeric", 8)
>> tracemem(env3$vec)
>> eval(substitute(vec[i] <- v, list(i = 1, v = 5)), env3)
>> env4 <- env3
>> eval(substitute(vec[i] <- v, list(i = 2, v = 6)), env3)
>> # still not duplicated
>> 
>> (I've also tried substitute(..., list(`<-` = base::`<-`)) for use in an
>> empty environment, but that breaks when it tries to invoke `[<-`.)
>> 
>> What is the overall problem you would like to solve?
>> 
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From j|r|@c@mor@vec @end|ng |rom gm@||@com  Wed Jan  7 02:25:28 2026
From: j|r|@c@mor@vec @end|ng |rom gm@||@com (=?UTF-8?B?SmnFmcOtIE1vcmF2ZWM=?=)
Date: Wed, 7 Jan 2026 14:25:28 +1300
Subject: [Rd] Assign in place and reference counting
In-Reply-To: <D8ACFFD3-68A6-4F11-9007-648B383195B9@R-project.org>
References: <c785d3f9-9b02-4ef1-bd90-306fd38f88ec@gmail.com>
 <20260106133901.24ed7f8c@Tarkus>
 <7d00d979-1c4f-4f31-9df7-5e473f3ba566@gmail.com>
 <D8ACFFD3-68A6-4F11-9007-648B383195B9@R-project.org>
Message-ID: <b80e4cc6-f542-4c91-ba1c-8a643ddc5592@gmail.com>

Hi Simon (?imon?),

 > You are re-inventing the reference classes (or R6 if you prefer 
package space). By definition, environments are the only mutable objects 
in R, no other objects are, so what you are doing is adding a reference 
wrapper around an immutable object.

yes, what I am doing is essentially very barebone RC or R6, but in pure 
base R in fewer lines of code.

I stole it from R6 benchmarks: 
https://r6.r-lib.org/articles/Performance.html#environment-created-by-a-function-call-without-class-attribute

and from https://github.com/r-lib/testthat/blob/main/R/stack.R

In the actual code, I am using an environment as a hidden state object, 
specifically to track test results:

https://github.com/J-Moravec/mutr/blob/master/mutr.r#L6-L13

so I need an environment object (or bunch of global variables).

 > Clearly, for the example above the entire discussion is irrelevant, 
since copies are much cheaper than function calls so unless you have a 
stack of billions it makes no difference. In addition, your get() will 
always return a copy regardless, because you are forcing it by the 
subsetting, so, paradoxically, the na?ve (yet more readable) implementation

I guess I was so scared of the Second Circle that I fell in the Eight.

https://www.burns-stat.com/pages/Tutor/R_inferno.pdf

I didn't realized that the "get" will force a copy, and after testing, 
the performance is better for growing variant (I guess since R is now 
internally pre-allocating for short vectors, but as you said, internal 
details :) ).

I guess I can keep it simple then and don't need to be as worried about 
re-allocating small vectors.

https://gist.github.com/J-Moravec/07bde03068ece71495976b0388c4b519

Thanks, this was nice learning experience,


-- Jirka

On 7/01/26 11:12, Simon Urbanek wrote:
>
>> On 7/01/2026, at 09:29, Ji?? Moravec <jiri.c.moravec at gmail.com> wrote:
>>
>> Hi Ivan,
>>
>> can't say that I fully understand yet the described mechanism,
>> namely given what you have described at the end,
>> something I found myself with:
>>
>>    env = parent.env() # doesn't work with emptyenv()
>>    env$vec = c("a","b")
>>    .Internal(address(env$vec))
>>    env2 = env
>>    with(env, {vec[1] = "foo"})
>>
>> Where `with` runs eval(substitute())` internally.
>>
>> ---
>>
>> I am just playing with fixed buffers or stacks, I previously was able to do stack with:
>>
>>      new_stack = function(){
>>          size = 0
>>          items = vector("character", 8)
>>
>>          add = function(x){
>>              size <<- size + 1
>>              items[size] <<- x
>>              }
>>
>>          get = function(){
>>              items[seq_len(size)]
>>              }
>>
>>          environment()
>>          }
>>
>>      stack = new_stack()
>>      tracemem(stack$items)
>>      stack2 = stack
>>      .Internal(address(stack$items))
>>      stack$add("foo")
>>      stack$add("bar")
>>      # Memory is the same
>>      .Internal(address(stack$items))
>>      # stack2 is the same as stack
>>      stack2$get() # [1] "foo" "bar"
>>
>> Which works, is really cool, and allows memory efficient (or so I hope) shared resources with reference-like schematic with other type that environments.
>> I just hoped that further simplification would be possible.
>>
>
> You are re-inventing the reference classes (or R6 if you prefer package space). By definition, environments are the only mutable objects in R, no other objects are, so what you are doing is adding a reference wrapper around an immutable object.
>
> The fact that `items` can be modified in place is orthogonal to that: as Ivan said, that's just an under-the-hood optimization. The language definition says that the `items` before and after the subassignment are two different objects - both immutable. From user's perspective there is no difference, but R is smart enough to optimize away the copy if it is safe, i.e., when it knows for sure that no one can access the original object so it can cheat and re-use the original object instead, but that fact is intended to be entirely invisible to the user.
>
> Clearly, for the example above the entire discussion is irrelevant, since copies are much cheaper than function calls so unless you have a stack of billions it makes no difference. In addition, your get() will always return a copy regardless, because you are forcing it by the subsetting, so, paradoxically, the na?ve (yet more readable) implementation
>
>          items = character()
>          add = function(x) items <<- c(items, x)
>          get = function() items
>
> is actually faster if you have comparable number of gets and adds since gets don't need to copy (and uses less memory). My recommendation would be to not worry about internal optimisations because a) they change all the time so your assumptions about undefined behavior may be broken and backfire, b) the time you spend on it is many orders of magnitude more than any potential savings and c) trying to exploit specific behavior makes code less readable and thus more error-prone.
>
> Cheers,
> ?imon
>
>
>> I believe this works because the function "add" is evaluated in the same environment (a with the `with`), but I don't fully get _why_.
>>
>> I will spend some time reading the subset assignment section.
>>
>>
>> On 6/01/26 23:39, Ivan Krylov wrote:
>>> ? Mon, 5 Jan 2026 16:30:43 +1300
>>> Ji?? Moravec <jiri.c.moravec at gmail.com> ?????:
>>>
>>>> 1. Is there documentation of `reference counting`?
>>> There is a short description at
>>> <https://developer.r-project.org/Refcnt.html>. The general rule for
>>> package developers is "Except in very special and well understood
>>> circumstances, an argument passed down to C code should not be modified
>>> if it has a positive reference count, even if that count is equal to
>>> one".
>>>
>>> For an example of when a reference count of 1 is not safe, consider:
>>>
>>> foo <- bar <- baz <- list(x = 42+0) # make a fresh numeric vector
>>> .Call(modify_me, foo$x)
>>>
>>> foo$x has a reference count of only 1, so NOT_SHARED() is true. On the
>>> other hand, since the bindings 'foo', 'bar', 'baz' all share the same
>>> list (whose reference count is 3), altering foo$x by reference from C
>>> code would also change the values of 'bar' and 'baz', which violates
>>> the value semantics of lists in R.
>>>
>>>> 2. Is the demonstrated behaviour a bug?
>>> In this particular case, you've shown the duplication could have been
>>> avoided, so at the very least you've got a feature request to make
>>> complex assignment more efficient. Now the question is, why does the
>>> duplication happen and how hard it is to avoid performing it without
>>> breaking anything?
>>>
>>> The complex assignment rules are described here:
>>>
>>> https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Subset-assignment-1
>>>
>>> If you call tracemem(env$vec) and set a breakpoint in
>>> memtrace_report(), you can see that env$vec is duplicated in eval.c,
>>> function evalseq():
>>>
>>> (gdb) l evalseq
>>> (gdb) b 3201
>>> Breakpoint 2 at 0x55555569dacb: file eval.c, line 3201.
>>> (gdb) commands 2
>>>> call Rf_PrintValue(nexpr)
>>>> c
>>>> end
>>> (gdb) b 3209
>>> Breakpoint 3 at 0x55555569dad3: file eval.c, line 3209.
>>> (gdb) commands 3
>>>> call R_inspect(nval)
>>>> call R_inspect(val)
>>>> c
>>>> end
>>> In both cases, the expression being evaluated is `*tmp*`$vec, with
>>> `*tmp*` aliased to `env` without incrementing its reference count. When
>>> evaluating the first assignment, `env$vec[1] <- 5`, `nval` is the
>>> vector being updated, and `val` is a special, non-reference-counting
>>> pairlist containing `env` and `as.name("env")`:
>>>
>>> Breakpoint 3, evalseq <...> at eval.c:3209
>>> # first the 'nval', note REF(1)
>>> @55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
>>> # next the 'val', note REF(1) for its first element
>>> @555557df5fb0 02 LISTSXP g0c0 [STP]
>>>    @555557d0a3b8 04 ENVSXP g0c0 [REF(1)] <0x555557d0a3b8>
>>> <...>
>>>    @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1785)] "env"
>>>
>>> Next, after `env2 <- env`, we attempt an assignment again:
>>>
>>> Breakpoint 3, evalseq <...> at eval.c:3209
>>> # again, 'nval' has a reference count of 1
>>> @55555615f588 14 REALSXP g0c4 [REF(1)] (len=8, tl=0) 5,0,0,0,0,...
>>> # but now 'env' has a reference count of 2
>>> @555557dfd108 02 LISTSXP g0c0 [STP]
>>>    @555557d0a3b8 04 ENVSXP g0c0 [REF(2)] <0x555557d0a3b8> # <-- here
>>> <...>
>>>    @555555a2ae88 01 SYMSXP g0c0 [MARK,REF(1787)] "env"
>>>
>>> Since `env` is referenced twice, it's MAYBE_SHARED, so the condition
>>>
>>> if (MAYBE_REFERENCED(nval) &&
>>>      (MAYBE_SHARED(nval) || MAYBE_SHARED(CAR(val))))
>>>
>>> is true, and `nval` (env$x) is duplicated before the assignment.
>>>
>>> This would've been necessary if 'env' was a list (or another
>>> value-semantics object; see the first example above).
>>>
>>>> 3. I would guess that assign in place in this case is
>>>> implementation-specific detail and not specified behaviour, so one
>>>> shouldn't rely on it.
>>> True. R's copy-on-write is an optimisation, although a very useful one.
>>>
>>>> 4. Is there way how to do this (i.e., fixed buffer) in base R without
>>>> relying on C with .Call?
>>> This is a kludge, but if you allow your environment to be enclosed by
>>> the base environment, you can perform the sub-assignment directly
>>> inside it, without invoking complex assignment:
>>>
>>> env3 <- new.env(parent = baseenv())
>>> env3$vec <- vector("numeric", 8)
>>> tracemem(env3$vec)
>>> eval(substitute(vec[i] <- v, list(i = 1, v = 5)), env3)
>>> env4 <- env3
>>> eval(substitute(vec[i] <- v, list(i = 2, v = 6)), env3)
>>> # still not duplicated
>>>
>>> (I've also tried substitute(..., list(`<-` = base::`<-`)) for use in an
>>> empty environment, but that breaks when it tries to invoke `[<-`.)
>>>
>>> What is the overall problem you would like to solve?
>>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>


