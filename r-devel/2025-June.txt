From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Jun  2 12:19:27 2025
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 2 Jun 2025 12:19:27 +0200
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
Message-ID: <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>


On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
> Dear All,
>
> Perhaps this should go in r-package-devel, but I suspect that this is
> going to turn into a feature request, and I want to run it by the list
> before filing it in the Bugzilla.
>
> I would like to specify a long string literal without making the line
> of code too long. In R,
>
> "abc
> def"
>
> yields the string "abc\def", and, as far as I can tell, there is no
> mechanism for preventing it from inserting a newline into the string.
>
> Putting a backslash before the newline, i.e.,
>
> "abc\
> def"
>
> eliminates the newline in (that I know of) C/C++, Python, and Julia,
> but it makes no difference in R.
>
> The implicit concatenation of Python and C/C++, e.g., "abc" "def", is a
> syntax error as well in R.
>
> It is, of course, possible to use paste0(), but is there a more concise
> built-in mechanism in R of which I am not aware?
>
> If not, I think it would make sense to bring R in line with the others.
> Currently, backslash and no backslash before a newline behave
> identically (at least as far as I can tell), so I doubt that a
> nontrivial amount of code relies on the current behaviour. [1]

What would be real example of a long string literal you would want to 
enter this way?

For entering a long text with newlines, one can use raw strings in R 
(see ?Quotes) - but there you would see the newlines and indentation. 
I've seen code where? "paste0" has been aliased to a local function 
named with a single letter to make concatenation more concise.

Best
Tomas

>
> 				Any thoughts?
> 				Pavel
>
> [1] On the off chance that it does, it should easy to check by
> searching for "\\\n" in package sources, because a backslash before a
> newline is a syntax error outside a string.
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From m|kko@m@rtt||@ @end|ng |rom or|onph@rm@@com  Mon Jun  2 13:26:30 2025
From: m|kko@m@rtt||@ @end|ng |rom or|onph@rm@@com (Marttila Mikko)
Date: Mon, 2 Jun 2025 11:26:30 +0000
Subject: [Rd] Bug in prettyNum
In-Reply-To: <CALK03d2v+eFr_79n_HSscFn9DwYd6OcS96DN3mYhweOx=pw6Xw@mail.gmail.com>
References: <DU0PR09MB5500C551FB554E632FE7DE3E9898A@DU0PR09MB5500.eurprd09.prod.outlook.com>
 <20250523171457.5260d7a9@arachnoid>
 <26676.38541.365837.162746@stat.math.ethz.ch>
 <CALK03d2v+eFr_79n_HSscFn9DwYd6OcS96DN3mYhweOx=pw6Xw@mail.gmail.com>
Message-ID: <DU0PR09MB5500F460D676B556B9DA8A6B9862A@DU0PR09MB5500.eurprd09.prod.outlook.com>

Hi,

Thanks, Ivan, for the additional diagnosis and debugging tips.

Thanks, Martin, for the prompt fix.

Thanks, Toby, for sharing the R Dev Container link. I tried it out and was able to easily test some changes. I'll be using that in the future!

Best,

Mikko

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Toby Hocking
Sent: Tuesday, 27 May 2025 08:17
To: Marttila Mikko via R-devel <r-devel at r-project.org>
Subject: Re: [Rd] Bug in prettyNum

Thanks for the contribution Mikko!
For testing future patches, you can actually do it right in the web browser, thanks to Heather Turner's R Dev Container, see instructions here https://contributor.r-project.org/r-dev-env/container_setup/
Best
Toby

On Mon, May 26, 2025 at 6:28?PM Martin Maechler <maechler at stat.math.ethz.ch>
wrote:

> Thank you,  Marttila  and Ivan,
>
> As the original author of prettyNum() {etc ..}, I will commit such a
> bug fix to R-devel (and probably port it to R 4.5.0 patched) quite
> soon (but not yet today).
>
> Best regards,
>
> Martin Maechler
>
> >>>>> Ivan Krylov via R-devel
> >>>>>     on Fri, 23 May 2025 17:14:57 +0300 writes:
>
>     > ? Fri, 23 May 2025 11:47:33 +0000
>     > Marttila Mikko via R-devel <r-devel at r-project.org> ?????:
>
>     >> When called with a numeric vector, the `replace.zero` argument is
>     >> disregarded.
>     >>
>     >> > prettyNum(0, zero.print = "- ", replace.zero = TRUE)
>     >> [1] "-"
>     >> Warning message:
>     >> In .format.zeros(x, zero.print, replace = replace.zero) :
>     >> 'zero.print' is truncated to fit into formatted zeros; consider
>     >> 'replace=TRUE'
>
>     >> Please see below a patch which I believe would fix this.
>
>     > Surprisingly, it's not enough. The 'replace' argument to
> .format.zeros
>     > needs to be "threaded" through both the call to vapply(x,
> format,
> ...)
>     > and the internal call from format.default(...) to prettyNum(...):
>
>     R> options(warn = 2, error = recover)
>     R> prettyNum(0, zero.print = "--", replace.zero = TRUE)
>     > Error in .format.zeros(x, zero.print, replace = replace.zero) :
>     > (converted from warning) 'zero.print' is truncated to fit into
> formatted zeros; consider 'replace=TRUE'
>
>     > Enter a frame number, or 0 to exit
>
>     > 1: prettyNum(0, zero.print = "--", replace.zero = TRUE)
>     > 2: vapply(x, format, "", big.mark = big.mark, big.interval =
> big.interval, sma
>     > 3: FUN(X[[i]], ...)
>     > 4: format.default(X[[i]], ...)
>     > 5: prettyNum(.Internal(format(x, trim, digits, nsmall, width, 3,
> na.encode, sc
>     > 6: .format.zeros(x, zero.print, replace = replace.zero)
>     > 7: warning("'zero.print' is truncated to fit into formatted
> zeros; consider 'r
>     > <...omitted...>
>     > Selection: 6
>     > <...>
>     > Browse[1]> ls.str()
>     > i0 :  logi TRUE
>     > ind0 :  int 1
>     > nc :  int 1
>     > nx :  num 0
>     > nz :  int 2
>     > replace :  logi FALSE
>     > warn.non.fitting :  logi TRUE
>     > x :  chr "0"
>     > zero.print :  chr "--"
>
>     > Since prettyNum() accepts ... and thus ignores unknown arguments, it
>     > seems to be safe to forward the ellipsis from format.default() to
>     > prettyNum(). The patch survives LANGUAGE=en TZ=UTC make check-devel.
>
>     > Index: src/library/base/R/format.R
>     > ===================================================================
>     > --- src/library/base/R/format.R   (revision 88229)
>     > +++ src/library/base/R/format.R   (working copy)
>     > @@ -73,7 +73,7 @@
>     > decimal.mark = decimal.mark, input.d.mark = decimal.mark,
>     > zero.print = zero.print, drop0trailing = drop0trailing,
>     > is.cmplx = is.complex(x),
>     > -                      preserve.width = if (trim) "individual" else
> "common"),
>     > +                      preserve.width = if (trim) "individual" else
> "common", ...),
>     > ## all others (for now):
>     > stop(gettextf("Found no format() method for class \"%s\"",
>     > class(x)), domain = NA))
>     > @@ -338,7 +338,8 @@
>     > big.mark=big.mark, big.interval=big.interval,
>     > small.mark=small.mark, small.interval=small.interval,
>     > decimal.mark=decimal.mark, zero.print=zero.print,
>     > -             drop0trailing=drop0trailing, ...)
>     > +             drop0trailing=drop0trailing, replace.zero=replace.zero,
>     > +             ...)
>     > }
>     > ## be fast in trivial case, when all options have their default,
> or "match"
>     > nMark <- big.mark == "" && small.mark == "" && (notChar ||
> decimal.mark == input.d.mark)
>
>
>     > --
>     > Best regards,
>     > Ivan
>
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


This e-mail transmission may contain confidential or legally privileged information that is intended only for the individual or entity named in the e-mail address. If you are not the intended recipient, you are hereby notified that any disclosure, copying, distribution, or reliance upon the contents of this e-mail is strictly prohibited. If you have received this e-mail transmission in error, please reply to the sender, so that they can arrange for proper delivery, and then please delete the message from your computer systems. Thank you.

From jo@|@h@p@rry @end|ng |rom gm@||@com  Mon Jun  2 17:37:36 2025
From: jo@|@h@p@rry @end|ng |rom gm@||@com (Josiah Parry)
Date: Mon, 2 Jun 2025 08:37:36 -0700
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
Message-ID: <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>

Tomas,

Here is a good example of where this functionality would be useful:
https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56

In order to prevent R CMD check notes I have to use `paste0()` to
concatenate long URLs. If we were able to use `\` to
separate the string across multiple lines, it would make the solution much
nicer!

On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera <tomas.kalibera at gmail.com>
wrote:

>
> On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
> > Dear All,
> >
> > Perhaps this should go in r-package-devel, but I suspect that this is
> > going to turn into a feature request, and I want to run it by the list
> > before filing it in the Bugzilla.
> >
> > I would like to specify a long string literal without making the line
> > of code too long. In R,
> >
> > "abc
> > def"
> >
> > yields the string "abc\def", and, as far as I can tell, there is no
> > mechanism for preventing it from inserting a newline into the string.
> >
> > Putting a backslash before the newline, i.e.,
> >
> > "abc\
> > def"
> >
> > eliminates the newline in (that I know of) C/C++, Python, and Julia,
> > but it makes no difference in R.
> >
> > The implicit concatenation of Python and C/C++, e.g., "abc" "def", is a
> > syntax error as well in R.
> >
> > It is, of course, possible to use paste0(), but is there a more concise
> > built-in mechanism in R of which I am not aware?
> >
> > If not, I think it would make sense to bring R in line with the others.
> > Currently, backslash and no backslash before a newline behave
> > identically (at least as far as I can tell), so I doubt that a
> > nontrivial amount of code relies on the current behaviour. [1]
>
> What would be real example of a long string literal you would want to
> enter this way?
>
> For entering a long text with newlines, one can use raw strings in R
> (see ?Quotes) - but there you would see the newlines and indentation.
> I've seen code where  "paste0" has been aliased to a local function
> named with a single letter to make concatenation more concise.
>
> Best
> Tomas
>
> >
> >                               Any thoughts?
> >                               Pavel
> >
> > [1] On the off chance that it does, it should easy to check by
> > searching for "\\\n" in package sources, because a backslash before a
> > newline is a syntax error outside a string.
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Jun  2 18:27:20 2025
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 2 Jun 2025 18:27:20 +0200
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
Message-ID: <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>


On 6/2/25 17:37, Josiah Parry wrote:
> Tomas,
>
> Here is a good example of where this functionality would be useful:
> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
>
> In order to prevent R CMD check notes I have to use `paste0()` to 
> concatenate long URLs. If we were able to use `\` to
> separate the string across multiple lines, it would make the solution 
> much nicer!

It may be a matter of taste. To me the current form

#' furl <- paste0(
#' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
#'?? "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
#' )
#'

would be actually clearer than say this:

#' # FeatureLayer
#' furl <- 
"https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
PLACES_LocalData_for_BetterHealth/FeatureServer/0"
#'

Inside a per-line comment (#), a backslash followed by a newline would 
probably be disallowed, anyway - e.g. in C it is considered dangerous 
and is discouraged. And the code resulting from splices is hard to read 
due to missing indentation. There is also risk of accidentally putting a 
space after the backslash before the end of line (which some 
languages/parsers then don't treat as a splice, some do, some issue a 
warning - of course it is hard to see in the code).

The idea of automatically concatenating consecutive string literals as 
in C would not easily work in R. This is now valid R code:

x <- "part1"
"part2"

if we introduced concatenation, we would change behavior of this code 
(the value of x would be different, the result of these two lines would 
be different).

I think paste0() is not that bad in the end.

Best
Tomas

> On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera 
> <tomas.kalibera at gmail.com> wrote:
>
>
>     On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
>     > Dear All,
>     >
>     > Perhaps this should go in r-package-devel, but I suspect that
>     this is
>     > going to turn into a feature request, and I want to run it by
>     the list
>     > before filing it in the Bugzilla.
>     >
>     > I would like to specify a long string literal without making the
>     line
>     > of code too long. In R,
>     >
>     > "abc
>     > def"
>     >
>     > yields the string "abc\def", and, as far as I can tell, there is no
>     > mechanism for preventing it from inserting a newline into the
>     string.
>     >
>     > Putting a backslash before the newline, i.e.,
>     >
>     > "abc\
>     > def"
>     >
>     > eliminates the newline in (that I know of) C/C++, Python, and Julia,
>     > but it makes no difference in R.
>     >
>     > The implicit concatenation of Python and C/C++, e.g., "abc"
>     "def", is a
>     > syntax error as well in R.
>     >
>     > It is, of course, possible to use paste0(), but is there a more
>     concise
>     > built-in mechanism in R of which I am not aware?
>     >
>     > If not, I think it would make sense to bring R in line with the
>     others.
>     > Currently, backslash and no backslash before a newline behave
>     > identically (at least as far as I can tell), so I doubt that a
>     > nontrivial amount of code relies on the current behaviour. [1]
>
>     What would be real example of a long string literal you would want to
>     enter this way?
>
>     For entering a long text with newlines, one can use raw strings in R
>     (see ?Quotes) - but there you would see the newlines and indentation.
>     I've seen code where? "paste0" has been aliased to a local function
>     named with a single letter to make concatenation more concise.
>
>     Best
>     Tomas
>
>     >
>     >? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?Any thoughts?
>     >? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?Pavel
>     >
>     > [1] On the off chance that it does, it should easy to check by
>     > searching for "\\\n" in package sources, because a backslash
>     before a
>     > newline is a syntax error outside a string.
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>     ______________________________________________
>     R-devel at r-project.org mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>


From k@@perd@n|e|h@n@en @end|ng |rom gm@||@com  Mon Jun  2 22:59:37 2025
From: k@@perd@n|e|h@n@en @end|ng |rom gm@||@com (Kasper Daniel Hansen)
Date: Mon, 2 Jun 2025 16:59:37 -0400
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
Message-ID: <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>

Like Tomas, I find the paste0 readability to be **much** better, partly
because it allows for better indentation (as Tomas pointed out). Perhaps a
pointless email, but sometimes - for these subjective issues - it is
worthwhile to point out a difference in opinion.

Best,
Kasper

On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
wrote:

>
> On 6/2/25 17:37, Josiah Parry wrote:
> > Tomas,
> >
> > Here is a good example of where this functionality would be useful:
> >
> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
> >
> > In order to prevent R CMD check notes I have to use `paste0()` to
> > concatenate long URLs. If we were able to use `\` to
> > separate the string across multiple lines, it would make the solution
> > much nicer!
>
> It may be a matter of taste. To me the current form
>
> #' furl <- paste0(
> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
> #' )
> #'
>
> would be actually clearer than say this:
>
> #' # FeatureLayer
> #' furl <-
> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
> PLACES_LocalData_for_BetterHealth/FeatureServer/0
> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
> "
> #'
>
> Inside a per-line comment (#), a backslash followed by a newline would
> probably be disallowed, anyway - e.g. in C it is considered dangerous
> and is discouraged. And the code resulting from splices is hard to read
> due to missing indentation. There is also risk of accidentally putting a
> space after the backslash before the end of line (which some
> languages/parsers then don't treat as a splice, some do, some issue a
> warning - of course it is hard to see in the code).
>
> The idea of automatically concatenating consecutive string literals as
> in C would not easily work in R. This is now valid R code:
>
> x <- "part1"
> "part2"
>
> if we introduced concatenation, we would change behavior of this code
> (the value of x would be different, the result of these two lines would
> be different).
>
> I think paste0() is not that bad in the end.
>
> Best
> Tomas
>
> > On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
> > <tomas.kalibera at gmail.com> wrote:
> >
> >
> >     On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
> >     > Dear All,
> >     >
> >     > Perhaps this should go in r-package-devel, but I suspect that
> >     this is
> >     > going to turn into a feature request, and I want to run it by
> >     the list
> >     > before filing it in the Bugzilla.
> >     >
> >     > I would like to specify a long string literal without making the
> >     line
> >     > of code too long. In R,
> >     >
> >     > "abc
> >     > def"
> >     >
> >     > yields the string "abc\def", and, as far as I can tell, there is no
> >     > mechanism for preventing it from inserting a newline into the
> >     string.
> >     >
> >     > Putting a backslash before the newline, i.e.,
> >     >
> >     > "abc\
> >     > def"
> >     >
> >     > eliminates the newline in (that I know of) C/C++, Python, and
> Julia,
> >     > but it makes no difference in R.
> >     >
> >     > The implicit concatenation of Python and C/C++, e.g., "abc"
> >     "def", is a
> >     > syntax error as well in R.
> >     >
> >     > It is, of course, possible to use paste0(), but is there a more
> >     concise
> >     > built-in mechanism in R of which I am not aware?
> >     >
> >     > If not, I think it would make sense to bring R in line with the
> >     others.
> >     > Currently, backslash and no backslash before a newline behave
> >     > identically (at least as far as I can tell), so I doubt that a
> >     > nontrivial amount of code relies on the current behaviour. [1]
> >
> >     What would be real example of a long string literal you would want to
> >     enter this way?
> >
> >     For entering a long text with newlines, one can use raw strings in R
> >     (see ?Quotes) - but there you would see the newlines and indentation.
> >     I've seen code where  "paste0" has been aliased to a local function
> >     named with a single letter to make concatenation more concise.
> >
> >     Best
> >     Tomas
> >
> >     >
> >     >                               Any thoughts?
> >     >                               Pavel
> >     >
> >     > [1] On the off chance that it does, it should easy to check by
> >     > searching for "\\\n" in package sources, because a backslash
> >     before a
> >     > newline is a syntax error outside a string.
> >     > ______________________________________________
> >     > R-devel at r-project.org mailing list
> >     > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >     ______________________________________________
> >     R-devel at r-project.org mailing list
> >     https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


-- 
Best,
Kasper

	[[alternative HTML version deleted]]


From jo@|@h@p@rry @end|ng |rom gm@||@com  Mon Jun  2 23:17:52 2025
From: jo@|@h@p@rry @end|ng |rom gm@||@com (Josiah Parry)
Date: Mon, 2 Jun 2025 14:17:52 -0700
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
Message-ID: <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>

I suppose taste is learned as well. It does feel quite odd that the best
way to define a long string without a note or text wrapping is by being
creative with functions.

This is valid in Python, Julia, and Rust (if you add `let` and a
terminating semi-colon):

my_str = "part1\
part2\
part2"

I don't think it is abnormal to expect or desire this type of functionality
in our favorite language.

On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
kasperdanielhansen at gmail.com> wrote:

> Like Tomas, I find the paste0 readability to be **much** better, partly
> because it allows for better indentation (as Tomas pointed out). Perhaps a
> pointless email, but sometimes - for these subjective issues - it is
> worthwhile to point out a difference in opinion.
>
> Best,
> Kasper
>
> On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
> wrote:
>
>>
>> On 6/2/25 17:37, Josiah Parry wrote:
>> > Tomas,
>> >
>> > Here is a good example of where this functionality would be useful:
>> >
>> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
>> >
>> > In order to prevent R CMD check notes I have to use `paste0()` to
>> > concatenate long URLs. If we were able to use `\` to
>> > separate the string across multiple lines, it would make the solution
>> > much nicer!
>>
>> It may be a matter of taste. To me the current form
>>
>> #' furl <- paste0(
>> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
>> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
>> #' )
>> #'
>>
>> would be actually clearer than say this:
>>
>> #' # FeatureLayer
>> #' furl <-
>> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
>> PLACES_LocalData_for_BetterHealth/FeatureServer/0
>> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
>> "
>> #'
>>
>> Inside a per-line comment (#), a backslash followed by a newline would
>> probably be disallowed, anyway - e.g. in C it is considered dangerous
>> and is discouraged. And the code resulting from splices is hard to read
>> due to missing indentation. There is also risk of accidentally putting a
>> space after the backslash before the end of line (which some
>> languages/parsers then don't treat as a splice, some do, some issue a
>> warning - of course it is hard to see in the code).
>>
>> The idea of automatically concatenating consecutive string literals as
>> in C would not easily work in R. This is now valid R code:
>>
>> x <- "part1"
>> "part2"
>>
>> if we introduced concatenation, we would change behavior of this code
>> (the value of x would be different, the result of these two lines would
>> be different).
>>
>> I think paste0() is not that bad in the end.
>>
>> Best
>> Tomas
>>
>> > On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
>> > <tomas.kalibera at gmail.com> wrote:
>> >
>> >
>> >     On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
>> >     > Dear All,
>> >     >
>> >     > Perhaps this should go in r-package-devel, but I suspect that
>> >     this is
>> >     > going to turn into a feature request, and I want to run it by
>> >     the list
>> >     > before filing it in the Bugzilla.
>> >     >
>> >     > I would like to specify a long string literal without making the
>> >     line
>> >     > of code too long. In R,
>> >     >
>> >     > "abc
>> >     > def"
>> >     >
>> >     > yields the string "abc\def", and, as far as I can tell, there is
>> no
>> >     > mechanism for preventing it from inserting a newline into the
>> >     string.
>> >     >
>> >     > Putting a backslash before the newline, i.e.,
>> >     >
>> >     > "abc\
>> >     > def"
>> >     >
>> >     > eliminates the newline in (that I know of) C/C++, Python, and
>> Julia,
>> >     > but it makes no difference in R.
>> >     >
>> >     > The implicit concatenation of Python and C/C++, e.g., "abc"
>> >     "def", is a
>> >     > syntax error as well in R.
>> >     >
>> >     > It is, of course, possible to use paste0(), but is there a more
>> >     concise
>> >     > built-in mechanism in R of which I am not aware?
>> >     >
>> >     > If not, I think it would make sense to bring R in line with the
>> >     others.
>> >     > Currently, backslash and no backslash before a newline behave
>> >     > identically (at least as far as I can tell), so I doubt that a
>> >     > nontrivial amount of code relies on the current behaviour. [1]
>> >
>> >     What would be real example of a long string literal you would want
>> to
>> >     enter this way?
>> >
>> >     For entering a long text with newlines, one can use raw strings in R
>> >     (see ?Quotes) - but there you would see the newlines and
>> indentation.
>> >     I've seen code where  "paste0" has been aliased to a local function
>> >     named with a single letter to make concatenation more concise.
>> >
>> >     Best
>> >     Tomas
>> >
>> >     >
>> >     >                               Any thoughts?
>> >     >                               Pavel
>> >     >
>> >     > [1] On the off chance that it does, it should easy to check by
>> >     > searching for "\\\n" in package sources, because a backslash
>> >     before a
>> >     > newline is a syntax error outside a string.
>> >     > ______________________________________________
>> >     > R-devel at r-project.org mailing list
>> >     > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>> >     ______________________________________________
>> >     R-devel at r-project.org mailing list
>> >     https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>
>
> --
> Best,
> Kasper
>

	[[alternative HTML version deleted]]


From henr|k@bengt@@on @end|ng |rom gm@||@com  Mon Jun  2 23:34:20 2025
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Mon, 2 Jun 2025 14:34:20 -0700
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
 <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
Message-ID: <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>

One could also argue that paste0("a", "b", "c") is a function call
that needs to be evaluated at runtime, whereas "abc" is a string
constant understood by the parser, and often also language agnostic.
I'd assume compilers and code- and text-search tools do a better job
with the latter.

/Henrik

On Mon, Jun 2, 2025 at 2:18?PM Josiah Parry <josiah.parry at gmail.com> wrote:
>
> I suppose taste is learned as well. It does feel quite odd that the best
> way to define a long string without a note or text wrapping is by being
> creative with functions.
>
> This is valid in Python, Julia, and Rust (if you add `let` and a
> terminating semi-colon):
>
> my_str = "part1\
> part2\
> part2"
>
> I don't think it is abnormal to expect or desire this type of functionality
> in our favorite language.
>
> On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
> kasperdanielhansen at gmail.com> wrote:
>
> > Like Tomas, I find the paste0 readability to be **much** better, partly
> > because it allows for better indentation (as Tomas pointed out). Perhaps a
> > pointless email, but sometimes - for these subjective issues - it is
> > worthwhile to point out a difference in opinion.
> >
> > Best,
> > Kasper
> >
> > On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
> > wrote:
> >
> >>
> >> On 6/2/25 17:37, Josiah Parry wrote:
> >> > Tomas,
> >> >
> >> > Here is a good example of where this functionality would be useful:
> >> >
> >> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
> >> >
> >> > In order to prevent R CMD check notes I have to use `paste0()` to
> >> > concatenate long URLs. If we were able to use `\` to
> >> > separate the string across multiple lines, it would make the solution
> >> > much nicer!
> >>
> >> It may be a matter of taste. To me the current form
> >>
> >> #' furl <- paste0(
> >> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
> >> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
> >> #' )
> >> #'
> >>
> >> would be actually clearer than say this:
> >>
> >> #' # FeatureLayer
> >> #' furl <-
> >> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
> >> PLACES_LocalData_for_BetterHealth/FeatureServer/0
> >> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
> >> "
> >> #'
> >>
> >> Inside a per-line comment (#), a backslash followed by a newline would
> >> probably be disallowed, anyway - e.g. in C it is considered dangerous
> >> and is discouraged. And the code resulting from splices is hard to read
> >> due to missing indentation. There is also risk of accidentally putting a
> >> space after the backslash before the end of line (which some
> >> languages/parsers then don't treat as a splice, some do, some issue a
> >> warning - of course it is hard to see in the code).
> >>
> >> The idea of automatically concatenating consecutive string literals as
> >> in C would not easily work in R. This is now valid R code:
> >>
> >> x <- "part1"
> >> "part2"
> >>
> >> if we introduced concatenation, we would change behavior of this code
> >> (the value of x would be different, the result of these two lines would
> >> be different).
> >>
> >> I think paste0() is not that bad in the end.
> >>
> >> Best
> >> Tomas
> >>
> >> > On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
> >> > <tomas.kalibera at gmail.com> wrote:
> >> >
> >> >
> >> >     On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
> >> >     > Dear All,
> >> >     >
> >> >     > Perhaps this should go in r-package-devel, but I suspect that
> >> >     this is
> >> >     > going to turn into a feature request, and I want to run it by
> >> >     the list
> >> >     > before filing it in the Bugzilla.
> >> >     >
> >> >     > I would like to specify a long string literal without making the
> >> >     line
> >> >     > of code too long. In R,
> >> >     >
> >> >     > "abc
> >> >     > def"
> >> >     >
> >> >     > yields the string "abc\def", and, as far as I can tell, there is
> >> no
> >> >     > mechanism for preventing it from inserting a newline into the
> >> >     string.
> >> >     >
> >> >     > Putting a backslash before the newline, i.e.,
> >> >     >
> >> >     > "abc\
> >> >     > def"
> >> >     >
> >> >     > eliminates the newline in (that I know of) C/C++, Python, and
> >> Julia,
> >> >     > but it makes no difference in R.
> >> >     >
> >> >     > The implicit concatenation of Python and C/C++, e.g., "abc"
> >> >     "def", is a
> >> >     > syntax error as well in R.
> >> >     >
> >> >     > It is, of course, possible to use paste0(), but is there a more
> >> >     concise
> >> >     > built-in mechanism in R of which I am not aware?
> >> >     >
> >> >     > If not, I think it would make sense to bring R in line with the
> >> >     others.
> >> >     > Currently, backslash and no backslash before a newline behave
> >> >     > identically (at least as far as I can tell), so I doubt that a
> >> >     > nontrivial amount of code relies on the current behaviour. [1]
> >> >
> >> >     What would be real example of a long string literal you would want
> >> to
> >> >     enter this way?
> >> >
> >> >     For entering a long text with newlines, one can use raw strings in R
> >> >     (see ?Quotes) - but there you would see the newlines and
> >> indentation.
> >> >     I've seen code where  "paste0" has been aliased to a local function
> >> >     named with a single letter to make concatenation more concise.
> >> >
> >> >     Best
> >> >     Tomas
> >> >
> >> >     >
> >> >     >                               Any thoughts?
> >> >     >                               Pavel
> >> >     >
> >> >     > [1] On the off chance that it does, it should easy to check by
> >> >     > searching for "\\\n" in package sources, because a backslash
> >> >     before a
> >> >     > newline is a syntax error outside a string.
> >> >     > ______________________________________________
> >> >     > R-devel at r-project.org mailing list
> >> >     > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> >
> >> >     ______________________________________________
> >> >     R-devel at r-project.org mailing list
> >> >     https://stat.ethz.ch/mailman/listinfo/r-devel
> >> >
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >
> >
> > --
> > Best,
> > Kasper
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @vi@e@gross m@iii@g oii gm@ii@com  Tue Jun  3 01:21:55 2025
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Mon, 2 Jun 2025 19:21:55 -0400
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
 <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
Message-ID: <004601dbd415$21e9be10$65bd3a30$@gmail.com>

My two cents (soon to be discontinued) is that it is not very relevant to compare one computer language ALREADY DESIGNED to another and insist they become the same. Next we will be asked to allow "+" or just adjacency to connect two or more quoted strings because, well, Python does that. Then, we can ask Python to give up using indentation and start using braces because R does that.

Paste and paste0 were planned as THE way R implements what is wanted. Sure, you could create functions with names like %plus% or %concat% or even overload that allow you to implement paste inline but is that much of a gain? Note suggestions here of things that could easily break if certain changes are blindly made.

Here is a trivial solution using %>>>% as an in-line operator you can replace with anything you want:

[1] "HelloThereCruelworld"
> `%>>>%`<- function(a,b) paste0(a,b)
> "Hello" %>>>% "There" %>>>% "Cruel" %>>>% "World"
[1] "HelloThereCruelWorld"

But you want a multi-line approach this works the same:

"Hello" %>>>% 
  "There" %>>>% 
  "Cruel" %>>>% 
  "World"

No backslashes, just the function name at the end of each line. I question how it would be faster than paste or even more readble as the above called paste0 multiple times plus calls a function multiple times.

What exactly is wrong with this:

paste0(
  "Hello",
  "There",
  "Cruel",
  "World"
)

If properly written, you can even place the text left-justified or wherever and it should be quite readable. 

Having said that, yes, it can be very nice to use languages designed differently. R can be used in ways you might not imagine given delayed evaluations. The price of a paste0 call is compensated for by the simplification of some other things but note other packages handling strings are available now like stringi and stringr that may give you some other things you want. You can even overload something like + this way but do NOT do that as it messes lots of things up:

`+`<- function(a,b) paste0(a,b)
"first" +
  "Second" +
  "Third"

A safer approach like the above could be creating your own "objects" that hold text and arranging for that object to treat plus )or other symbols) specially.

I would say on the list of changes and updates to R, this feature may not look like it is worthwhile and may break things. If this feature is really that important to you, and you use it many times in your program, there are fairly oddball solutions such as running a program in an environment (as in POSIT RSTUDIO) that allows python and R to work together on a single set of data so python can be used to create variables like the ones you want and R can then use them. I suspect you might find such a solution far worse than just using R the way it was designed.





-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Josiah Parry
Sent: Monday, June 2, 2025 5:18 PM
To: Kasper Daniel Hansen <kasperdanielhansen at gmail.com>
Cc: r-devel at r-project.org
Subject: Re: [Rd] Specifying a long string literal across several lines

I suppose taste is learned as well. It does feel quite odd that the best
way to define a long string without a note or text wrapping is by being
creative with functions.

This is valid in Python, Julia, and Rust (if you add `let` and a
terminating semi-colon):

my_str = "part1\
part2\
part2"

I don't think it is abnormal to expect or desire this type of functionality
in our favorite language.

On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
kasperdanielhansen at gmail.com> wrote:

> Like Tomas, I find the paste0 readability to be **much** better, partly
> because it allows for better indentation (as Tomas pointed out). Perhaps a
> pointless email, but sometimes - for these subjective issues - it is
> worthwhile to point out a difference in opinion.
>
> Best,
> Kasper
>
> On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
> wrote:
>
>>
>> On 6/2/25 17:37, Josiah Parry wrote:
>> > Tomas,
>> >
>> > Here is a good example of where this functionality would be useful:
>> >
>> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
>> >
>> > In order to prevent R CMD check notes I have to use `paste0()` to
>> > concatenate long URLs. If we were able to use `\` to
>> > separate the string across multiple lines, it would make the solution
>> > much nicer!
>>
>> It may be a matter of taste. To me the current form
>>
>> #' furl <- paste0(
>> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
>> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
>> #' )
>> #'
>>
>> would be actually clearer than say this:
>>
>> #' # FeatureLayer
>> #' furl <-
>> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
>> PLACES_LocalData_for_BetterHealth/FeatureServer/0
>> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
>> "
>> #'
>>
>> Inside a per-line comment (#), a backslash followed by a newline would
>> probably be disallowed, anyway - e.g. in C it is considered dangerous
>> and is discouraged. And the code resulting from splices is hard to read
>> due to missing indentation. There is also risk of accidentally putting a
>> space after the backslash before the end of line (which some
>> languages/parsers then don't treat as a splice, some do, some issue a
>> warning - of course it is hard to see in the code).
>>
>> The idea of automatically concatenating consecutive string literals as
>> in C would not easily work in R. This is now valid R code:
>>
>> x <- "part1"
>> "part2"
>>
>> if we introduced concatenation, we would change behavior of this code
>> (the value of x would be different, the result of these two lines would
>> be different).
>>
>> I think paste0() is not that bad in the end.
>>
>> Best
>> Tomas
>>
>> > On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
>> > <tomas.kalibera at gmail.com> wrote:
>> >
>> >
>> >     On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
>> >     > Dear All,
>> >     >
>> >     > Perhaps this should go in r-package-devel, but I suspect that
>> >     this is
>> >     > going to turn into a feature request, and I want to run it by
>> >     the list
>> >     > before filing it in the Bugzilla.
>> >     >
>> >     > I would like to specify a long string literal without making the
>> >     line
>> >     > of code too long. In R,
>> >     >
>> >     > "abc
>> >     > def"
>> >     >
>> >     > yields the string "abc\def", and, as far as I can tell, there is
>> no
>> >     > mechanism for preventing it from inserting a newline into the
>> >     string.
>> >     >
>> >     > Putting a backslash before the newline, i.e.,
>> >     >
>> >     > "abc\
>> >     > def"
>> >     >
>> >     > eliminates the newline in (that I know of) C/C++, Python, and
>> Julia,
>> >     > but it makes no difference in R.
>> >     >
>> >     > The implicit concatenation of Python and C/C++, e.g., "abc"
>> >     "def", is a
>> >     > syntax error as well in R.
>> >     >
>> >     > It is, of course, possible to use paste0(), but is there a more
>> >     concise
>> >     > built-in mechanism in R of which I am not aware?
>> >     >
>> >     > If not, I think it would make sense to bring R in line with the
>> >     others.
>> >     > Currently, backslash and no backslash before a newline behave
>> >     > identically (at least as far as I can tell), so I doubt that a
>> >     > nontrivial amount of code relies on the current behaviour. [1]
>> >
>> >     What would be real example of a long string literal you would want
>> to
>> >     enter this way?
>> >
>> >     For entering a long text with newlines, one can use raw strings in R
>> >     (see ?Quotes) - but there you would see the newlines and
>> indentation.
>> >     I've seen code where  "paste0" has been aliased to a local function
>> >     named with a single letter to make concatenation more concise.
>> >
>> >     Best
>> >     Tomas
>> >
>> >     >
>> >     >                               Any thoughts?
>> >     >                               Pavel
>> >     >
>> >     > [1] On the off chance that it does, it should easy to check by
>> >     > searching for "\\\n" in package sources, because a backslash
>> >     before a
>> >     > newline is a syntax error outside a string.
>> >     > ______________________________________________
>> >     > R-devel at r-project.org mailing list
>> >     > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>> >     ______________________________________________
>> >     R-devel at r-project.org mailing list
>> >     https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>
>
> --
> Best,
> Kasper
>

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From @vi@e@gross m@iii@g oii gm@ii@com  Tue Jun  3 01:24:13 2025
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Mon, 2 Jun 2025 19:24:13 -0400
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
 <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
 <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>
Message-ID: <004701dbd415$739f67f0$5ade37d0$@gmail.com>

Henrik,

As R is an interpreted language and paste0 is likely a nice and fast built-in function likely already written in some version of C, there does not seem much room for a speedup as everything is done at run time. The parser phase may indeed have abilities to simplify but often at the expense of a more complex, and perhaps slow, parser.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Henrik Bengtsson
Sent: Monday, June 2, 2025 5:34 PM
To: Josiah Parry <josiah.parry at gmail.com>
Cc: r-devel at r-project.org
Subject: Re: [Rd] Specifying a long string literal across several lines

One could also argue that paste0("a", "b", "c") is a function call
that needs to be evaluated at runtime, whereas "abc" is a string
constant understood by the parser, and often also language agnostic.
I'd assume compilers and code- and text-search tools do a better job
with the latter.

/Henrik

On Mon, Jun 2, 2025 at 2:18?PM Josiah Parry <josiah.parry at gmail.com> wrote:
>
> I suppose taste is learned as well. It does feel quite odd that the best
> way to define a long string without a note or text wrapping is by being
> creative with functions.
>
> This is valid in Python, Julia, and Rust (if you add `let` and a
> terminating semi-colon):
>
> my_str = "part1\
> part2\
> part2"
>
> I don't think it is abnormal to expect or desire this type of functionality
> in our favorite language.
>
> On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
> kasperdanielhansen at gmail.com> wrote:
>
> > Like Tomas, I find the paste0 readability to be **much** better, partly
> > because it allows for better indentation (as Tomas pointed out). Perhaps a
> > pointless email, but sometimes - for these subjective issues - it is
> > worthwhile to point out a difference in opinion.
> >
> > Best,
> > Kasper
> >
> > On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
> > wrote:
> >
> >>
> >> On 6/2/25 17:37, Josiah Parry wrote:
> >> > Tomas,
> >> >
> >> > Here is a good example of where this functionality would be useful:
> >> >
> >> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
> >> >
> >> > In order to prevent R CMD check notes I have to use `paste0()` to
> >> > concatenate long URLs. If we were able to use `\` to
> >> > separate the string across multiple lines, it would make the solution
> >> > much nicer!
> >>
> >> It may be a matter of taste. To me the current form
> >>
> >> #' furl <- paste0(
> >> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
> >> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
> >> #' )
> >> #'
> >>
> >> would be actually clearer than say this:
> >>
> >> #' # FeatureLayer
> >> #' furl <-
> >> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
> >> PLACES_LocalData_for_BetterHealth/FeatureServer/0
> >> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
> >> "
> >> #'
> >>
> >> Inside a per-line comment (#), a backslash followed by a newline would
> >> probably be disallowed, anyway - e.g. in C it is considered dangerous
> >> and is discouraged. And the code resulting from splices is hard to read
> >> due to missing indentation. There is also risk of accidentally putting a
> >> space after the backslash before the end of line (which some
> >> languages/parsers then don't treat as a splice, some do, some issue a
> >> warning - of course it is hard to see in the code).
> >>
> >> The idea of automatically concatenating consecutive string literals as
> >> in C would not easily work in R. This is now valid R code:
> >>
> >> x <- "part1"
> >> "part2"
> >>
> >> if we introduced concatenation, we would change behavior of this code
> >> (the value of x would be different, the result of these two lines would
> >> be different).
> >>
> >> I think paste0() is not that bad in the end.
> >>
> >> Best
> >> Tomas
> >>
> >> > On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
> >> > <tomas.kalibera at gmail.com> wrote:
> >> >
> >> >
> >> >     On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
> >> >     > Dear All,
> >> >     >
> >> >     > Perhaps this should go in r-package-devel, but I suspect that
> >> >     this is
> >> >     > going to turn into a feature request, and I want to run it by
> >> >     the list
> >> >     > before filing it in the Bugzilla.
> >> >     >
> >> >     > I would like to specify a long string literal without making the
> >> >     line
> >> >     > of code too long. In R,
> >> >     >
> >> >     > "abc
> >> >     > def"
> >> >     >
> >> >     > yields the string "abc\def", and, as far as I can tell, there is
> >> no
> >> >     > mechanism for preventing it from inserting a newline into the
> >> >     string.
> >> >     >
> >> >     > Putting a backslash before the newline, i.e.,
> >> >     >
> >> >     > "abc\
> >> >     > def"
> >> >     >
> >> >     > eliminates the newline in (that I know of) C/C++, Python, and
> >> Julia,
> >> >     > but it makes no difference in R.
> >> >     >
> >> >     > The implicit concatenation of Python and C/C++, e.g., "abc"
> >> >     "def", is a
> >> >     > syntax error as well in R.
> >> >     >
> >> >     > It is, of course, possible to use paste0(), but is there a more
> >> >     concise
> >> >     > built-in mechanism in R of which I am not aware?
> >> >     >
> >> >     > If not, I think it would make sense to bring R in line with the
> >> >     others.
> >> >     > Currently, backslash and no backslash before a newline behave
> >> >     > identically (at least as far as I can tell), so I doubt that a
> >> >     > nontrivial amount of code relies on the current behaviour. [1]
> >> >
> >> >     What would be real example of a long string literal you would want
> >> to
> >> >     enter this way?
> >> >
> >> >     For entering a long text with newlines, one can use raw strings in R
> >> >     (see ?Quotes) - but there you would see the newlines and
> >> indentation.
> >> >     I've seen code where  "paste0" has been aliased to a local function
> >> >     named with a single letter to make concatenation more concise.
> >> >
> >> >     Best
> >> >     Tomas
> >> >
> >> >     >
> >> >     >                               Any thoughts?
> >> >     >                               Pavel
> >> >     >
> >> >     > [1] On the off chance that it does, it should easy to check by
> >> >     > searching for "\\\n" in package sources, because a backslash
> >> >     before a
> >> >     > newline is a syntax error outside a string.
> >> >     > ______________________________________________
> >> >     > R-devel at r-project.org mailing list
> >> >     > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> >
> >> >     ______________________________________________
> >> >     R-devel at r-project.org mailing list
> >> >     https://stat.ethz.ch/mailman/listinfo/r-devel
> >> >
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >
> >
> > --
> > Best,
> > Kasper
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From @|mon@urb@nek @end|ng |rom R-project@org  Tue Jun  3 01:48:25 2025
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Tue, 3 Jun 2025 11:48:25 +1200
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
 <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
 <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>
Message-ID: <CD025F68-B54D-4A3C-BB34-B32E8447C089@R-project.org>



> On 3 Jun 2025, at 09:34, Henrik Bengtsson <henrik.bengtsson at gmail.com> wrote:
> 
> One could also argue that paste0("a", "b", "c") is a function call that needs to be evaluated at runtime, whereas "abc" is a string constant understood by the parser, and often also language agnostic. I'd assume compilers and code- and text-search tools do a better job with the latter.
> 


Well, about that, just to illustrate how insane that is:

$ cat foo.py 
if True:
    a = "foo\
    bar\
    !"
    print(a)
$ python3 foo.py
foo    bar    !

in particular for a language that insist on the space being part of the syntax ;) - so it forces you to indent things and yet it breaks badly in those strings.

I don?t have a strong opinion, but I agree that it is very bad for readability so definitely not something that should be recommended.

That said, in R we tend to offer many tools that allow you to shoot yourself in the foot, so some might argue that one more is not going to hurt ;) - not everyone wants their code to be readable?

Cheers,
Simon


> 
> 
> On Mon, Jun 2, 2025 at 2:18?PM Josiah Parry <josiah.parry at gmail.com> wrote:
>> 
>> I suppose taste is learned as well. It does feel quite odd that the best
>> way to define a long string without a note or text wrapping is by being
>> creative with functions.
>> 
>> This is valid in Python, Julia, and Rust (if you add `let` and a
>> terminating semi-colon):
>> 
>> my_str = "part1\
>> part2\
>> part2"
>> 
>> I don't think it is abnormal to expect or desire this type of functionality
>> in our favorite language.
>> 
>> On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
>> kasperdanielhansen at gmail.com> wrote:
>> 
>>> Like Tomas, I find the paste0 readability to be **much** better, partly
>>> because it allows for better indentation (as Tomas pointed out). Perhaps a
>>> pointless email, but sometimes - for these subjective issues - it is
>>> worthwhile to point out a difference in opinion.
>>> 
>>> Best,
>>> Kasper
>>> 
>>> On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
>>> wrote:
>>> 
>>>> 
>>>> On 6/2/25 17:37, Josiah Parry wrote:
>>>>> Tomas,
>>>>> 
>>>>> Here is a good example of where this functionality would be useful:
>>>>> 
>>>> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
>>>>> 
>>>>> In order to prevent R CMD check notes I have to use `paste0()` to
>>>>> concatenate long URLs. If we were able to use `\` to
>>>>> separate the string across multiple lines, it would make the solution
>>>>> much nicer!
>>>> 
>>>> It may be a matter of taste. To me the current form
>>>> 
>>>> #' furl <- paste0(
>>>> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
>>>> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
>>>> #' )
>>>> #'
>>>> 
>>>> would be actually clearer than say this:
>>>> 
>>>> #' # FeatureLayer
>>>> #' furl <-
>>>> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
>>>> PLACES_LocalData_for_BetterHealth/FeatureServer/0
>>>> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
>>>> "
>>>> #'
>>>> 
>>>> Inside a per-line comment (#), a backslash followed by a newline would
>>>> probably be disallowed, anyway - e.g. in C it is considered dangerous
>>>> and is discouraged. And the code resulting from splices is hard to read
>>>> due to missing indentation. There is also risk of accidentally putting a
>>>> space after the backslash before the end of line (which some
>>>> languages/parsers then don't treat as a splice, some do, some issue a
>>>> warning - of course it is hard to see in the code).
>>>> 
>>>> The idea of automatically concatenating consecutive string literals as
>>>> in C would not easily work in R. This is now valid R code:
>>>> 
>>>> x <- "part1"
>>>> "part2"
>>>> 
>>>> if we introduced concatenation, we would change behavior of this code
>>>> (the value of x would be different, the result of these two lines would
>>>> be different).
>>>> 
>>>> I think paste0() is not that bad in the end.
>>>> 
>>>> Best
>>>> Tomas
>>>> 
>>>>> On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
>>>>> <tomas.kalibera at gmail.com> wrote:
>>>>> 
>>>>> 
>>>>>    On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
>>>>>> Dear All,
>>>>>> 
>>>>>> Perhaps this should go in r-package-devel, but I suspect that
>>>>>    this is
>>>>>> going to turn into a feature request, and I want to run it by
>>>>>    the list
>>>>>> before filing it in the Bugzilla.
>>>>>> 
>>>>>> I would like to specify a long string literal without making the
>>>>>    line
>>>>>> of code too long. In R,
>>>>>> 
>>>>>> "abc
>>>>>> def"
>>>>>> 
>>>>>> yields the string "abc\def", and, as far as I can tell, there is
>>>> no
>>>>>> mechanism for preventing it from inserting a newline into the
>>>>>    string.
>>>>>> 
>>>>>> Putting a backslash before the newline, i.e.,
>>>>>> 
>>>>>> "abc\
>>>>>> def"
>>>>>> 
>>>>>> eliminates the newline in (that I know of) C/C++, Python, and
>>>> Julia,
>>>>>> but it makes no difference in R.
>>>>>> 
>>>>>> The implicit concatenation of Python and C/C++, e.g., "abc"
>>>>>    "def", is a
>>>>>> syntax error as well in R.
>>>>>> 
>>>>>> It is, of course, possible to use paste0(), but is there a more
>>>>>    concise
>>>>>> built-in mechanism in R of which I am not aware?
>>>>>> 
>>>>>> If not, I think it would make sense to bring R in line with the
>>>>>    others.
>>>>>> Currently, backslash and no backslash before a newline behave
>>>>>> identically (at least as far as I can tell), so I doubt that a
>>>>>> nontrivial amount of code relies on the current behaviour. [1]
>>>>> 
>>>>>    What would be real example of a long string literal you would want
>>>> to
>>>>>    enter this way?
>>>>> 
>>>>>    For entering a long text with newlines, one can use raw strings in R
>>>>>    (see ?Quotes) - but there you would see the newlines and
>>>> indentation.
>>>>>    I've seen code where  "paste0" has been aliased to a local function
>>>>>    named with a single letter to make concatenation more concise.
>>>>> 
>>>>>    Best
>>>>>    Tomas
>>>>> 
>>>>>> 
>>>>>>                              Any thoughts?
>>>>>>                              Pavel
>>>>>> 
>>>>>> [1] On the off chance that it does, it should easy to check by
>>>>>> searching for "\\\n" in package sources, because a backslash
>>>>>    before a
>>>>>> newline is a syntax error outside a string.
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>>>>    ______________________________________________
>>>>>    R-devel at r-project.org mailing list
>>>>>    https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>> 
>>> 
>>> --
>>> Best,
>>> Kasper
>>> 
>> 
>>        [[alternative HTML version deleted]]
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From kev|nu@hey @end|ng |rom gm@||@com  Tue Jun  3 02:33:18 2025
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Mon, 2 Jun 2025 17:33:18 -0700
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CD025F68-B54D-4A3C-BB34-B32E8447C089@R-project.org>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
 <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
 <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>
 <CD025F68-B54D-4A3C-BB34-B32E8447C089@R-project.org>
Message-ID: <CAJXgQP3jiApYgAf+GLObWr0dRAbNtUWJt-QF4zAHPU6nFS=fHg@mail.gmail.com>

I also suspect the byte compiler could constant-fold some of these
common paste expressions, effectively negating any potential runtime
cost of `paste` / `paste0` with string literals.

Beyond the syntax restrictions for automatic concatenation of
sequential string literals, it's also a big footgun. It's easy to
accidentally write code like this:

  yum <- c(
    "apple",
    "banana",
    "cherry"
    "danish"
  )

and in this scenario, instead of an error, you'd just quietly get 3
strings instead of the intended 4. This sort of code is easy to
accidentally write if you're updating an existing list by adding
another member.

All this said, I think the conversation has strayed from the original
request, which was around whether R could handle EOL escapes as a
means of creating longer strings. I think it's a reasonable request,
but it does lead to (IMHO) awkward code where you might have an
indented code block, but a multiline string which would no longer
match the code indentation. That's ultimately a matter of taste,
though.

For what it's worth, I've occasionally defined helper functions which
try to trim common indentation and join newlines in long strings, e.g.

z <- function(text, collapse = " ")  {
    trimmed <- gsub("^\\s*\\n|\\n\\s*$", "", text)
    lines <- strsplit(trimmed, "\n", fixed = TRUE)[[1L]]
    indent <- regexpr("[^[:space:]]", lines)
    common <- min(setdiff(indent, -1L))
    paste(substring(lines, common, nchar(lines)), collapse = collapse)
}

with example:

> z('
+     This is some text.
+     It spans multiple lines.
+ ')
[1] "This is some text. It spans multiple lines."

and personally I prefer reading (and writing) longer strings in this
form, as opposed to adorning text with trailing slashes.

Best,
Kevin

On Mon, Jun 2, 2025 at 4:49?PM Simon Urbanek
<simon.urbanek at r-project.org> wrote:
>
>
>
> > On 3 Jun 2025, at 09:34, Henrik Bengtsson <henrik.bengtsson at gmail.com> wrote:
> >
> > One could also argue that paste0("a", "b", "c") is a function call that needs to be evaluated at runtime, whereas "abc" is a string constant understood by the parser, and often also language agnostic. I'd assume compilers and code- and text-search tools do a better job with the latter.
> >
>
>
> Well, about that, just to illustrate how insane that is:
>
> $ cat foo.py
> if True:
>     a = "foo\
>     bar\
>     !"
>     print(a)
> $ python3 foo.py
> foo    bar    !
>
> in particular for a language that insist on the space being part of the syntax ;) - so it forces you to indent things and yet it breaks badly in those strings.
>
> I don?t have a strong opinion, but I agree that it is very bad for readability so definitely not something that should be recommended.
>
> That said, in R we tend to offer many tools that allow you to shoot yourself in the foot, so some might argue that one more is not going to hurt ;) - not everyone wants their code to be readable?
>
> Cheers,
> Simon
>
>
> >
> >
> > On Mon, Jun 2, 2025 at 2:18?PM Josiah Parry <josiah.parry at gmail.com> wrote:
> >>
> >> I suppose taste is learned as well. It does feel quite odd that the best
> >> way to define a long string without a note or text wrapping is by being
> >> creative with functions.
> >>
> >> This is valid in Python, Julia, and Rust (if you add `let` and a
> >> terminating semi-colon):
> >>
> >> my_str = "part1\
> >> part2\
> >> part2"
> >>
> >> I don't think it is abnormal to expect or desire this type of functionality
> >> in our favorite language.
> >>
> >> On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
> >> kasperdanielhansen at gmail.com> wrote:
> >>
> >>> Like Tomas, I find the paste0 readability to be **much** better, partly
> >>> because it allows for better indentation (as Tomas pointed out). Perhaps a
> >>> pointless email, but sometimes - for these subjective issues - it is
> >>> worthwhile to point out a difference in opinion.
> >>>
> >>> Best,
> >>> Kasper
> >>>
> >>> On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
> >>> wrote:
> >>>
> >>>>
> >>>> On 6/2/25 17:37, Josiah Parry wrote:
> >>>>> Tomas,
> >>>>>
> >>>>> Here is a good example of where this functionality would be useful:
> >>>>>
> >>>> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
> >>>>>
> >>>>> In order to prevent R CMD check notes I have to use `paste0()` to
> >>>>> concatenate long URLs. If we were able to use `\` to
> >>>>> separate the string across multiple lines, it would make the solution
> >>>>> much nicer!
> >>>>
> >>>> It may be a matter of taste. To me the current form
> >>>>
> >>>> #' furl <- paste0(
> >>>> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
> >>>> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
> >>>> #' )
> >>>> #'
> >>>>
> >>>> would be actually clearer than say this:
> >>>>
> >>>> #' # FeatureLayer
> >>>> #' furl <-
> >>>> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
> >>>> PLACES_LocalData_for_BetterHealth/FeatureServer/0
> >>>> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
> >>>> "
> >>>> #'
> >>>>
> >>>> Inside a per-line comment (#), a backslash followed by a newline would
> >>>> probably be disallowed, anyway - e.g. in C it is considered dangerous
> >>>> and is discouraged. And the code resulting from splices is hard to read
> >>>> due to missing indentation. There is also risk of accidentally putting a
> >>>> space after the backslash before the end of line (which some
> >>>> languages/parsers then don't treat as a splice, some do, some issue a
> >>>> warning - of course it is hard to see in the code).
> >>>>
> >>>> The idea of automatically concatenating consecutive string literals as
> >>>> in C would not easily work in R. This is now valid R code:
> >>>>
> >>>> x <- "part1"
> >>>> "part2"
> >>>>
> >>>> if we introduced concatenation, we would change behavior of this code
> >>>> (the value of x would be different, the result of these two lines would
> >>>> be different).
> >>>>
> >>>> I think paste0() is not that bad in the end.
> >>>>
> >>>> Best
> >>>> Tomas
> >>>>
> >>>>> On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
> >>>>> <tomas.kalibera at gmail.com> wrote:
> >>>>>
> >>>>>
> >>>>>    On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
> >>>>>> Dear All,
> >>>>>>
> >>>>>> Perhaps this should go in r-package-devel, but I suspect that
> >>>>>    this is
> >>>>>> going to turn into a feature request, and I want to run it by
> >>>>>    the list
> >>>>>> before filing it in the Bugzilla.
> >>>>>>
> >>>>>> I would like to specify a long string literal without making the
> >>>>>    line
> >>>>>> of code too long. In R,
> >>>>>>
> >>>>>> "abc
> >>>>>> def"
> >>>>>>
> >>>>>> yields the string "abc\def", and, as far as I can tell, there is
> >>>> no
> >>>>>> mechanism for preventing it from inserting a newline into the
> >>>>>    string.
> >>>>>>
> >>>>>> Putting a backslash before the newline, i.e.,
> >>>>>>
> >>>>>> "abc\
> >>>>>> def"
> >>>>>>
> >>>>>> eliminates the newline in (that I know of) C/C++, Python, and
> >>>> Julia,
> >>>>>> but it makes no difference in R.
> >>>>>>
> >>>>>> The implicit concatenation of Python and C/C++, e.g., "abc"
> >>>>>    "def", is a
> >>>>>> syntax error as well in R.
> >>>>>>
> >>>>>> It is, of course, possible to use paste0(), but is there a more
> >>>>>    concise
> >>>>>> built-in mechanism in R of which I am not aware?
> >>>>>>
> >>>>>> If not, I think it would make sense to bring R in line with the
> >>>>>    others.
> >>>>>> Currently, backslash and no backslash before a newline behave
> >>>>>> identically (at least as far as I can tell), so I doubt that a
> >>>>>> nontrivial amount of code relies on the current behaviour. [1]
> >>>>>
> >>>>>    What would be real example of a long string literal you would want
> >>>> to
> >>>>>    enter this way?
> >>>>>
> >>>>>    For entering a long text with newlines, one can use raw strings in R
> >>>>>    (see ?Quotes) - but there you would see the newlines and
> >>>> indentation.
> >>>>>    I've seen code where  "paste0" has been aliased to a local function
> >>>>>    named with a single letter to make concatenation more concise.
> >>>>>
> >>>>>    Best
> >>>>>    Tomas
> >>>>>
> >>>>>>
> >>>>>>                              Any thoughts?
> >>>>>>                              Pavel
> >>>>>>
> >>>>>> [1] On the off chance that it does, it should easy to check by
> >>>>>> searching for "\\\n" in package sources, because a backslash
> >>>>>    before a
> >>>>>> newline is a syntax error outside a string.
> >>>>>> ______________________________________________
> >>>>>> R-devel at r-project.org mailing list
> >>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>
> >>>>>    ______________________________________________
> >>>>>    R-devel at r-project.org mailing list
> >>>>>    https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>
> >>>>
> >>>> ______________________________________________
> >>>> R-devel at r-project.org mailing list
> >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>
> >>>
> >>> --
> >>> Best,
> >>> Kasper
> >>>
> >>
> >>        [[alternative HTML version deleted]]
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @vi@e@gross m@iii@g oii gm@ii@com  Tue Jun  3 03:22:29 2025
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Mon, 2 Jun 2025 21:22:29 -0400
Subject: [Rd] Specifying a long string literal across several lines
In-Reply-To: <CD025F68-B54D-4A3C-BB34-B32E8447C089@R-project.org>
References: <0d740a410d3ad7629105ad508f6969f2c9785e79.camel@unsw.edu.au>
 <967f1f49-c268-4208-803b-e7af29d3e95c@gmail.com>
 <CAL3ufUJ+WZ5OdTnPHo92eyaYpz0vJVoQ+tQ-ubPE20skL4ZAQg@mail.gmail.com>
 <8ef51649-79e5-475d-8c2c-3b6109e895ca@gmail.com>
 <CAC2h7utOWGLLRaUJYqmam0R88O4kLQUPqE7-mzi39wJoTQUELw@mail.gmail.com>
 <CAL3ufULVP7CYpFWPU40KgfAzh9ic2L5MzJDt=Xr5gT15KO27VA@mail.gmail.com>
 <CAFDcVCTOsgLN+TPQruixyqKh4-OjWKzoaqKQRa_81xX7qg7m9w@mail.gmail.com>
 <CD025F68-B54D-4A3C-BB34-B32E8447C089@R-project.org>
Message-ID: <005201dbd425$f9463d10$ebd2b730$@gmail.com>

Have we talked this topic out yet?

As has been mentioned, R allows many strategies with perhaps the simplest being to use the paste functions. Here, is a not simpler version where you do a global substitution that removes it alongside the artificial newlines.

gsub(pattern="\n",
     replacement="",
     x="Hello
And
Goodbye")

Result:
[1] "HelloAndGoodbye"

Is it worth the bother? I think not . It does work but I suspect gsub (or similar functions) that do a lot more, may be as inefficient or even more than the paste0 alternative.



-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Simon Urbanek
Sent: Monday, June 2, 2025 7:48 PM
To: Henrik Bengtsson <henrik.bengtsson at gmail.com>
Cc: r-devel at r-project.org
Subject: Re: [Rd] Specifying a long string literal across several lines



> On 3 Jun 2025, at 09:34, Henrik Bengtsson <henrik.bengtsson at gmail.com> wrote:
> 
> One could also argue that paste0("a", "b", "c") is a function call that needs to be evaluated at runtime, whereas "abc" is a string constant understood by the parser, and often also language agnostic. I'd assume compilers and code- and text-search tools do a better job with the latter.
> 


Well, about that, just to illustrate how insane that is:

$ cat foo.py 
if True:
    a = "foo\
    bar\
    !"
    print(a)
$ python3 foo.py
foo    bar    !

in particular for a language that insist on the space being part of the syntax ;) - so it forces you to indent things and yet it breaks badly in those strings.

I don?t have a strong opinion, but I agree that it is very bad for readability so definitely not something that should be recommended.

That said, in R we tend to offer many tools that allow you to shoot yourself in the foot, so some might argue that one more is not going to hurt ;) - not everyone wants their code to be readable?

Cheers,
Simon


> 
> 
> On Mon, Jun 2, 2025 at 2:18?PM Josiah Parry <josiah.parry at gmail.com> wrote:
>> 
>> I suppose taste is learned as well. It does feel quite odd that the best
>> way to define a long string without a note or text wrapping is by being
>> creative with functions.
>> 
>> This is valid in Python, Julia, and Rust (if you add `let` and a
>> terminating semi-colon):
>> 
>> my_str = "part1\
>> part2\
>> part2"
>> 
>> I don't think it is abnormal to expect or desire this type of functionality
>> in our favorite language.
>> 
>> On Mon, Jun 2, 2025 at 13:59 Kasper Daniel Hansen <
>> kasperdanielhansen at gmail.com> wrote:
>> 
>>> Like Tomas, I find the paste0 readability to be **much** better, partly
>>> because it allows for better indentation (as Tomas pointed out). Perhaps a
>>> pointless email, but sometimes - for these subjective issues - it is
>>> worthwhile to point out a difference in opinion.
>>> 
>>> Best,
>>> Kasper
>>> 
>>> On Mon, Jun 2, 2025 at 12:27?PM Tomas Kalibera <tomas.kalibera at gmail.com>
>>> wrote:
>>> 
>>>> 
>>>> On 6/2/25 17:37, Josiah Parry wrote:
>>>>> Tomas,
>>>>> 
>>>>> Here is a good example of where this functionality would be useful:
>>>>> 
>>>> https://github.com/R-ArcGIS/arcgislayers/blob/2b29f4c254e7e5a1dadce8d4b0015a70dfae39d4/R/arc-open.R#L19-L56
>>>>> 
>>>>> In order to prevent R CMD check notes I have to use `paste0()` to
>>>>> concatenate long URLs. If we were able to use `\` to
>>>>> separate the string across multiple lines, it would make the solution
>>>>> much nicer!
>>>> 
>>>> It may be a matter of taste. To me the current form
>>>> 
>>>> #' furl <- paste0(
>>>> #' "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/",
>>>> #'   "PLACES_LocalData_for_BetterHealth/FeatureServer/0"
>>>> #' )
>>>> #'
>>>> 
>>>> would be actually clearer than say this:
>>>> 
>>>> #' # FeatureLayer
>>>> #' furl <-
>>>> "https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/\
>>>> PLACES_LocalData_for_BetterHealth/FeatureServer/0
>>>> <https://services3.arcgis.com/ZvidGQkLaDJxRSJ2/arcgis/rest/services/%5CPLACES_LocalData_for_BetterHealth/FeatureServer/0>
>>>> "
>>>> #'
>>>> 
>>>> Inside a per-line comment (#), a backslash followed by a newline would
>>>> probably be disallowed, anyway - e.g. in C it is considered dangerous
>>>> and is discouraged. And the code resulting from splices is hard to read
>>>> due to missing indentation. There is also risk of accidentally putting a
>>>> space after the backslash before the end of line (which some
>>>> languages/parsers then don't treat as a splice, some do, some issue a
>>>> warning - of course it is hard to see in the code).
>>>> 
>>>> The idea of automatically concatenating consecutive string literals as
>>>> in C would not easily work in R. This is now valid R code:
>>>> 
>>>> x <- "part1"
>>>> "part2"
>>>> 
>>>> if we introduced concatenation, we would change behavior of this code
>>>> (the value of x would be different, the result of these two lines would
>>>> be different).
>>>> 
>>>> I think paste0() is not that bad in the end.
>>>> 
>>>> Best
>>>> Tomas
>>>> 
>>>>> On Mon, Jun 2, 2025 at 3:19?AM Tomas Kalibera
>>>>> <tomas.kalibera at gmail.com> wrote:
>>>>> 
>>>>> 
>>>>>    On 5/28/25 04:15, Pavel Krivitsky via R-devel wrote:
>>>>>> Dear All,
>>>>>> 
>>>>>> Perhaps this should go in r-package-devel, but I suspect that
>>>>>    this is
>>>>>> going to turn into a feature request, and I want to run it by
>>>>>    the list
>>>>>> before filing it in the Bugzilla.
>>>>>> 
>>>>>> I would like to specify a long string literal without making the
>>>>>    line
>>>>>> of code too long. In R,
>>>>>> 
>>>>>> "abc
>>>>>> def"
>>>>>> 
>>>>>> yields the string "abc\def", and, as far as I can tell, there is
>>>> no
>>>>>> mechanism for preventing it from inserting a newline into the
>>>>>    string.
>>>>>> 
>>>>>> Putting a backslash before the newline, i.e.,
>>>>>> 
>>>>>> "abc\
>>>>>> def"
>>>>>> 
>>>>>> eliminates the newline in (that I know of) C/C++, Python, and
>>>> Julia,
>>>>>> but it makes no difference in R.
>>>>>> 
>>>>>> The implicit concatenation of Python and C/C++, e.g., "abc"
>>>>>    "def", is a
>>>>>> syntax error as well in R.
>>>>>> 
>>>>>> It is, of course, possible to use paste0(), but is there a more
>>>>>    concise
>>>>>> built-in mechanism in R of which I am not aware?
>>>>>> 
>>>>>> If not, I think it would make sense to bring R in line with the
>>>>>    others.
>>>>>> Currently, backslash and no backslash before a newline behave
>>>>>> identically (at least as far as I can tell), so I doubt that a
>>>>>> nontrivial amount of code relies on the current behaviour. [1]
>>>>> 
>>>>>    What would be real example of a long string literal you would want
>>>> to
>>>>>    enter this way?
>>>>> 
>>>>>    For entering a long text with newlines, one can use raw strings in R
>>>>>    (see ?Quotes) - but there you would see the newlines and
>>>> indentation.
>>>>>    I've seen code where  "paste0" has been aliased to a local function
>>>>>    named with a single letter to make concatenation more concise.
>>>>> 
>>>>>    Best
>>>>>    Tomas
>>>>> 
>>>>>> 
>>>>>>                              Any thoughts?
>>>>>>                              Pavel
>>>>>> 
>>>>>> [1] On the off chance that it does, it should easy to check by
>>>>>> searching for "\\\n" in package sources, because a backslash
>>>>>    before a
>>>>>> newline is a syntax error outside a string.
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>>>>    ______________________________________________
>>>>>    R-devel at r-project.org mailing list
>>>>>    https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>> 
>>> 
>>> --
>>> Best,
>>> Kasper
>>> 
>> 
>>        [[alternative HTML version deleted]]
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From Kurt@Horn|k @end|ng |rom wu@@c@@t  Tue Jun  3 19:23:01 2025
From: Kurt@Horn|k @end|ng |rom wu@@c@@t (Kurt Hornik)
Date: Tue, 3 Jun 2025 19:23:01 +0200
Subject: [Rd] FR: improve "use" function
In-Reply-To: <X_sz0Ee-RPDu7Lm1TnpUx4ZGuqttBwjET2Y7L7JRpWGvuPPf-HimC3nxs2B81iO7hE9ktfO-Fg0mSyx26HV5TskEp_Zf2F5_OkE781GUO8Y=@protonmail.ch>
References: <ffdeb8bc-bec8-49cc-b6b4-6f0a6b2b2b88@thuenen.de>
 <CAMigB8Ef9QB27aj1OP7T1dhG4qPmM3YjMWs7XTrxA+BkY7CGkg@mail.gmail.com>
 <26677.26109.816335.849333@hornik.net>
 <X_sz0Ee-RPDu7Lm1TnpUx4ZGuqttBwjET2Y7L7JRpWGvuPPf-HimC3nxs2B81iO7hE9ktfO-Fg0mSyx26HV5TskEp_Zf2F5_OkE781GUO8Y=@protonmail.ch>
Message-ID: <26687.12149.851300.842290@hornik.net>

>>>>> Laurent Gatto writes:

Thanks.

In general, I guess we all agree that if 'include.only' or 'exclude' ask
for something (currently) impossible then a suitably classed condition
object should be thrown.  Could be both a warning or an error ...

And perhaps we should take 'include.only' as 'include', i.e., be fine
when we give 'include.only' as a subset of what is already included.

Personally, I am not a big fan of suggesting to use detach() in the
condition message.

Best
-k

> On Tuesday, May 27th, 2025 at 9:13 AM, Kurt Hornik <Kurt.Hornik at wu.ac.at> wrote:
>> > > > > > Trevor Davis writes:
>> 
>> 
>> Thanks.
>> 
>> This is really about what
>> 
>> library("foo", include.only = "fun2")
>> 
>> should do if package 'foo' was already attached and the include.only
>> contradicts a previous specification.
>> 
>> In principle, one could look into allowing the underlying
>> attachNamespace() to add more exports into the package environment (the
>> 'only' in 'include.only' might suggest differently, but we would have to
>> live with that). However, using detach/attach is not the right way of
>> doing this, as it possibly modifies the search path and may trigger
>> hooks that should not be triggered. Doing it right would probably need
>> an .Internal and hence be a lot of work ...
>> 
>> What definitely needs attention is the fact that currently the above is
>> silently ignored. So at least for now we should teach attachNamespace()
>> to throw a suitably classed error if called with include.only that
>> contradicts a previous specification.
>> 
>> Contributions welcome :-)

> Some work has been done on that front during last week's r-dev-day
> with Ella Kaye and Philippe Grosjean [1]. After some more thinking, I
> think we haven't been stringent enough, and would suggest that the
> user should be alerted as soon as what they want to attach doesn't
> match exactly what is already on the search path. Something along the
> lines of (the warning/message can of course be amended).

> These two situations are OK, given that exactly the same set is asked
> for repeated, either with a limited set of functions:

>> library("Matrix", include.only = "isDiagonal")
>> library("Matrix", include.only = "isDiagonal") ## ok

> or, in a new session, with the whole package:

>> library("Matrix", include.only = "isDiagonal")
>> library("Matrix", include.only = "isDiagonal") ## ok

> Below, (again, in a new session) the user could be mislead that either
> only qr would be attached (and isDiagonal not anymore), or all
> Matrix's exported symbols:

>> library("Matrix", include.only = "isDiagonal")
>> library("Matrix", include.only = "qr") ## warn
> Warning message:
> In library("Matrix", include.only = "qr") :
>   The package 'Matrix' is already loaded with a different set of functions. Please detach() it first.
>> library("Matrix") ## warn
> Warning message:
> In library("Matrix") :
>   The package 'Matrix' is already loaded with a different set of functions. Please detach() it first.

> In the following cases, a subset is asked after all symbols are
> attached, which also triggers a warning/message:

>> library("Matrix")
>> library("Matrix", exclude = "isDiagonal") ## warn
> Warning message:
> In library("Matrix", exclude = "isDiagonal") :
>   The package 'Matrix' is already loaded with a different set of functions. Please detach() it first.
>> library("Matrix", include.only = "isDiagonal") ## warn
> Warning message:
> In library("Matrix", include.only = "isDiagonal") :
>   The package 'Matrix' is already loaded with a different set of functions. Please detach() it first.

> If this is a good way forward, I would be happy to carry on that work.

> Laurent


> [1] https://github.com/r-devel/r-dev-day/issues/48


From ro|@nd@|u@@ @end|ng |rom thuenen@de  Wed Jun  4 14:46:38 2025
From: ro|@nd@|u@@ @end|ng |rom thuenen@de (Roland =?utf-8?B?RnXDnw==?=)
Date: Wed, 4 Jun 2025 14:46:38 +0200 (CEST)
Subject: [Rd] FR: improve "use" function
In-Reply-To: <26687.12149.851300.842290@hornik.net>
References: <ffdeb8bc-bec8-49cc-b6b4-6f0a6b2b2b88@thuenen.de>
 <CAMigB8Ef9QB27aj1OP7T1dhG4qPmM3YjMWs7XTrxA+BkY7CGkg@mail.gmail.com>
 <26677.26109.816335.849333@hornik.net>
 <X_sz0Ee-RPDu7Lm1TnpUx4ZGuqttBwjET2Y7L7JRpWGvuPPf-HimC3nxs2B81iO7hE9ktfO-Fg0mSyx26HV5TskEp_Zf2F5_OkE781GUO8Y=@protonmail.ch>
 <26687.12149.851300.842290@hornik.net>
Message-ID: <1260672468.9250991.1749041198154.JavaMail.zimbra@thuenen.de>

As a user I would prefer:

A (classed) error if I ask for something impossible.

A (classed) warning if 'include.only' is handled as 'include' (because I might rely on the .only part for some reason and have forgotten that I have already attached the namespace).


----- Urspr?ngliche Mail -----
> Von: "Kurt Hornik" <Kurt.Hornik at wu.ac.at>
> An: "Laurent Gatto" <lgatto at protonmail.ch>
> CC: "Kurt Hornik" <Kurt.Hornik at wu.ac.at>, "Trevor Davis" <trevor.l.davis at gmail.com>, r-devel at r-project.org, "roland
> fuss" <roland.fuss at thuenen.de>
> Gesendet: Dienstag, 3. Juni 2025 19:23:01
> Betreff: Re: [Rd] FR: improve "use" function

>>>>>> Laurent Gatto writes:
> 
> Thanks.
> 
> In general, I guess we all agree that if 'include.only' or 'exclude' ask
> for something (currently) impossible then a suitably classed condition
> object should be thrown.  Could be both a warning or an error ...
> 
> And perhaps we should take 'include.only' as 'include', i.e., be fine
> when we give 'include.only' as a subset of what is already included.
> 
> Personally, I am not a big fan of suggesting to use detach() in the
> condition message.
> 
> Best
> -k
> 
>> On Tuesday, May 27th, 2025 at 9:13 AM, Kurt Hornik <Kurt.Hornik at wu.ac.at> wrote:
>>> > > > > > Trevor Davis writes:
>>> 
>>> 
>>> Thanks.
>>> 
>>> This is really about what
>>> 
>>> library("foo", include.only = "fun2")
>>> 
>>> should do if package 'foo' was already attached and the include.only
>>> contradicts a previous specification.
>>> 
>>> In principle, one could look into allowing the underlying
>>> attachNamespace() to add more exports into the package environment (the
>>> 'only' in 'include.only' might suggest differently, but we would have to
>>> live with that). However, using detach/attach is not the right way of
>>> doing this, as it possibly modifies the search path and may trigger
>>> hooks that should not be triggered. Doing it right would probably need
>>> an .Internal and hence be a lot of work ...
>>> 
>>> What definitely needs attention is the fact that currently the above is
>>> silently ignored. So at least for now we should teach attachNamespace()
>>> to throw a suitably classed error if called with include.only that
>>> contradicts a previous specification.
>>> 
>>> Contributions welcome :-)
> 
>> Some work has been done on that front during last week's r-dev-day
>> with Ella Kaye and Philippe Grosjean [1]. After some more thinking, I
>> think we haven't been stringent enough, and would suggest that the
>> user should be alerted as soon as what they want to attach doesn't
>> match exactly what is already on the search path. Something along the
>> lines of (the warning/message can of course be amended).
> 
>> These two situations are OK, given that exactly the same set is asked
>> for repeated, either with a limited set of functions:
> 
>>> library("Matrix", include.only = "isDiagonal")
>>> library("Matrix", include.only = "isDiagonal") ## ok
> 
>> or, in a new session, with the whole package:
> 
>>> library("Matrix", include.only = "isDiagonal")
>>> library("Matrix", include.only = "isDiagonal") ## ok
> 
>> Below, (again, in a new session) the user could be mislead that either
>> only qr would be attached (and isDiagonal not anymore), or all
>> Matrix's exported symbols:
> 
>>> library("Matrix", include.only = "isDiagonal")
>>> library("Matrix", include.only = "qr") ## warn
>> Warning message:
>> In library("Matrix", include.only = "qr") :
>>   The package 'Matrix' is already loaded with a different set of functions. Please
>>   detach() it first.
>>> library("Matrix") ## warn
>> Warning message:
>> In library("Matrix") :
>>   The package 'Matrix' is already loaded with a different set of functions. Please
>>   detach() it first.
> 
>> In the following cases, a subset is asked after all symbols are
>> attached, which also triggers a warning/message:
> 
>>> library("Matrix")
>>> library("Matrix", exclude = "isDiagonal") ## warn
>> Warning message:
>> In library("Matrix", exclude = "isDiagonal") :
>>   The package 'Matrix' is already loaded with a different set of functions. Please
>>   detach() it first.
>>> library("Matrix", include.only = "isDiagonal") ## warn
>> Warning message:
>> In library("Matrix", include.only = "isDiagonal") :
>>   The package 'Matrix' is already loaded with a different set of functions. Please
>>   detach() it first.
> 
>> If this is a good way forward, I would be happy to carry on that work.
> 
>> Laurent
> 
> 
> > [1] https://github.com/r-devel/r-dev-day/issues/48

-- 
Th?nen-Institut f?r Agrarklimaschutz/
Th?nen Institute of Climate-Smart Agriculture

Bundesallee 65
D-38116 Braunschweig, Germany

Tel./Webex: +49 531 25701967

Email: roland.fuss at thuenen.de

Arbeitsgruppe "Emissionsberichterstattung"/
Working group "Emission Inventories"
Email: emissionsinventare at thuenen.de

Das Johann Heinrich von Th?nen-Institut, 
Bundesforschungsinstitut f?r L?ndliche R?ume, 
Wald und Fischerei ? kurz: Th?nen-Institut ? 
besteht aus 15 Fachinstituten, die ?ber 
sozio?konomische, ?kologische und technologische 
Kompetenz verf?gen. Das Th?nen-Institut betreibt 
Forschung und Politikberatung mit Bezug zu 
l?ndlichen R?umen, Landwirtschaft, Wald und Fischerei.

The Johann Heinrich von Th?nen Institute, 
Federal Research Institute for Rural Areas, 
Forestry and Fisheries ? Th?nen Institute 
in brief ? consists of 15 specialized 
institutes with socioeconomic, ecological 
and technological expertise. The Th?nen 
Institute conducts research and policy advice 
related to rural areas, agriculture, forests 
and fisheries.


From m|ch@e|ch|r|co4 @end|ng |rom gm@||@com  Fri Jun  6 20:59:08 2025
From: m|ch@e|ch|r|co4 @end|ng |rom gm@||@com (Michael Chirico)
Date: Fri, 6 Jun 2025 11:59:08 -0700
Subject: [Rd] Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
Message-ID: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>

There is a big difference in how to think of '...' for non-generic
functions like data.frame() vs. S3 generics.

In the former, it means "any number of inputs" [e.g. columns]; in the
latter, it means "any number of inputs [think c()], as well as any
arguments that might be interpreted by class implementations".

Understanding the difference for a given generic can require carefully
reading lots of documentation. print(<generic>), which is useful for
so many other contexts, can be a dead end.

One idea is to extend the print() method to suggest to the reader
which other arguments are available (among registered generics). Often
?<generic> will include the most common implementation, but not always
so.

For rbind (in a --vanilla session), we currently have one method,
rbind.data.frame, that offers three arguments not present in the
generic: make.row.names, stringsAsFactors, and factor.exclude. The
proposal would be to mention this in the print(rbind) output somehow,
e.g.

> print(rbind)
function (..., deparse.level = 1)
.Internal(rbind(deparse.level, ...))
<bytecode: 0x73d4fd824e20>
<environment: namespace:base>

+Other arguments implemented by methods
+  factor.exclude: rbind.data.frame
+  make.row.names: rbind.data.frame
+  stringsAsFactors: rbind.data.frame

I suggest grouping by argument, not generic, although something like
this could be OK too:

+Signatures of other methods
+  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
stringsAsFactors = FALSE,
+      factor.exclude = TRUE)

Where it gets more interesting is when there are many methods, e.g.
for as.data.frame (again, in a --vanilla session):

> print(as.data.frame)
function (x, row.names = NULL, optional = FALSE, ...)
{
    if (is.null(x))
        return(as.data.frame(list()))
    UseMethod("as.data.frame")
}
<bytecode: 0x73d4fc1e70d0>
<environment: namespace:base>

+Other arguments implemented by methods
+  base: as.data.frame.table
+  check.names: as.data.frame.list
+  col.names: as.data.frame.list
+  cut.names: as.data.frame.list
+  fix.empty.names: as.data.frame.list
+  make.names: as.data.frame.matrix, as.data.frame.model.matrix
+  new.names: as.data.frame.list
+  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
+    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
+    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
+    as.data.frame.numeric_version, as.data.frame.ordered,
+    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
+  responseName: as.data.frame.table
+  sep: as.data.frame.table
+  stringsAsFactors: as.data.frame.character, as.data.frame.list,
+    as.data.frame.matrix, as.data.frame.table

Or

+Signatures of other methods
+  as.data.frame.aovproj(x, ...)
+  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
+  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
+  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
+  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
+  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.data.frame(x, row.names = NULL, ...)
+  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
deparse1(substitute(x)))
+  as.data.frame.default(x, ...)
+  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
= deparse1(substitute(x)))
+  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
+  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
cut.names = FALSE,
+      col.names = names(x), fix.empty.names = TRUE, new.names =
!missing(col.names),
+      check.names = !optional, stringsAsFactors = FALSE)
+  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.logLik(x, ...)
+  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
make.names = TRUE,
+      ..., stringsAsFactors = FALSE)
+  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
make.names = TRUE,
+      ...)
+  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.numeric_version(x, row.names = NULL, optional =
FALSE, ..., nm = deparse1(substitute(x)))
+  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
= deparse1(substitute(x)))
+  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
nm = deparse1(substitute(x)))
+  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
+  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
deparse1(substitute(x)))
+  as.data.frame.table(x, row.names = NULL, ..., responseName =
"Freq", stringsAsFactors = TRUE,
+      sep = "", base = list(LETTERS))
+  as.data.frame.ts(x, ...)

Obviously that's a bit more cluttered, but as.data.frame() should be a
pretty unusual case. It also highlights better the differences in the
two approaches: the former economizes on space and focuses on what
sorts of arguments are available; the latter shows the defaults, does
not hide the arguments shared with the generic, and will always
produce as many lines as there are methods.

There are other edge cases to think through (multiple registrations,
interactions with S4, primitives, ...), but I want to first check with
the list if this looks workable & valuable enough to pursue.

Mike C

----

Code that helped with the above:

f = as.data.frame
# NB: methods() and getAnywhere() require {utils}
m = methods(f)
generic_args = names(formals(f))
f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
names(f_methods) = m
new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
with( # group by argument name
  data.frame(method = rep(names(new_args), lengths(new_args)), arg =
unlist(new_args), row.names=NULL),
  {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
": ", tbl))}
)
signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
collapse="\n"))
writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Mon Jun  9 00:57:13 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 8 Jun 2025 17:57:13 -0500
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
References: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
Message-ID: <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>

Hi Mike,

On Fri, Jun 6, 2025 at 1:59?PM Michael Chirico
<michaelchirico4 at gmail.com> wrote:
>
> There is a big difference in how to think of '...' for non-generic
> functions like data.frame() vs. S3 generics.
>
> In the former, it means "any number of inputs" [e.g. columns]; in the
> latter, it means "any number of inputs [think c()], as well as any
> arguments that might be interpreted by class implementations".
>
> Understanding the difference for a given generic can require carefully
> reading lots of documentation. print(<generic>), which is useful for
> so many other contexts, can be a dead end.
>
> One idea is to extend the print() method to suggest to the reader
> which other arguments are available (among registered generics). Often
> ?<generic> will include the most common implementation, but not always
> so.
>
> For rbind (in a --vanilla session), we currently have one method,
> rbind.data.frame, that offers three arguments not present in the
> generic: make.row.names, stringsAsFactors, and factor.exclude. The
> proposal would be to mention this in the print(rbind) output somehow,
> e.g.
>
> > print(rbind)
> function (..., deparse.level = 1)
> .Internal(rbind(deparse.level, ...))
> <bytecode: 0x73d4fd824e20>
> <environment: namespace:base>
>
> +Other arguments implemented by methods
> +  factor.exclude: rbind.data.frame
> +  make.row.names: rbind.data.frame
> +  stringsAsFactors: rbind.data.frame
>
> I suggest grouping by argument, not generic, although something like
> this could be OK too:
>
> +Signatures of other methods
> +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
> stringsAsFactors = FALSE,
> +      factor.exclude = TRUE)
>
> Where it gets more interesting is when there are many methods, e.g.
> for as.data.frame (again, in a --vanilla session):
>
> > print(as.data.frame)
> function (x, row.names = NULL, optional = FALSE, ...)
> {
>     if (is.null(x))
>         return(as.data.frame(list()))
>     UseMethod("as.data.frame")
> }
> <bytecode: 0x73d4fc1e70d0>
> <environment: namespace:base>
>
> +Other arguments implemented by methods
> +  base: as.data.frame.table
> +  check.names: as.data.frame.list
> +  col.names: as.data.frame.list
> +  cut.names: as.data.frame.list
> +  fix.empty.names: as.data.frame.list
> +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
> +  new.names: as.data.frame.list
> +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
> +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
> +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
> +    as.data.frame.numeric_version, as.data.frame.ordered,
> +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
> +  responseName: as.data.frame.table
> +  sep: as.data.frame.table
> +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
> +    as.data.frame.matrix, as.data.frame.table
>
> Or
>
> +Signatures of other methods
> +  as.data.frame.aovproj(x, ...)
> +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
> +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.data.frame(x, row.names = NULL, ...)
> +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
> deparse1(substitute(x)))
> +  as.data.frame.default(x, ...)
> +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
> = deparse1(substitute(x)))
> +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
> cut.names = FALSE,
> +      col.names = names(x), fix.empty.names = TRUE, new.names =
> !missing(col.names),
> +      check.names = !optional, stringsAsFactors = FALSE)
> +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.logLik(x, ...)
> +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
> make.names = TRUE,
> +      ..., stringsAsFactors = FALSE)
> +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
> make.names = TRUE,
> +      ...)
> +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.numeric_version(x, row.names = NULL, optional =
> FALSE, ..., nm = deparse1(substitute(x)))
> +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
> = deparse1(substitute(x)))
> +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
> deparse1(substitute(x)))
> +  as.data.frame.table(x, row.names = NULL, ..., responseName =
> "Freq", stringsAsFactors = TRUE,
> +      sep = "", base = list(LETTERS))
> +  as.data.frame.ts(x, ...)
>
> Obviously that's a bit more cluttered, but as.data.frame() should be a
> pretty unusual case. It also highlights better the differences in the
> two approaches: the former economizes on space and focuses on what
> sorts of arguments are available; the latter shows the defaults, does
> not hide the arguments shared with the generic, and will always
> produce as many lines as there are methods.
>
> There are other edge cases to think through (multiple registrations,
> interactions with S4, primitives, ...), but I want to first check with
> the list if this looks workable & valuable enough to pursue.
>
I like and appreciate the intent behind your suggestion, though I
don't like all the extra output from printing the generic. I want to
look at the function body when I print it. And as you show, it can
output a lot of information you're probably not interested in.

What about adding the number of methods to printed output for
generics, and a suggestion to use `methods(some_generic)` to get a
list of them? Then you can use help(some_method) or args(some_method)
to get more information about the specific method(s) you're interested
in.

Best,
Josh

> Mike C
>
> ----
>
> Code that helped with the above:
>
> f = as.data.frame
> # NB: methods() and getAnywhere() require {utils}
> m = methods(f)
> generic_args = names(formals(f))
> f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
> names(f_methods) = m
> new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
> with( # group by argument name
>   data.frame(method = rep(names(new_args), lengths(new_args)), arg =
> unlist(new_args), row.names=NULL),
>   {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
> ": ", tbl))}
> )
> signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
> collapse="\n"))
> writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From m|ch@e|ch|r|co4 @end|ng |rom gm@||@com  Mon Jun  9 07:59:39 2025
From: m|ch@e|ch|r|co4 @end|ng |rom gm@||@com (Michael Chirico)
Date: Sun, 8 Jun 2025 22:59:39 -0700
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>
References: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
 <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>
Message-ID: <CAPRVBcysU3cm4tAbySD4su8pxfTy1fLwGh==sY+c58=FoVBPJw@mail.gmail.com>

Thanks Josh,

With fresh eyes, it's definitely information overload for the
suggested output to take up more space than the function body itself.

I'm not sure your suggestion gets at the heart of the issue, though,
which is about steering the user with regards to interpreting '...'
they see in the printout.

Therefore I would suggest something like this as the economized
version of my original suggestion:

> print(rbind)
function (..., deparse.level = 1)
# ...
<environment: namespace:base>
+ 1 other method defines 3 other arguments. See methods(rbind).

> print(as.data.frame)
function (x, row.names = NULL, optional = FALSE, ...)
# ...
<environment: namespace:base>
+ 29 other methods define 11 other arguments. See methods(as.data.frame).

Mike C

On Sun, Jun 8, 2025 at 3:57?PM Joshua Ulrich <josh.m.ulrich at gmail.com> wrote:
>
> Hi Mike,
>
> On Fri, Jun 6, 2025 at 1:59?PM Michael Chirico
> <michaelchirico4 at gmail.com> wrote:
> >
> > There is a big difference in how to think of '...' for non-generic
> > functions like data.frame() vs. S3 generics.
> >
> > In the former, it means "any number of inputs" [e.g. columns]; in the
> > latter, it means "any number of inputs [think c()], as well as any
> > arguments that might be interpreted by class implementations".
> >
> > Understanding the difference for a given generic can require carefully
> > reading lots of documentation. print(<generic>), which is useful for
> > so many other contexts, can be a dead end.
> >
> > One idea is to extend the print() method to suggest to the reader
> > which other arguments are available (among registered generics). Often
> > ?<generic> will include the most common implementation, but not always
> > so.
> >
> > For rbind (in a --vanilla session), we currently have one method,
> > rbind.data.frame, that offers three arguments not present in the
> > generic: make.row.names, stringsAsFactors, and factor.exclude. The
> > proposal would be to mention this in the print(rbind) output somehow,
> > e.g.
> >
> > > print(rbind)
> > function (..., deparse.level = 1)
> > .Internal(rbind(deparse.level, ...))
> > <bytecode: 0x73d4fd824e20>
> > <environment: namespace:base>
> >
> > +Other arguments implemented by methods
> > +  factor.exclude: rbind.data.frame
> > +  make.row.names: rbind.data.frame
> > +  stringsAsFactors: rbind.data.frame
> >
> > I suggest grouping by argument, not generic, although something like
> > this could be OK too:
> >
> > +Signatures of other methods
> > +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
> > stringsAsFactors = FALSE,
> > +      factor.exclude = TRUE)
> >
> > Where it gets more interesting is when there are many methods, e.g.
> > for as.data.frame (again, in a --vanilla session):
> >
> > > print(as.data.frame)
> > function (x, row.names = NULL, optional = FALSE, ...)
> > {
> >     if (is.null(x))
> >         return(as.data.frame(list()))
> >     UseMethod("as.data.frame")
> > }
> > <bytecode: 0x73d4fc1e70d0>
> > <environment: namespace:base>
> >
> > +Other arguments implemented by methods
> > +  base: as.data.frame.table
> > +  check.names: as.data.frame.list
> > +  col.names: as.data.frame.list
> > +  cut.names: as.data.frame.list
> > +  fix.empty.names: as.data.frame.list
> > +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
> > +  new.names: as.data.frame.list
> > +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
> > +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
> > +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
> > +    as.data.frame.numeric_version, as.data.frame.ordered,
> > +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
> > +  responseName: as.data.frame.table
> > +  sep: as.data.frame.table
> > +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
> > +    as.data.frame.matrix, as.data.frame.table
> >
> > Or
> >
> > +Signatures of other methods
> > +  as.data.frame.aovproj(x, ...)
> > +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
> > +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.data.frame(x, row.names = NULL, ...)
> > +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
> > deparse1(substitute(x)))
> > +  as.data.frame.default(x, ...)
> > +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
> > = deparse1(substitute(x)))
> > +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
> > cut.names = FALSE,
> > +      col.names = names(x), fix.empty.names = TRUE, new.names =
> > !missing(col.names),
> > +      check.names = !optional, stringsAsFactors = FALSE)
> > +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.logLik(x, ...)
> > +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
> > make.names = TRUE,
> > +      ..., stringsAsFactors = FALSE)
> > +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
> > make.names = TRUE,
> > +      ...)
> > +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.numeric_version(x, row.names = NULL, optional =
> > FALSE, ..., nm = deparse1(substitute(x)))
> > +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
> > = deparse1(substitute(x)))
> > +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
> > deparse1(substitute(x)))
> > +  as.data.frame.table(x, row.names = NULL, ..., responseName =
> > "Freq", stringsAsFactors = TRUE,
> > +      sep = "", base = list(LETTERS))
> > +  as.data.frame.ts(x, ...)
> >
> > Obviously that's a bit more cluttered, but as.data.frame() should be a
> > pretty unusual case. It also highlights better the differences in the
> > two approaches: the former economizes on space and focuses on what
> > sorts of arguments are available; the latter shows the defaults, does
> > not hide the arguments shared with the generic, and will always
> > produce as many lines as there are methods.
> >
> > There are other edge cases to think through (multiple registrations,
> > interactions with S4, primitives, ...), but I want to first check with
> > the list if this looks workable & valuable enough to pursue.
> >
> I like and appreciate the intent behind your suggestion, though I
> don't like all the extra output from printing the generic. I want to
> look at the function body when I print it. And as you show, it can
> output a lot of information you're probably not interested in.
>
> What about adding the number of methods to printed output for
> generics, and a suggestion to use `methods(some_generic)` to get a
> list of them? Then you can use help(some_method) or args(some_method)
> to get more information about the specific method(s) you're interested
> in.
>
> Best,
> Josh
>
> > Mike C
> >
> > ----
> >
> > Code that helped with the above:
> >
> > f = as.data.frame
> > # NB: methods() and getAnywhere() require {utils}
> > m = methods(f)
> > generic_args = names(formals(f))
> > f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
> > names(f_methods) = m
> > new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
> > with( # group by argument name
> >   data.frame(method = rep(names(new_args), lengths(new_args)), arg =
> > unlist(new_args), row.names=NULL),
> >   {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
> > ": ", tbl))}
> > )
> > signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
> > collapse="\n"))
> > writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Joshua Ulrich  |  about.me/joshuaulrich
> FOSS Trading  |  www.fosstrading.com


From ||u|@@rev|||@ @end|ng |rom gm@||@com  Mon Jun  9 23:25:31 2025
From: ||u|@@rev|||@ @end|ng |rom gm@||@com (=?UTF-8?Q?Llu=C3=ADs_Revilla?=)
Date: Mon, 9 Jun 2025 23:25:31 +0200
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <CAPRVBcysU3cm4tAbySD4su8pxfTy1fLwGh==sY+c58=FoVBPJw@mail.gmail.com>
References: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
 <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>
 <CAPRVBcysU3cm4tAbySD4su8pxfTy1fLwGh==sY+c58=FoVBPJw@mail.gmail.com>
Message-ID: <CAN+W6_t7SK66xJUHzFyitwN4EgaX_cqSq+X+0_Ca=j1VdBNKtw@mail.gmail.com>

Hi,

I agree that showing that there are other methods might help.
The print.function method could be modified to add this in addition to
print.default output.

But I guess (new) users would check the help page with ?as.data.frame and
not print the method or use args() (if they don't check with their prefered
LLM/agent).
Would it be helpful to also report these numbers on the documentation page
of the generic too?

Best,

Llu?s


PS: Trying to see what happens with ? and looking for a specific method I
found that on my computer with R-devel (2025-06-08 r88288), the expressions
below the "Not run:" on ? examples raise errors.


On Mon, 9 Jun 2025 at 08:07, Michael Chirico <michaelchirico4 at gmail.com>
wrote:

> Thanks Josh,
>
> With fresh eyes, it's definitely information overload for the
> suggested output to take up more space than the function body itself.
>
> I'm not sure your suggestion gets at the heart of the issue, though,
> which is about steering the user with regards to interpreting '...'
> they see in the printout.
>
> Therefore I would suggest something like this as the economized
> version of my original suggestion:
>
> > print(rbind)
> function (..., deparse.level = 1)
> # ...
> <environment: namespace:base>
> + 1 other method defines 3 other arguments. See methods(rbind).
>
> > print(as.data.frame)
> function (x, row.names = NULL, optional = FALSE, ...)
> # ...
> <environment: namespace:base>
> + 29 other methods define 11 other arguments. See methods(as.data.frame).
>
> Mike C
>
> On Sun, Jun 8, 2025 at 3:57?PM Joshua Ulrich <josh.m.ulrich at gmail.com>
> wrote:
> >
> > Hi Mike,
> >
> > On Fri, Jun 6, 2025 at 1:59?PM Michael Chirico
> > <michaelchirico4 at gmail.com> wrote:
> > >
> > > There is a big difference in how to think of '...' for non-generic
> > > functions like data.frame() vs. S3 generics.
> > >
> > > In the former, it means "any number of inputs" [e.g. columns]; in the
> > > latter, it means "any number of inputs [think c()], as well as any
> > > arguments that might be interpreted by class implementations".
> > >
> > > Understanding the difference for a given generic can require carefully
> > > reading lots of documentation. print(<generic>), which is useful for
> > > so many other contexts, can be a dead end.
> > >
> > > One idea is to extend the print() method to suggest to the reader
> > > which other arguments are available (among registered generics). Often
> > > ?<generic> will include the most common implementation, but not always
> > > so.
> > >
> > > For rbind (in a --vanilla session), we currently have one method,
> > > rbind.data.frame, that offers three arguments not present in the
> > > generic: make.row.names, stringsAsFactors, and factor.exclude. The
> > > proposal would be to mention this in the print(rbind) output somehow,
> > > e.g.
> > >
> > > > print(rbind)
> > > function (..., deparse.level = 1)
> > > .Internal(rbind(deparse.level, ...))
> > > <bytecode: 0x73d4fd824e20>
> > > <environment: namespace:base>
> > >
> > > +Other arguments implemented by methods
> > > +  factor.exclude: rbind.data.frame
> > > +  make.row.names: rbind.data.frame
> > > +  stringsAsFactors: rbind.data.frame
> > >
> > > I suggest grouping by argument, not generic, although something like
> > > this could be OK too:
> > >
> > > +Signatures of other methods
> > > +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
> > > stringsAsFactors = FALSE,
> > > +      factor.exclude = TRUE)
> > >
> > > Where it gets more interesting is when there are many methods, e.g.
> > > for as.data.frame (again, in a --vanilla session):
> > >
> > > > print(as.data.frame)
> > > function (x, row.names = NULL, optional = FALSE, ...)
> > > {
> > >     if (is.null(x))
> > >         return(as.data.frame(list()))
> > >     UseMethod("as.data.frame")
> > > }
> > > <bytecode: 0x73d4fc1e70d0>
> > > <environment: namespace:base>
> > >
> > > +Other arguments implemented by methods
> > > +  base: as.data.frame.table
> > > +  check.names: as.data.frame.list
> > > +  col.names: as.data.frame.list
> > > +  cut.names: as.data.frame.list
> > > +  fix.empty.names: as.data.frame.list
> > > +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
> > > +  new.names: as.data.frame.list
> > > +  nm: as.data.frame.bibentry, as.data.frame.complex,
> as.data.frame.Date,
> > > +    as.data.frame.difftime, as.data.frame.factor,
> as.data.frame.integer,
> > > +    as.data.frame.logical, as.data.frame.noquote,
> as.data.frame.numeric,
> > > +    as.data.frame.numeric_version, as.data.frame.ordered,
> > > +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
> > > +  responseName: as.data.frame.table
> > > +  sep: as.data.frame.table
> > > +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
> > > +    as.data.frame.matrix, as.data.frame.table
> > >
> > > Or
> > >
> > > +Signatures of other methods
> > > +  as.data.frame.aovproj(x, ...)
> > > +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
> > > +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
> > > +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
> > > +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
> > > +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.data.frame(x, row.names = NULL, ...)
> > > +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
> > > deparse1(substitute(x)))
> > > +  as.data.frame.default(x, ...)
> > > +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
> > > = deparse1(substitute(x)))
> > > +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
> > > +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
> > > cut.names = FALSE,
> > > +      col.names = names(x), fix.empty.names = TRUE, new.names =
> > > !missing(col.names),
> > > +      check.names = !optional, stringsAsFactors = FALSE)
> > > +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.logLik(x, ...)
> > > +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
> > > make.names = TRUE,
> > > +      ..., stringsAsFactors = FALSE)
> > > +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
> > > make.names = TRUE,
> > > +      ...)
> > > +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.numeric_version(x, row.names = NULL, optional =
> > > FALSE, ..., nm = deparse1(substitute(x)))
> > > +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
> > > = deparse1(substitute(x)))
> > > +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
> > > nm = deparse1(substitute(x)))
> > > +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
> > > +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
> > > deparse1(substitute(x)))
> > > +  as.data.frame.table(x, row.names = NULL, ..., responseName =
> > > "Freq", stringsAsFactors = TRUE,
> > > +      sep = "", base = list(LETTERS))
> > > +  as.data.frame.ts(x, ...)
> > >
> > > Obviously that's a bit more cluttered, but as.data.frame() should be a
> > > pretty unusual case. It also highlights better the differences in the
> > > two approaches: the former economizes on space and focuses on what
> > > sorts of arguments are available; the latter shows the defaults, does
> > > not hide the arguments shared with the generic, and will always
> > > produce as many lines as there are methods.
> > >
> > > There are other edge cases to think through (multiple registrations,
> > > interactions with S4, primitives, ...), but I want to first check with
> > > the list if this looks workable & valuable enough to pursue.
> > >
> > I like and appreciate the intent behind your suggestion, though I
> > don't like all the extra output from printing the generic. I want to
> > look at the function body when I print it. And as you show, it can
> > output a lot of information you're probably not interested in.
> >
> > What about adding the number of methods to printed output for
> > generics, and a suggestion to use `methods(some_generic)` to get a
> > list of them? Then you can use help(some_method) or args(some_method)
> > to get more information about the specific method(s) you're interested
> > in.
> >
> > Best,
> > Josh
> >
> > > Mike C
> > >
> > > ----
> > >
> > > Code that helped with the above:
> > >
> > > f = as.data.frame
> > > # NB: methods() and getAnywhere() require {utils}
> > > m = methods(f)
> > > generic_args = names(formals(f))
> > > f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
> > > names(f_methods) = m
> > > new_args = sapply(f_methods, \(g) setdiff(names(formals(g)),
> generic_args))
> > > with( # group by argument name
> > >   data.frame(method = rep(names(new_args), lengths(new_args)), arg =
> > > unlist(new_args), row.names=NULL),
> > >   {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
> > > ": ", tbl))}
> > > )
> > > signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
> > > collapse="\n"))
> > > writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "",
> signatures)))
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> >
> > --
> > Joshua Ulrich  |  about.me/joshuaulrich
> > FOSS Trading  |  www.fosstrading.com
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From j@g@nmn2 @end|ng |rom gm@||@com  Tue Jun 10 05:44:07 2025
From: j@g@nmn2 @end|ng |rom gm@||@com (Mikael Jagan)
Date: Mon, 9 Jun 2025 23:44:07 -0400
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <mailman.54933.3.1749290401.32909.r-devel@r-project.org>
References: <mailman.54933.3.1749290401.32909.r-devel@r-project.org>
Message-ID: <50f36c21-0503-4166-9c9e-1017f468dc1a@gmail.com>

I don't really understand the premise.  Any function F with '...' as a formal
argument can pass '...' to another function G.  The actual arguments matching
'...' in the call to F will be matched to the formal arguments of G.  So the
the maintainer of F may want to alert the user of F to the existence of G and
the user of F may want to consult the documentation of G.

Whether F is S3 generic and G is registered as a method for F seems irrelevant.

That is a conceptual issue.  There are practical issues, too:

     * print.default is used "everywhere".  Backwards incompatible changes to
       default behaviour have the potential to break a lot of code out there.

     * Testing that a function F is S3 generic seems nontrivial.  You have to
       deal with internally generic functions and for closures recurse through
       body(F) looking for a call to UseMethod.

     * I would not want the output of print(F) to depend on details external to
       F or the method call, such as the state of the table of registered S3
       methods which changes as packages are loaded.  AFAIK, it is intended that
       options() is the only exception to the rule.

     * More harmonious would be to implement the feature ("give me more
       information about S3 methods") as an option (disabled by default) of
       utils::.S3methods if not as a new function altogether.

Mikael

> Date: Fri, 6 Jun 2025 11:59:08 -0700
> From: Michael Chirico<michaelchirico4 at gmail.com>
> 
> There is a big difference in how to think of '...' for non-generic
> functions like data.frame() vs. S3 generics.
> 
> In the former, it means "any number of inputs" [e.g. columns]; in the
> latter, it means "any number of inputs [think c()], as well as any
> arguments that might be interpreted by class implementations".
> 
> Understanding the difference for a given generic can require carefully
> reading lots of documentation. print(<generic>), which is useful for
> so many other contexts, can be a dead end.
> 
> One idea is to extend the print() method to suggest to the reader
> which other arguments are available (among registered generics). Often
> ?<generic> will include the most common implementation, but not always
> so.
> 
> For rbind (in a --vanilla session), we currently have one method,
> rbind.data.frame, that offers three arguments not present in the
> generic: make.row.names, stringsAsFactors, and factor.exclude. The
> proposal would be to mention this in the print(rbind) output somehow,
> e.g.
> 
>> print(rbind)
> function (..., deparse.level = 1)
> .Internal(rbind(deparse.level, ...))
> <bytecode: 0x73d4fd824e20>
> <environment: namespace:base>
> 
> +Other arguments implemented by methods
> +  factor.exclude: rbind.data.frame
> +  make.row.names: rbind.data.frame
> +  stringsAsFactors: rbind.data.frame
> 
> I suggest grouping by argument, not generic, although something like
> this could be OK too:
> 
> +Signatures of other methods
> +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
> stringsAsFactors = FALSE,
> +      factor.exclude = TRUE)
> 
> Where it gets more interesting is when there are many methods, e.g.
> for as.data.frame (again, in a --vanilla session):
> 
>> print(as.data.frame)
> function (x, row.names = NULL, optional = FALSE, ...)
> {
>      if (is.null(x))
>          return(as.data.frame(list()))
>      UseMethod("as.data.frame")
> }
> <bytecode: 0x73d4fc1e70d0>
> <environment: namespace:base>
> 
> +Other arguments implemented by methods
> +  base: as.data.frame.table
> +  check.names: as.data.frame.list
> +  col.names: as.data.frame.list
> +  cut.names: as.data.frame.list
> +  fix.empty.names: as.data.frame.list
> +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
> +  new.names: as.data.frame.list
> +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
> +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
> +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
> +    as.data.frame.numeric_version, as.data.frame.ordered,
> +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
> +  responseName: as.data.frame.table
> +  sep: as.data.frame.table
> +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
> +    as.data.frame.matrix, as.data.frame.table
> 
> Or
> 
> +Signatures of other methods
> +  as.data.frame.aovproj(x, ...)
> +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
> +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.data.frame(x, row.names = NULL, ...)
> +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
> deparse1(substitute(x)))
> +  as.data.frame.default(x, ...)
> +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
> = deparse1(substitute(x)))
> +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
> cut.names = FALSE,
> +      col.names = names(x), fix.empty.names = TRUE, new.names =
> !missing(col.names),
> +      check.names = !optional, stringsAsFactors = FALSE)
> +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.logLik(x, ...)
> +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
> make.names = TRUE,
> +      ..., stringsAsFactors = FALSE)
> +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
> make.names = TRUE,
> +      ...)
> +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.numeric_version(x, row.names = NULL, optional =
> FALSE, ..., nm = deparse1(substitute(x)))
> +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
> = deparse1(substitute(x)))
> +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
> nm = deparse1(substitute(x)))
> +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
> +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
> deparse1(substitute(x)))
> +  as.data.frame.table(x, row.names = NULL, ..., responseName =
> "Freq", stringsAsFactors = TRUE,
> +      sep = "", base = list(LETTERS))
> +  as.data.frame.ts(x, ...)
> 
> Obviously that's a bit more cluttered, but as.data.frame() should be a
> pretty unusual case. It also highlights better the differences in the
> two approaches: the former economizes on space and focuses on what
> sorts of arguments are available; the latter shows the defaults, does
> not hide the arguments shared with the generic, and will always
> produce as many lines as there are methods.
> 
> There are other edge cases to think through (multiple registrations,
> interactions with S4, primitives, ...), but I want to first check with
> the list if this looks workable & valuable enough to pursue.
> 
> Mike C
> 
> ----
> 
> Code that helped with the above:
> 
> f = as.data.frame
> # NB: methods() and getAnywhere() require {utils}
> m = methods(f)
> generic_args = names(formals(f))
> f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
> names(f_methods) = m
> new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
> with( # group by argument name
>    data.frame(method = rep(names(new_args), lengths(new_args)), arg =
> unlist(new_args), row.names=NULL),
>    {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
> ": ", tbl))}
> )
> signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
> collapse="\n"))
> writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))


From g@u@@e||m|ner|ng @end|ng |rom gm@||@com  Tue Jun 10 08:46:13 2025
From: g@u@@e||m|ner|ng @end|ng |rom gm@||@com (=?UTF-8?B?TcOlbnMgVGh1bGlu?=)
Date: Tue, 10 Jun 2025 08:46:13 +0200
Subject: [Rd] Suggestion: Modify common hypothesis tests and models to work
 better with pipes
Message-ID: <CAMdJUypT0-eGfgC-cfTKTkLEdCYncmi=vFqss7FVMyDyxe-ZAg@mail.gmail.com>

To use functions for common statistical tests/models, like t.test,
wilcox.test, lm, glm, and aov, we must currently use the pipe placeholder _
when using pipes:

penguins |>
    subset(species != "Gentoo") |>
    t.test(bill_len ~ species, data = _)

The syntax would be cleaner and perhaps more intuitive if we didn't have to
add the `data = _` bit:

penguins |>
    subset(species != "Gentoo") |>
    t.test(bill_len ~ species)

I believe that this is how t.test and the other functions I mentioned would
have worked if they'd been written after the base pipe was introduced.

Currently, t.test and friends only accept a vector and/or a formula as
their first argument. Since there already is a formula method for these
functions, a simple way to make the second example above work would be to
define a data.frame method like so:

t.test.data.frame <- function(x, formula, ...)
{
    t.test.formula(formula, x, ...)
}

...perhaps with a check to make sure that the formula argument actually is
a formula.

Now, this seems like an easy thing to fix, and it doesn't break any
existing functionality of these functions. Since the base pipe was
introduced four years ago, I suspect that there might be some reason why
this hasn't been implemented already, and I'm curious to find out what that
is. Or, if there is support for the idea above, I'd be happy to submit a
feature request in Bugzilla and provide code for implementing this.

Best regards,
M?ns

	[[alternative HTML version deleted]]


From ggrothend|eck @end|ng |rom gm@||@com  Tue Jun 10 15:32:10 2025
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 10 Jun 2025 09:32:10 -0400
Subject: [Rd] 
 Suggestion: Modify common hypothesis tests and models to work
 better with pipes
In-Reply-To: <CAMdJUypT0-eGfgC-cfTKTkLEdCYncmi=vFqss7FVMyDyxe-ZAg@mail.gmail.com>
References: <CAMdJUypT0-eGfgC-cfTKTkLEdCYncmi=vFqss7FVMyDyxe-ZAg@mail.gmail.com>
Message-ID: <CAP01uRnbEikmwRSYuV=y7eMh4x4UY_1Zwa6bkR--LMf10p_WxQ@mail.gmail.com>

I am not saying this is wonderful but this does work:

  penguins |>
      subset(species != "Gentoo") |>
      stats:::t.test.formula(formula = bill_len ~ species)

Also there is a problem with t.test in that methods are not supposed
to have conflicting
signatures but

  > args(t.test)
  function (x, ...)
  NULL

  > args(stats:::t.test.formula)
  function (formula, data, subset, na.action = na.pass, ...)
  NULL

On Tue, Jun 10, 2025 at 6:39?AM M?ns Thulin <gausseliminering at gmail.com> wrote:
>
> To use functions for common statistical tests/models, like t.test,
> wilcox.test, lm, glm, and aov, we must currently use the pipe placeholder _
> when using pipes:
>
> penguins |>
>     subset(species != "Gentoo") |>
>     t.test(bill_len ~ species, data = _)
>
> The syntax would be cleaner and perhaps more intuitive if we didn't have to
> add the `data = _` bit:
>
> penguins |>
>     subset(species != "Gentoo") |>
>     t.test(bill_len ~ species)
>
> I believe that this is how t.test and the other functions I mentioned would
> have worked if they'd been written after the base pipe was introduced.
>
> Currently, t.test and friends only accept a vector and/or a formula as
> their first argument. Since there already is a formula method for these
> functions, a simple way to make the second example above work would be to
> define a data.frame method like so:
>
> t.test.data.frame <- function(x, formula, ...)
> {
>     t.test.formula(formula, x, ...)
> }
>
> ...perhaps with a check to make sure that the formula argument actually is
> a formula.
>
> Now, this seems like an easy thing to fix, and it doesn't break any
> existing functionality of these functions. Since the base pipe was
> introduced four years ago, I suspect that there might be some reason why
> this hasn't been implemented already, and I'm curious to find out what that
> is. Or, if there is support for the idea above, I'd be happy to submit a
> feature request in Bugzilla and provide code for implementing this.
>
> Best regards,
> M?ns
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From m|ch@e|ch|r|co4 @end|ng |rom gm@||@com  Tue Jun 10 18:15:02 2025
From: m|ch@e|ch|r|co4 @end|ng |rom gm@||@com (Michael Chirico)
Date: Tue, 10 Jun 2025 09:15:02 -0700
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <50f36c21-0503-4166-9c9e-1017f468dc1a@gmail.com>
References: <mailman.54933.3.1749290401.32909.r-devel@r-project.org>
 <50f36c21-0503-4166-9c9e-1017f468dc1a@gmail.com>
Message-ID: <CAPRVBcwJHvDkOPDbbKX=b3EjLFWy7yGgCMvRiw-piyR6+R4ZQQ@mail.gmail.com>

Thanks for the thoughtful reply Mikael.

> Any function F with '...' as a formal argument can pass '...' to another function G.

Yes, that's true. The difference is that in print(F) we can _usually_
pick out at a glance how '...' is being used -- we can see which 'G'
is getting '...'.

For S3 generics, we quickly reach the dead end of 'UseMethod' -- F
being S3 generic is in fact _highly_ relevant.

Yes, the practical issues you raise are interesting & knotty (I
especially have in mind [1] and [2]), but ultimately I think we could
come up with something useful. Whether that becomes a default can
depend on how useful it winds up being, and the empirical risk of
back-incompatibility (which I suspect is low).

Mike C

[1] utils::isS3stdGeneric
https://stat.ethz.ch/R-manual/R-devel/library/utils/html/isS3stdGen.html,
which has a large # of false negatives
[2] utils::nonS3methods
https://stat.ethz.ch/R-manual/R-devel/library/tools/html/QC.html,
which maintains an onerous list of S3 method lookalikes

On Mon, Jun 9, 2025 at 8:44?PM Mikael Jagan <jaganmn2 at gmail.com> wrote:
>
> I don't really understand the premise.  Any function F with '...' as a formal
> argument can pass '...' to another function G.  The actual arguments matching
> '...' in the call to F will be matched to the formal arguments of G.  So the
> the maintainer of F may want to alert the user of F to the existence of G and
> the user of F may want to consult the documentation of G.
>
> Whether F is S3 generic and G is registered as a method for F seems irrelevant.
>
> That is a conceptual issue.  There are practical issues, too:
>
>      * print.default is used "everywhere".  Backwards incompatible changes to
>        default behaviour have the potential to break a lot of code out there.
>
>      * Testing that a function F is S3 generic seems nontrivial.  You have to
>        deal with internally generic functions and for closures recurse through
>        body(F) looking for a call to UseMethod.
>
>      * I would not want the output of print(F) to depend on details external to
>        F or the method call, such as the state of the table of registered S3
>        methods which changes as packages are loaded.  AFAIK, it is intended that
>        options() is the only exception to the rule.
>
>      * More harmonious would be to implement the feature ("give me more
>        information about S3 methods") as an option (disabled by default) of
>        utils::.S3methods if not as a new function altogether.
>
> Mikael
>
> > Date: Fri, 6 Jun 2025 11:59:08 -0700
> > From: Michael Chirico<michaelchirico4 at gmail.com>
> >
> > There is a big difference in how to think of '...' for non-generic
> > functions like data.frame() vs. S3 generics.
> >
> > In the former, it means "any number of inputs" [e.g. columns]; in the
> > latter, it means "any number of inputs [think c()], as well as any
> > arguments that might be interpreted by class implementations".
> >
> > Understanding the difference for a given generic can require carefully
> > reading lots of documentation. print(<generic>), which is useful for
> > so many other contexts, can be a dead end.
> >
> > One idea is to extend the print() method to suggest to the reader
> > which other arguments are available (among registered generics). Often
> > ?<generic> will include the most common implementation, but not always
> > so.
> >
> > For rbind (in a --vanilla session), we currently have one method,
> > rbind.data.frame, that offers three arguments not present in the
> > generic: make.row.names, stringsAsFactors, and factor.exclude. The
> > proposal would be to mention this in the print(rbind) output somehow,
> > e.g.
> >
> >> print(rbind)
> > function (..., deparse.level = 1)
> > .Internal(rbind(deparse.level, ...))
> > <bytecode: 0x73d4fd824e20>
> > <environment: namespace:base>
> >
> > +Other arguments implemented by methods
> > +  factor.exclude: rbind.data.frame
> > +  make.row.names: rbind.data.frame
> > +  stringsAsFactors: rbind.data.frame
> >
> > I suggest grouping by argument, not generic, although something like
> > this could be OK too:
> >
> > +Signatures of other methods
> > +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
> > stringsAsFactors = FALSE,
> > +      factor.exclude = TRUE)
> >
> > Where it gets more interesting is when there are many methods, e.g.
> > for as.data.frame (again, in a --vanilla session):
> >
> >> print(as.data.frame)
> > function (x, row.names = NULL, optional = FALSE, ...)
> > {
> >      if (is.null(x))
> >          return(as.data.frame(list()))
> >      UseMethod("as.data.frame")
> > }
> > <bytecode: 0x73d4fc1e70d0>
> > <environment: namespace:base>
> >
> > +Other arguments implemented by methods
> > +  base: as.data.frame.table
> > +  check.names: as.data.frame.list
> > +  col.names: as.data.frame.list
> > +  cut.names: as.data.frame.list
> > +  fix.empty.names: as.data.frame.list
> > +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
> > +  new.names: as.data.frame.list
> > +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
> > +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
> > +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
> > +    as.data.frame.numeric_version, as.data.frame.ordered,
> > +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
> > +  responseName: as.data.frame.table
> > +  sep: as.data.frame.table
> > +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
> > +    as.data.frame.matrix, as.data.frame.table
> >
> > Or
> >
> > +Signatures of other methods
> > +  as.data.frame.aovproj(x, ...)
> > +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
> > +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.data.frame(x, row.names = NULL, ...)
> > +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
> > deparse1(substitute(x)))
> > +  as.data.frame.default(x, ...)
> > +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
> > = deparse1(substitute(x)))
> > +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
> > cut.names = FALSE,
> > +      col.names = names(x), fix.empty.names = TRUE, new.names =
> > !missing(col.names),
> > +      check.names = !optional, stringsAsFactors = FALSE)
> > +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.logLik(x, ...)
> > +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
> > make.names = TRUE,
> > +      ..., stringsAsFactors = FALSE)
> > +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
> > make.names = TRUE,
> > +      ...)
> > +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.numeric_version(x, row.names = NULL, optional =
> > FALSE, ..., nm = deparse1(substitute(x)))
> > +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
> > = deparse1(substitute(x)))
> > +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
> > nm = deparse1(substitute(x)))
> > +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
> > +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
> > deparse1(substitute(x)))
> > +  as.data.frame.table(x, row.names = NULL, ..., responseName =
> > "Freq", stringsAsFactors = TRUE,
> > +      sep = "", base = list(LETTERS))
> > +  as.data.frame.ts(x, ...)
> >
> > Obviously that's a bit more cluttered, but as.data.frame() should be a
> > pretty unusual case. It also highlights better the differences in the
> > two approaches: the former economizes on space and focuses on what
> > sorts of arguments are available; the latter shows the defaults, does
> > not hide the arguments shared with the generic, and will always
> > produce as many lines as there are methods.
> >
> > There are other edge cases to think through (multiple registrations,
> > interactions with S4, primitives, ...), but I want to first check with
> > the list if this looks workable & valuable enough to pursue.
> >
> > Mike C
> >
> > ----
> >
> > Code that helped with the above:
> >
> > f = as.data.frame
> > # NB: methods() and getAnywhere() require {utils}
> > m = methods(f)
> > generic_args = names(formals(f))
> > f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
> > names(f_methods) = m
> > new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
> > with( # group by argument name
> >    data.frame(method = rep(names(new_args), lengths(new_args)), arg =
> > unlist(new_args), row.names=NULL),
> >    {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
> > ": ", tbl))}
> > )
> > signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
> > collapse="\n"))
> > writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
>


From m|ch@e|ch|r|co4 @end|ng |rom gm@||@com  Tue Jun 10 19:46:23 2025
From: m|ch@e|ch|r|co4 @end|ng |rom gm@||@com (Michael Chirico)
Date: Tue, 10 Jun 2025 10:46:23 -0700
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <CAN+W6_t7SK66xJUHzFyitwN4EgaX_cqSq+X+0_Ca=j1VdBNKtw@mail.gmail.com>
References: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
 <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>
 <CAPRVBcysU3cm4tAbySD4su8pxfTy1fLwGh==sY+c58=FoVBPJw@mail.gmail.com>
 <CAN+W6_t7SK66xJUHzFyitwN4EgaX_cqSq+X+0_Ca=j1VdBNKtw@mail.gmail.com>
Message-ID: <CAPRVBcwMwqF4STckKG7cg2LchhNJKHW+o5iyUfGCusz1Q7We2A@mail.gmail.com>

When it comes to adding more info in the help pages, we'd be remiss
not to point out the great engineering work the tidyverse folks have
put in to this end:

https://dplyr.tidyverse.org/reference/mutate.html

> Methods available in currently loaded packages: dbplyr (tbl_lazy), dplyr (data.frame) .

https://github.com/tidyverse/dplyr/blob/9df9d63234f34837fa058bbd081a42dfb8a4eeb0/R/mutate.R#L78-L79
https://github.com/tidyverse/dplyr/blob/be3e3a05fd0081cb53168d6aedb417d62139b75d/R/doc-methods.R#L57-L75

On Mon, Jun 9, 2025 at 2:25?PM Llu?s Revilla <lluis.revilla at gmail.com> wrote:
>
> Hi,
>
> I agree that showing that there are other methods might help.
> The print.function method could be modified to add this in addition to print.default output.
>
> But I guess (new) users would check the help page with ?as.data.frame and not print the method or use args() (if they don't check with their prefered LLM/agent).
> Would it be helpful to also report these numbers on the documentation page of the generic too?
>
> Best,
>
> Llu?s
>
>
> PS: Trying to see what happens with ? and looking for a specific method I found that on my computer with R-devel (2025-06-08 r88288), the expressions below the "Not run:" on ? examples raise errors.
>
>
> On Mon, 9 Jun 2025 at 08:07, Michael Chirico <michaelchirico4 at gmail.com> wrote:
>>
>> Thanks Josh,
>>
>> With fresh eyes, it's definitely information overload for the
>> suggested output to take up more space than the function body itself.
>>
>> I'm not sure your suggestion gets at the heart of the issue, though,
>> which is about steering the user with regards to interpreting '...'
>> they see in the printout.
>>
>> Therefore I would suggest something like this as the economized
>> version of my original suggestion:
>>
>> > print(rbind)
>> function (..., deparse.level = 1)
>> # ...
>> <environment: namespace:base>
>> + 1 other method defines 3 other arguments. See methods(rbind).
>>
>> > print(as.data.frame)
>> function (x, row.names = NULL, optional = FALSE, ...)
>> # ...
>> <environment: namespace:base>
>> + 29 other methods define 11 other arguments. See methods(as.data.frame).
>>
>> Mike C
>>
>> On Sun, Jun 8, 2025 at 3:57?PM Joshua Ulrich <josh.m.ulrich at gmail.com> wrote:
>> >
>> > Hi Mike,
>> >
>> > On Fri, Jun 6, 2025 at 1:59?PM Michael Chirico
>> > <michaelchirico4 at gmail.com> wrote:
>> > >
>> > > There is a big difference in how to think of '...' for non-generic
>> > > functions like data.frame() vs. S3 generics.
>> > >
>> > > In the former, it means "any number of inputs" [e.g. columns]; in the
>> > > latter, it means "any number of inputs [think c()], as well as any
>> > > arguments that might be interpreted by class implementations".
>> > >
>> > > Understanding the difference for a given generic can require carefully
>> > > reading lots of documentation. print(<generic>), which is useful for
>> > > so many other contexts, can be a dead end.
>> > >
>> > > One idea is to extend the print() method to suggest to the reader
>> > > which other arguments are available (among registered generics). Often
>> > > ?<generic> will include the most common implementation, but not always
>> > > so.
>> > >
>> > > For rbind (in a --vanilla session), we currently have one method,
>> > > rbind.data.frame, that offers three arguments not present in the
>> > > generic: make.row.names, stringsAsFactors, and factor.exclude. The
>> > > proposal would be to mention this in the print(rbind) output somehow,
>> > > e.g.
>> > >
>> > > > print(rbind)
>> > > function (..., deparse.level = 1)
>> > > .Internal(rbind(deparse.level, ...))
>> > > <bytecode: 0x73d4fd824e20>
>> > > <environment: namespace:base>
>> > >
>> > > +Other arguments implemented by methods
>> > > +  factor.exclude: rbind.data.frame
>> > > +  make.row.names: rbind.data.frame
>> > > +  stringsAsFactors: rbind.data.frame
>> > >
>> > > I suggest grouping by argument, not generic, although something like
>> > > this could be OK too:
>> > >
>> > > +Signatures of other methods
>> > > +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
>> > > stringsAsFactors = FALSE,
>> > > +      factor.exclude = TRUE)
>> > >
>> > > Where it gets more interesting is when there are many methods, e.g.
>> > > for as.data.frame (again, in a --vanilla session):
>> > >
>> > > > print(as.data.frame)
>> > > function (x, row.names = NULL, optional = FALSE, ...)
>> > > {
>> > >     if (is.null(x))
>> > >         return(as.data.frame(list()))
>> > >     UseMethod("as.data.frame")
>> > > }
>> > > <bytecode: 0x73d4fc1e70d0>
>> > > <environment: namespace:base>
>> > >
>> > > +Other arguments implemented by methods
>> > > +  base: as.data.frame.table
>> > > +  check.names: as.data.frame.list
>> > > +  col.names: as.data.frame.list
>> > > +  cut.names: as.data.frame.list
>> > > +  fix.empty.names: as.data.frame.list
>> > > +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
>> > > +  new.names: as.data.frame.list
>> > > +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
>> > > +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
>> > > +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
>> > > +    as.data.frame.numeric_version, as.data.frame.ordered,
>> > > +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
>> > > +  responseName: as.data.frame.table
>> > > +  sep: as.data.frame.table
>> > > +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
>> > > +    as.data.frame.matrix, as.data.frame.table
>> > >
>> > > Or
>> > >
>> > > +Signatures of other methods
>> > > +  as.data.frame.aovproj(x, ...)
>> > > +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
>> > > +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
>> > > +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
>> > > +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
>> > > +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.data.frame(x, row.names = NULL, ...)
>> > > +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
>> > > deparse1(substitute(x)))
>> > > +  as.data.frame.default(x, ...)
>> > > +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
>> > > = deparse1(substitute(x)))
>> > > +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
>> > > +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
>> > > cut.names = FALSE,
>> > > +      col.names = names(x), fix.empty.names = TRUE, new.names =
>> > > !missing(col.names),
>> > > +      check.names = !optional, stringsAsFactors = FALSE)
>> > > +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.logLik(x, ...)
>> > > +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
>> > > make.names = TRUE,
>> > > +      ..., stringsAsFactors = FALSE)
>> > > +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
>> > > make.names = TRUE,
>> > > +      ...)
>> > > +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.numeric_version(x, row.names = NULL, optional =
>> > > FALSE, ..., nm = deparse1(substitute(x)))
>> > > +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
>> > > = deparse1(substitute(x)))
>> > > +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
>> > > nm = deparse1(substitute(x)))
>> > > +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
>> > > +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
>> > > deparse1(substitute(x)))
>> > > +  as.data.frame.table(x, row.names = NULL, ..., responseName =
>> > > "Freq", stringsAsFactors = TRUE,
>> > > +      sep = "", base = list(LETTERS))
>> > > +  as.data.frame.ts(x, ...)
>> > >
>> > > Obviously that's a bit more cluttered, but as.data.frame() should be a
>> > > pretty unusual case. It also highlights better the differences in the
>> > > two approaches: the former economizes on space and focuses on what
>> > > sorts of arguments are available; the latter shows the defaults, does
>> > > not hide the arguments shared with the generic, and will always
>> > > produce as many lines as there are methods.
>> > >
>> > > There are other edge cases to think through (multiple registrations,
>> > > interactions with S4, primitives, ...), but I want to first check with
>> > > the list if this looks workable & valuable enough to pursue.
>> > >
>> > I like and appreciate the intent behind your suggestion, though I
>> > don't like all the extra output from printing the generic. I want to
>> > look at the function body when I print it. And as you show, it can
>> > output a lot of information you're probably not interested in.
>> >
>> > What about adding the number of methods to printed output for
>> > generics, and a suggestion to use `methods(some_generic)` to get a
>> > list of them? Then you can use help(some_method) or args(some_method)
>> > to get more information about the specific method(s) you're interested
>> > in.
>> >
>> > Best,
>> > Josh
>> >
>> > > Mike C
>> > >
>> > > ----
>> > >
>> > > Code that helped with the above:
>> > >
>> > > f = as.data.frame
>> > > # NB: methods() and getAnywhere() require {utils}
>> > > m = methods(f)
>> > > generic_args = names(formals(f))
>> > > f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
>> > > names(f_methods) = m
>> > > new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
>> > > with( # group by argument name
>> > >   data.frame(method = rep(names(new_args), lengths(new_args)), arg =
>> > > unlist(new_args), row.names=NULL),
>> > >   {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
>> > > ": ", tbl))}
>> > > )
>> > > signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
>> > > collapse="\n"))
>> > > writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
>> > >
>> > > ______________________________________________
>> > > R-devel at r-project.org mailing list
>> > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>> >
>> >
>> > --
>> > Joshua Ulrich  |  about.me/joshuaulrich
>> > FOSS Trading  |  www.fosstrading.com
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Jun 10 21:10:39 2025
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 10 Jun 2025 15:10:39 -0400
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <CAPRVBcwMwqF4STckKG7cg2LchhNJKHW+o5iyUfGCusz1Q7We2A@mail.gmail.com>
References: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
 <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>
 <CAPRVBcysU3cm4tAbySD4su8pxfTy1fLwGh==sY+c58=FoVBPJw@mail.gmail.com>
 <CAN+W6_t7SK66xJUHzFyitwN4EgaX_cqSq+X+0_Ca=j1VdBNKtw@mail.gmail.com>
 <CAPRVBcwMwqF4STckKG7cg2LchhNJKHW+o5iyUfGCusz1Q7We2A@mail.gmail.com>
Message-ID: <323705af-ee1c-4421-9927-6f8b96fea12c@gmail.com>

On 2025-06-10 1:46 p.m., Michael Chirico wrote:
> When it comes to adding more info in the help pages, we'd be remiss
> not to point out the great engineering work the tidyverse folks have
> put in to this end:
> 
> https://dplyr.tidyverse.org/reference/mutate.html
> 
>> Methods available in currently loaded packages: dbplyr (tbl_lazy), dplyr (data.frame) .
> 
> https://github.com/tidyverse/dplyr/blob/9df9d63234f34837fa058bbd081a42dfb8a4eeb0/R/mutate.R#L78-L79
> https://github.com/tidyverse/dplyr/blob/be3e3a05fd0081cb53168d6aedb417d62139b75d/R/doc-methods.R#L57-L75

Those lines arise from this entry in the Rd file:

   \Sexpr[stage=render,results=rd]{dplyr:::methods_rd("mutate")}

The dplyr:::methods_rd function basically just formats the results of a 
call similar to `methods("mutate")`.  All the rest of that is by R Core, 
not tidyverse folks.

Duncan Murdoch


> 
> On Mon, Jun 9, 2025 at 2:25?PM Llu?s Revilla <lluis.revilla at gmail.com> wrote:
>>
>> Hi,
>>
>> I agree that showing that there are other methods might help.
>> The print.function method could be modified to add this in addition to print.default output.
>>
>> But I guess (new) users would check the help page with ?as.data.frame and not print the method or use args() (if they don't check with their prefered LLM/agent).
>> Would it be helpful to also report these numbers on the documentation page of the generic too?
>>
>> Best,
>>
>> Llu?s
>>
>>
>> PS: Trying to see what happens with ? and looking for a specific method I found that on my computer with R-devel (2025-06-08 r88288), the expressions below the "Not run:" on ? examples raise errors.
>>
>>
>> On Mon, 9 Jun 2025 at 08:07, Michael Chirico <michaelchirico4 at gmail.com> wrote:
>>>
>>> Thanks Josh,
>>>
>>> With fresh eyes, it's definitely information overload for the
>>> suggested output to take up more space than the function body itself.
>>>
>>> I'm not sure your suggestion gets at the heart of the issue, though,
>>> which is about steering the user with regards to interpreting '...'
>>> they see in the printout.
>>>
>>> Therefore I would suggest something like this as the economized
>>> version of my original suggestion:
>>>
>>>> print(rbind)
>>> function (..., deparse.level = 1)
>>> # ...
>>> <environment: namespace:base>
>>> + 1 other method defines 3 other arguments. See methods(rbind).
>>>
>>>> print(as.data.frame)
>>> function (x, row.names = NULL, optional = FALSE, ...)
>>> # ...
>>> <environment: namespace:base>
>>> + 29 other methods define 11 other arguments. See methods(as.data.frame).
>>>
>>> Mike C
>>>
>>> On Sun, Jun 8, 2025 at 3:57?PM Joshua Ulrich <josh.m.ulrich at gmail.com> wrote:
>>>>
>>>> Hi Mike,
>>>>
>>>> On Fri, Jun 6, 2025 at 1:59?PM Michael Chirico
>>>> <michaelchirico4 at gmail.com> wrote:
>>>>>
>>>>> There is a big difference in how to think of '...' for non-generic
>>>>> functions like data.frame() vs. S3 generics.
>>>>>
>>>>> In the former, it means "any number of inputs" [e.g. columns]; in the
>>>>> latter, it means "any number of inputs [think c()], as well as any
>>>>> arguments that might be interpreted by class implementations".
>>>>>
>>>>> Understanding the difference for a given generic can require carefully
>>>>> reading lots of documentation. print(<generic>), which is useful for
>>>>> so many other contexts, can be a dead end.
>>>>>
>>>>> One idea is to extend the print() method to suggest to the reader
>>>>> which other arguments are available (among registered generics). Often
>>>>> ?<generic> will include the most common implementation, but not always
>>>>> so.
>>>>>
>>>>> For rbind (in a --vanilla session), we currently have one method,
>>>>> rbind.data.frame, that offers three arguments not present in the
>>>>> generic: make.row.names, stringsAsFactors, and factor.exclude. The
>>>>> proposal would be to mention this in the print(rbind) output somehow,
>>>>> e.g.
>>>>>
>>>>>> print(rbind)
>>>>> function (..., deparse.level = 1)
>>>>> .Internal(rbind(deparse.level, ...))
>>>>> <bytecode: 0x73d4fd824e20>
>>>>> <environment: namespace:base>
>>>>>
>>>>> +Other arguments implemented by methods
>>>>> +  factor.exclude: rbind.data.frame
>>>>> +  make.row.names: rbind.data.frame
>>>>> +  stringsAsFactors: rbind.data.frame
>>>>>
>>>>> I suggest grouping by argument, not generic, although something like
>>>>> this could be OK too:
>>>>>
>>>>> +Signatures of other methods
>>>>> +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
>>>>> stringsAsFactors = FALSE,
>>>>> +      factor.exclude = TRUE)
>>>>>
>>>>> Where it gets more interesting is when there are many methods, e.g.
>>>>> for as.data.frame (again, in a --vanilla session):
>>>>>
>>>>>> print(as.data.frame)
>>>>> function (x, row.names = NULL, optional = FALSE, ...)
>>>>> {
>>>>>      if (is.null(x))
>>>>>          return(as.data.frame(list()))
>>>>>      UseMethod("as.data.frame")
>>>>> }
>>>>> <bytecode: 0x73d4fc1e70d0>
>>>>> <environment: namespace:base>
>>>>>
>>>>> +Other arguments implemented by methods
>>>>> +  base: as.data.frame.table
>>>>> +  check.names: as.data.frame.list
>>>>> +  col.names: as.data.frame.list
>>>>> +  cut.names: as.data.frame.list
>>>>> +  fix.empty.names: as.data.frame.list
>>>>> +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
>>>>> +  new.names: as.data.frame.list
>>>>> +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
>>>>> +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
>>>>> +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
>>>>> +    as.data.frame.numeric_version, as.data.frame.ordered,
>>>>> +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
>>>>> +  responseName: as.data.frame.table
>>>>> +  sep: as.data.frame.table
>>>>> +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
>>>>> +    as.data.frame.matrix, as.data.frame.table
>>>>>
>>>>> Or
>>>>>
>>>>> +Signatures of other methods
>>>>> +  as.data.frame.aovproj(x, ...)
>>>>> +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
>>>>> +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
>>>>> +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
>>>>> +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
>>>>> +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.data.frame(x, row.names = NULL, ...)
>>>>> +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
>>>>> deparse1(substitute(x)))
>>>>> +  as.data.frame.default(x, ...)
>>>>> +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
>>>>> = deparse1(substitute(x)))
>>>>> +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
>>>>> +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
>>>>> cut.names = FALSE,
>>>>> +      col.names = names(x), fix.empty.names = TRUE, new.names =
>>>>> !missing(col.names),
>>>>> +      check.names = !optional, stringsAsFactors = FALSE)
>>>>> +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.logLik(x, ...)
>>>>> +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
>>>>> make.names = TRUE,
>>>>> +      ..., stringsAsFactors = FALSE)
>>>>> +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
>>>>> make.names = TRUE,
>>>>> +      ...)
>>>>> +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.numeric_version(x, row.names = NULL, optional =
>>>>> FALSE, ..., nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
>>>>> = deparse1(substitute(x)))
>>>>> +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
>>>>> nm = deparse1(substitute(x)))
>>>>> +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
>>>>> +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
>>>>> deparse1(substitute(x)))
>>>>> +  as.data.frame.table(x, row.names = NULL, ..., responseName =
>>>>> "Freq", stringsAsFactors = TRUE,
>>>>> +      sep = "", base = list(LETTERS))
>>>>> +  as.data.frame.ts(x, ...)
>>>>>
>>>>> Obviously that's a bit more cluttered, but as.data.frame() should be a
>>>>> pretty unusual case. It also highlights better the differences in the
>>>>> two approaches: the former economizes on space and focuses on what
>>>>> sorts of arguments are available; the latter shows the defaults, does
>>>>> not hide the arguments shared with the generic, and will always
>>>>> produce as many lines as there are methods.
>>>>>
>>>>> There are other edge cases to think through (multiple registrations,
>>>>> interactions with S4, primitives, ...), but I want to first check with
>>>>> the list if this looks workable & valuable enough to pursue.
>>>>>
>>>> I like and appreciate the intent behind your suggestion, though I
>>>> don't like all the extra output from printing the generic. I want to
>>>> look at the function body when I print it. And as you show, it can
>>>> output a lot of information you're probably not interested in.
>>>>
>>>> What about adding the number of methods to printed output for
>>>> generics, and a suggestion to use `methods(some_generic)` to get a
>>>> list of them? Then you can use help(some_method) or args(some_method)
>>>> to get more information about the specific method(s) you're interested
>>>> in.
>>>>
>>>> Best,
>>>> Josh
>>>>
>>>>> Mike C
>>>>>
>>>>> ----
>>>>>
>>>>> Code that helped with the above:
>>>>>
>>>>> f = as.data.frame
>>>>> # NB: methods() and getAnywhere() require {utils}
>>>>> m = methods(f)
>>>>> generic_args = names(formals(f))
>>>>> f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
>>>>> names(f_methods) = m
>>>>> new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
>>>>> with( # group by argument name
>>>>>    data.frame(method = rep(names(new_args), lengths(new_args)), arg =
>>>>> unlist(new_args), row.names=NULL),
>>>>>    {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
>>>>> ": ", tbl))}
>>>>> )
>>>>> signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
>>>>> collapse="\n"))
>>>>> writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>>
>>>>
>>>> --
>>>> Joshua Ulrich  |  about.me/joshuaulrich
>>>> FOSS Trading  |  www.fosstrading.com
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From j@g@nmn2 @end|ng |rom gm@||@com  Tue Jun 10 21:56:13 2025
From: j@g@nmn2 @end|ng |rom gm@||@com (Mikael Jagan)
Date: Tue, 10 Jun 2025 15:56:13 -0400
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <CAPRVBcwJHvDkOPDbbKX=b3EjLFWy7yGgCMvRiw-piyR6+R4ZQQ@mail.gmail.com>
References: <mailman.54933.3.1749290401.32909.r-devel@r-project.org>
 <50f36c21-0503-4166-9c9e-1017f468dc1a@gmail.com>
 <CAPRVBcwJHvDkOPDbbKX=b3EjLFWy7yGgCMvRiw-piyR6+R4ZQQ@mail.gmail.com>
Message-ID: <595430b0-9db7-45e6-9719-7eaae3f1894a@gmail.com>



On 2025-06-10 12:15 pm, Michael Chirico wrote:
> Thanks for the thoughtful reply Mikael.
> 
>> Any function F with '...' as a formal argument can pass '...' to another function G.
> 
> Yes, that's true. The difference is that in print(F) we can _usually_
> pick out at a glance how '...' is being used -- we can see which 'G'
> is getting '...'.
> 
> For S3 generics, we quickly reach the dead end of 'UseMethod' -- F
> being S3 generic is in fact _highly_ relevant.
> 

I don't really think of calls to UseMethod as dead ends.  I immediately do
something like

     for (nm in paste0(generic, ".", c(.class2(object), "default"))) {
         print(help(nm)) # or print(argsAnywhere(nm)) or ...
         if (satisfied) break
     }

In other words, I seek info about only those methods that might actually be
dispatched.  Details about other methods are really an unwanted distraction.

But, yes, the fact that '...' does not appear in calls to UseMethod is a
legitimate distinction, so thanks for clarifying.

As I see it, R provides many tools enabling users to efficiently and
programmatically interrogate the dispatch mechanism, available methods, their
formal arguments, etc.  These seem well documented but not enough advertised.
Hence I would sooner work to improve and promote the tools than work to change
print.default, especially if those changes risk overwhelming very new users of
R who may know nothing about OOP and for whom print.default is a primary mode
of interrogation.

Mikael

> Yes, the practical issues you raise are interesting & knotty (I
> especially have in mind [1] and [2]), but ultimately I think we could
> come up with something useful. Whether that becomes a default can
> depend on how useful it winds up being, and the empirical risk of
> back-incompatibility (which I suspect is low).
> 
> Mike C
> 
> [1] utils::isS3stdGeneric
> https://stat.ethz.ch/R-manual/R-devel/library/utils/html/isS3stdGen.html,
> which has a large # of false negatives
> [2] utils::nonS3methods
> https://stat.ethz.ch/R-manual/R-devel/library/tools/html/QC.html,
> which maintains an onerous list of S3 method lookalikes
> 
> On Mon, Jun 9, 2025 at 8:44?PM Mikael Jagan <jaganmn2 at gmail.com> wrote:
>>
>> I don't really understand the premise.  Any function F with '...' as a formal
>> argument can pass '...' to another function G.  The actual arguments matching
>> '...' in the call to F will be matched to the formal arguments of G.  So the
>> the maintainer of F may want to alert the user of F to the existence of G and
>> the user of F may want to consult the documentation of G.
>>
>> Whether F is S3 generic and G is registered as a method for F seems irrelevant.
>>
>> That is a conceptual issue.  There are practical issues, too:
>>
>>       * print.default is used "everywhere".  Backwards incompatible changes to
>>         default behaviour have the potential to break a lot of code out there.
>>
>>       * Testing that a function F is S3 generic seems nontrivial.  You have to
>>         deal with internally generic functions and for closures recurse through
>>         body(F) looking for a call to UseMethod.
>>
>>       * I would not want the output of print(F) to depend on details external to
>>         F or the method call, such as the state of the table of registered S3
>>         methods which changes as packages are loaded.  AFAIK, it is intended that
>>         options() is the only exception to the rule.
>>
>>       * More harmonious would be to implement the feature ("give me more
>>         information about S3 methods") as an option (disabled by default) of
>>         utils::.S3methods if not as a new function altogether.
>>
>> Mikael
>>
>>> Date: Fri, 6 Jun 2025 11:59:08 -0700
>>> From: Michael Chirico<michaelchirico4 at gmail.com>
>>>
>>> There is a big difference in how to think of '...' for non-generic
>>> functions like data.frame() vs. S3 generics.
>>>
>>> In the former, it means "any number of inputs" [e.g. columns]; in the
>>> latter, it means "any number of inputs [think c()], as well as any
>>> arguments that might be interpreted by class implementations".
>>>
>>> Understanding the difference for a given generic can require carefully
>>> reading lots of documentation. print(<generic>), which is useful for
>>> so many other contexts, can be a dead end.
>>>
>>> One idea is to extend the print() method to suggest to the reader
>>> which other arguments are available (among registered generics). Often
>>> ?<generic> will include the most common implementation, but not always
>>> so.
>>>
>>> For rbind (in a --vanilla session), we currently have one method,
>>> rbind.data.frame, that offers three arguments not present in the
>>> generic: make.row.names, stringsAsFactors, and factor.exclude. The
>>> proposal would be to mention this in the print(rbind) output somehow,
>>> e.g.
>>>
>>>> print(rbind)
>>> function (..., deparse.level = 1)
>>> .Internal(rbind(deparse.level, ...))
>>> <bytecode: 0x73d4fd824e20>
>>> <environment: namespace:base>
>>>
>>> +Other arguments implemented by methods
>>> +  factor.exclude: rbind.data.frame
>>> +  make.row.names: rbind.data.frame
>>> +  stringsAsFactors: rbind.data.frame
>>>
>>> I suggest grouping by argument, not generic, although something like
>>> this could be OK too:
>>>
>>> +Signatures of other methods
>>> +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
>>> stringsAsFactors = FALSE,
>>> +      factor.exclude = TRUE)
>>>
>>> Where it gets more interesting is when there are many methods, e.g.
>>> for as.data.frame (again, in a --vanilla session):
>>>
>>>> print(as.data.frame)
>>> function (x, row.names = NULL, optional = FALSE, ...)
>>> {
>>>       if (is.null(x))
>>>           return(as.data.frame(list()))
>>>       UseMethod("as.data.frame")
>>> }
>>> <bytecode: 0x73d4fc1e70d0>
>>> <environment: namespace:base>
>>>
>>> +Other arguments implemented by methods
>>> +  base: as.data.frame.table
>>> +  check.names: as.data.frame.list
>>> +  col.names: as.data.frame.list
>>> +  cut.names: as.data.frame.list
>>> +  fix.empty.names: as.data.frame.list
>>> +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
>>> +  new.names: as.data.frame.list
>>> +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
>>> +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
>>> +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
>>> +    as.data.frame.numeric_version, as.data.frame.ordered,
>>> +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
>>> +  responseName: as.data.frame.table
>>> +  sep: as.data.frame.table
>>> +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
>>> +    as.data.frame.matrix, as.data.frame.table
>>>
>>> Or
>>>
>>> +Signatures of other methods
>>> +  as.data.frame.aovproj(x, ...)
>>> +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
>>> +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
>>> +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
>>> +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
>>> +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.data.frame(x, row.names = NULL, ...)
>>> +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
>>> deparse1(substitute(x)))
>>> +  as.data.frame.default(x, ...)
>>> +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
>>> = deparse1(substitute(x)))
>>> +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
>>> +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
>>> cut.names = FALSE,
>>> +      col.names = names(x), fix.empty.names = TRUE, new.names =
>>> !missing(col.names),
>>> +      check.names = !optional, stringsAsFactors = FALSE)
>>> +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.logLik(x, ...)
>>> +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
>>> make.names = TRUE,
>>> +      ..., stringsAsFactors = FALSE)
>>> +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
>>> make.names = TRUE,
>>> +      ...)
>>> +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.numeric_version(x, row.names = NULL, optional =
>>> FALSE, ..., nm = deparse1(substitute(x)))
>>> +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
>>> = deparse1(substitute(x)))
>>> +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
>>> nm = deparse1(substitute(x)))
>>> +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
>>> +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
>>> deparse1(substitute(x)))
>>> +  as.data.frame.table(x, row.names = NULL, ..., responseName =
>>> "Freq", stringsAsFactors = TRUE,
>>> +      sep = "", base = list(LETTERS))
>>> +  as.data.frame.ts(x, ...)
>>>
>>> Obviously that's a bit more cluttered, but as.data.frame() should be a
>>> pretty unusual case. It also highlights better the differences in the
>>> two approaches: the former economizes on space and focuses on what
>>> sorts of arguments are available; the latter shows the defaults, does
>>> not hide the arguments shared with the generic, and will always
>>> produce as many lines as there are methods.
>>>
>>> There are other edge cases to think through (multiple registrations,
>>> interactions with S4, primitives, ...), but I want to first check with
>>> the list if this looks workable & valuable enough to pursue.
>>>
>>> Mike C
>>>
>>> ----
>>>
>>> Code that helped with the above:
>>>
>>> f = as.data.frame
>>> # NB: methods() and getAnywhere() require {utils}
>>> m = methods(f)
>>> generic_args = names(formals(f))
>>> f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
>>> names(f_methods) = m
>>> new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
>>> with( # group by argument name
>>>     data.frame(method = rep(names(new_args), lengths(new_args)), arg =
>>> unlist(new_args), row.names=NULL),
>>>     {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
>>> ": ", tbl))}
>>> )
>>> signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
>>> collapse="\n"))
>>> writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
>>


From @eb@meyer @end|ng |rom |@u@de  Wed Jun 11 10:25:54 2025
From: @eb@meyer @end|ng |rom |@u@de (Sebastian Meyer)
Date: Wed, 11 Jun 2025 10:25:54 +0200
Subject: [Rd] 
 Suggestion: default print method for S3 generics could offer
 some insights on '...' among registered methods
In-Reply-To: <323705af-ee1c-4421-9927-6f8b96fea12c@gmail.com>
References: <CAPRVBczf9=kGdzpK1+3g9z-P3HT6C93wrqYZAbJgG2bALstx4w@mail.gmail.com>
 <CAPPM_gQytn5uvV25X563OuTgmQ=Xt067=OD76itKjMriWANSWA@mail.gmail.com>
 <CAPRVBcysU3cm4tAbySD4su8pxfTy1fLwGh==sY+c58=FoVBPJw@mail.gmail.com>
 <CAN+W6_t7SK66xJUHzFyitwN4EgaX_cqSq+X+0_Ca=j1VdBNKtw@mail.gmail.com>
 <CAPRVBcwMwqF4STckKG7cg2LchhNJKHW+o5iyUfGCusz1Q7We2A@mail.gmail.com>
 <323705af-ee1c-4421-9927-6f8b96fea12c@gmail.com>
Message-ID: <e28662ea-7bac-4e53-bff4-e2134d847680@fau.de>

Am 10.06.25 um 21:10 schrieb Duncan Murdoch:
> On 2025-06-10 1:46 p.m., Michael Chirico wrote:
>> When it comes to adding more info in the help pages, we'd be remiss
>> not to point out the great engineering work the tidyverse folks have
>> put in to this end:
>>
>> https://dplyr.tidyverse.org/reference/mutate.html
>>
>>> Methods available in currently loaded packages: dbplyr (tbl_lazy), dplyr (data.frame) .
>>
>> https://github.com/tidyverse/dplyr/blob/9df9d63234f34837fa058bbd081a42dfb8a4eeb0/R/mutate.R#L78-L79
>> https://github.com/tidyverse/dplyr/blob/be3e3a05fd0081cb53168d6aedb417d62139b75d/R/doc-methods.R#L57-L75
> 
> Those lines arise from this entry in the Rd file:
> 
>     \Sexpr[stage=render,results=rd]{dplyr:::methods_rd("mutate")}
> 
> The dplyr:::methods_rd function basically just formats the results of a
> call similar to `methods("mutate")`.  All the rest of that is by R Core,

including former R-core members, of course! AFAICS, the Rd \Sexpr macro 
was introduced in R 2.10.0 and most of it was originally implemented by 
svn author "murdoch".

	Sebastian Meyer

> not tidyverse folks.
> 
> Duncan Murdoch
> 
> 
>>
>> On Mon, Jun 9, 2025 at 2:25?PM Llu?s Revilla <lluis.revilla at gmail.com> wrote:
>>>
>>> Hi,
>>>
>>> I agree that showing that there are other methods might help.
>>> The print.function method could be modified to add this in addition to print.default output.
>>>
>>> But I guess (new) users would check the help page with ?as.data.frame and not print the method or use args() (if they don't check with their prefered LLM/agent).
>>> Would it be helpful to also report these numbers on the documentation page of the generic too?
>>>
>>> Best,
>>>
>>> Llu?s
>>>
>>>
>>> PS: Trying to see what happens with ? and looking for a specific method I found that on my computer with R-devel (2025-06-08 r88288), the expressions below the "Not run:" on ? examples raise errors.
>>>
>>>
>>> On Mon, 9 Jun 2025 at 08:07, Michael Chirico <michaelchirico4 at gmail.com> wrote:
>>>>
>>>> Thanks Josh,
>>>>
>>>> With fresh eyes, it's definitely information overload for the
>>>> suggested output to take up more space than the function body itself.
>>>>
>>>> I'm not sure your suggestion gets at the heart of the issue, though,
>>>> which is about steering the user with regards to interpreting '...'
>>>> they see in the printout.
>>>>
>>>> Therefore I would suggest something like this as the economized
>>>> version of my original suggestion:
>>>>
>>>>> print(rbind)
>>>> function (..., deparse.level = 1)
>>>> # ...
>>>> <environment: namespace:base>
>>>> + 1 other method defines 3 other arguments. See methods(rbind).
>>>>
>>>>> print(as.data.frame)
>>>> function (x, row.names = NULL, optional = FALSE, ...)
>>>> # ...
>>>> <environment: namespace:base>
>>>> + 29 other methods define 11 other arguments. See methods(as.data.frame).
>>>>
>>>> Mike C
>>>>
>>>> On Sun, Jun 8, 2025 at 3:57?PM Joshua Ulrich <josh.m.ulrich at gmail.com> wrote:
>>>>>
>>>>> Hi Mike,
>>>>>
>>>>> On Fri, Jun 6, 2025 at 1:59?PM Michael Chirico
>>>>> <michaelchirico4 at gmail.com> wrote:
>>>>>>
>>>>>> There is a big difference in how to think of '...' for non-generic
>>>>>> functions like data.frame() vs. S3 generics.
>>>>>>
>>>>>> In the former, it means "any number of inputs" [e.g. columns]; in the
>>>>>> latter, it means "any number of inputs [think c()], as well as any
>>>>>> arguments that might be interpreted by class implementations".
>>>>>>
>>>>>> Understanding the difference for a given generic can require carefully
>>>>>> reading lots of documentation. print(<generic>), which is useful for
>>>>>> so many other contexts, can be a dead end.
>>>>>>
>>>>>> One idea is to extend the print() method to suggest to the reader
>>>>>> which other arguments are available (among registered generics). Often
>>>>>> ?<generic> will include the most common implementation, but not always
>>>>>> so.
>>>>>>
>>>>>> For rbind (in a --vanilla session), we currently have one method,
>>>>>> rbind.data.frame, that offers three arguments not present in the
>>>>>> generic: make.row.names, stringsAsFactors, and factor.exclude. The
>>>>>> proposal would be to mention this in the print(rbind) output somehow,
>>>>>> e.g.
>>>>>>
>>>>>>> print(rbind)
>>>>>> function (..., deparse.level = 1)
>>>>>> .Internal(rbind(deparse.level, ...))
>>>>>> <bytecode: 0x73d4fd824e20>
>>>>>> <environment: namespace:base>
>>>>>>
>>>>>> +Other arguments implemented by methods
>>>>>> +  factor.exclude: rbind.data.frame
>>>>>> +  make.row.names: rbind.data.frame
>>>>>> +  stringsAsFactors: rbind.data.frame
>>>>>>
>>>>>> I suggest grouping by argument, not generic, although something like
>>>>>> this could be OK too:
>>>>>>
>>>>>> +Signatures of other methods
>>>>>> +  rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE,
>>>>>> stringsAsFactors = FALSE,
>>>>>> +      factor.exclude = TRUE)
>>>>>>
>>>>>> Where it gets more interesting is when there are many methods, e.g.
>>>>>> for as.data.frame (again, in a --vanilla session):
>>>>>>
>>>>>>> print(as.data.frame)
>>>>>> function (x, row.names = NULL, optional = FALSE, ...)
>>>>>> {
>>>>>>       if (is.null(x))
>>>>>>           return(as.data.frame(list()))
>>>>>>       UseMethod("as.data.frame")
>>>>>> }
>>>>>> <bytecode: 0x73d4fc1e70d0>
>>>>>> <environment: namespace:base>
>>>>>>
>>>>>> +Other arguments implemented by methods
>>>>>> +  base: as.data.frame.table
>>>>>> +  check.names: as.data.frame.list
>>>>>> +  col.names: as.data.frame.list
>>>>>> +  cut.names: as.data.frame.list
>>>>>> +  fix.empty.names: as.data.frame.list
>>>>>> +  make.names: as.data.frame.matrix, as.data.frame.model.matrix
>>>>>> +  new.names: as.data.frame.list
>>>>>> +  nm: as.data.frame.bibentry, as.data.frame.complex, as.data.frame.Date,
>>>>>> +    as.data.frame.difftime, as.data.frame.factor, as.data.frame.integer,
>>>>>> +    as.data.frame.logical, as.data.frame.noquote, as.data.frame.numeric,
>>>>>> +    as.data.frame.numeric_version, as.data.frame.ordered,
>>>>>> +    as.data.frame.person, as.data.frame.POSIXct, as.data.frame.raw
>>>>>> +  responseName: as.data.frame.table
>>>>>> +  sep: as.data.frame.table
>>>>>> +  stringsAsFactors: as.data.frame.character, as.data.frame.list,
>>>>>> +    as.data.frame.matrix, as.data.frame.table
>>>>>>
>>>>>> Or
>>>>>>
>>>>>> +Signatures of other methods
>>>>>> +  as.data.frame.aovproj(x, ...)
>>>>>> +  as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)
>>>>>> +  as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)
>>>>>> +  as.data.frame.bibentry(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.character(x, ..., stringsAsFactors = FALSE)
>>>>>> +  as.data.frame.citation(x, row.names = NULL, optional = FALSE, ...)
>>>>>> +  as.data.frame.complex(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.data.frame(x, row.names = NULL, ...)
>>>>>> +  as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm =
>>>>>> deparse1(substitute(x)))
>>>>>> +  as.data.frame.default(x, ...)
>>>>>> +  as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm
>>>>>> = deparse1(substitute(x)))
>>>>>> +  as.data.frame.ftable(x, row.names = NULL, optional = FALSE, ...)
>>>>>> +  as.data.frame.integer(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.list(x, row.names = NULL, optional = FALSE, ...,
>>>>>> cut.names = FALSE,
>>>>>> +      col.names = names(x), fix.empty.names = TRUE, new.names =
>>>>>> !missing(col.names),
>>>>>> +      check.names = !optional, stringsAsFactors = FALSE)
>>>>>> +  as.data.frame.logical(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.logLik(x, ...)
>>>>>> +  as.data.frame.matrix(x, row.names = NULL, optional = FALSE,
>>>>>> make.names = TRUE,
>>>>>> +      ..., stringsAsFactors = FALSE)
>>>>>> +  as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE,
>>>>>> make.names = TRUE,
>>>>>> +      ...)
>>>>>> +  as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.numeric_version(x, row.names = NULL, optional =
>>>>>> FALSE, ..., nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.person(x, row.names = NULL, optional = FALSE, ..., nm
>>>>>> = deparse1(substitute(x)))
>>>>>> +  as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ...,
>>>>>> nm = deparse1(substitute(x)))
>>>>>> +  as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)
>>>>>> +  as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm =
>>>>>> deparse1(substitute(x)))
>>>>>> +  as.data.frame.table(x, row.names = NULL, ..., responseName =
>>>>>> "Freq", stringsAsFactors = TRUE,
>>>>>> +      sep = "", base = list(LETTERS))
>>>>>> +  as.data.frame.ts(x, ...)
>>>>>>
>>>>>> Obviously that's a bit more cluttered, but as.data.frame() should be a
>>>>>> pretty unusual case. It also highlights better the differences in the
>>>>>> two approaches: the former economizes on space and focuses on what
>>>>>> sorts of arguments are available; the latter shows the defaults, does
>>>>>> not hide the arguments shared with the generic, and will always
>>>>>> produce as many lines as there are methods.
>>>>>>
>>>>>> There are other edge cases to think through (multiple registrations,
>>>>>> interactions with S4, primitives, ...), but I want to first check with
>>>>>> the list if this looks workable & valuable enough to pursue.
>>>>>>
>>>>> I like and appreciate the intent behind your suggestion, though I
>>>>> don't like all the extra output from printing the generic. I want to
>>>>> look at the function body when I print it. And as you show, it can
>>>>> output a lot of information you're probably not interested in.
>>>>>
>>>>> What about adding the number of methods to printed output for
>>>>> generics, and a suggestion to use `methods(some_generic)` to get a
>>>>> list of them? Then you can use help(some_method) or args(some_method)
>>>>> to get more information about the specific method(s) you're interested
>>>>> in.
>>>>>
>>>>> Best,
>>>>> Josh
>>>>>
>>>>>> Mike C
>>>>>>
>>>>>> ----
>>>>>>
>>>>>> Code that helped with the above:
>>>>>>
>>>>>> f = as.data.frame
>>>>>> # NB: methods() and getAnywhere() require {utils}
>>>>>> m = methods(f)
>>>>>> generic_args = names(formals(f))
>>>>>> f_methods = lapply(m, \(fn) getAnywhere(fn)$objs[[1L]])
>>>>>> names(f_methods) = m
>>>>>> new_args = sapply(f_methods, \(g) setdiff(names(formals(g)), generic_args))
>>>>>> with( # group by argument name
>>>>>>     data.frame(method = rep(names(new_args), lengths(new_args)), arg =
>>>>>> unlist(new_args), row.names=NULL),
>>>>>>     {tbl = tapply(method, arg, toString); writeLines(paste0(names(tbl),
>>>>>> ": ", tbl))}
>>>>>> )
>>>>>> signatures=sapply(f_methods, \(g) paste(head(format(args(g)), -1),
>>>>>> collapse="\n"))
>>>>>> writeLines(paste0(names(signatures), gsub("^\\s*function\\s*", "", signatures)))
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Joshua Ulrich  |  about.me/joshuaulrich
>>>>> FOSS Trading  |  www.fosstrading.com
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From pd@me@ @end|ng |rom cb@@dk  Fri Jun 13 10:06:55 2025
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Fri, 13 Jun 2025 08:06:55 +0000
Subject: [Rd] R 4.5.1 is released
Message-ID: <9466D537-EBE3-4347-B8BF-42FDE61A7479@cbs.dk>

The build system rolled up R-4.5.1.tar.gz and .xz (codename ?Great Square Root") this morning.

This is a patch release with a handful of minor changes and mixups.

The list below details the changes in this release. 

You can get the source code from

https://cran.r-project.org/src/base/R-4/R-4.5.1.tar.gz
https://cran.r-project.org/src/base/R-4/R-4.5.1.tar.xz

or wait for it to be mirrored at a CRAN site nearer to you.

Binaries for various platforms will appear in due course. 


For the R Core Team,

Peter Dalgaard


These are the checksums (md5 and SHA-256) for the freshly created files, in case you wish
to check that they are uncorrupted:

MD5 (AUTHORS) = 07651d43d483521300ca8d68fc797522
MD5 (build-dist.log) = 5d3ce1a527ec387f0a1ffb34fd2dcb32
MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
MD5 (FAQ) = 509204af252e96df0f9c5232667136a9
MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
MD5 (NEWS) = d335f3e8664e05352e4ff5a43bfd0468
MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
MD5 (NEWS.1) = f8466e418dec6b958b4ce484a13f9a9d
MD5 (NEWS.2) = 05e4a57b645e651ba13019c3cf5c495f
MD5 (NEWS.3) = 082abfc2fdc36912075e78b92fb2941e
MD5 (R-latest.tar.gz) = e22eee30af90ec66eb179b66d122ffd9
MD5 (R-latest.tar.xz) = 9d027d75905654421dbaa7b3953e9760
MD5 (README) = e8e5ee38544d34409177cd479025fe66
MD5 (RESOURCES) = 94ab0226460af048446af1041a23771b
MD5 (THANKS) = 61d146aa6a2cf5999295b2fb340991c1
MD5 (VERSION-INFO.dcf) = a072111b90e7db672871542523a2793c
MD5 (R-4/R-4.5.1.tar.gz) = e22eee30af90ec66eb179b66d122ffd9
MD5 (R-4/R-4.5.1.tar.xz) = 9d027d75905654421dbaa7b3953e9760

b87c4dfcb4300f8af91009e2473f2ee5747e9e199df353c90146cba2aee8f444  AUTHORS
a1c0f18bc5f7a4e234aeb2877e62b477c478fb066ad217a70b302c3b8be9114f  build-dist.log
e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3  COPYING.LIB
5f9f622d2febc0bfbe5381599f2fba7dcfae3b372d48988ee30f474e86290ffa  FAQ
f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
c4392d9d2f3d3951dc4b4db9323dc9889bfa1ef064bd8a6b3a00f28f510a3469  NEWS
4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
602f3a40ef759c7b2a6c485a33dc674af34249644ac5fb53b21283d4e12e808d  NEWS.1
7babb6d82a4479b2c3803f7dbfaab63125b0f0d1b6bb40b1389d3af65eaf83aa  NEWS.2
eb473efd365822e7ae64eb0f86028ea019815fdd273fe7daa9c6fe5e28fd2737  NEWS.3
b42a7921400386645b10105b91c68728787db5c4c83c9f6c30acdce632e1bb70  R-latest.tar.gz
3c29f587f438588160cc8a82a2b3fcc0abff392f731d930b4eaa7f85fa022a32  R-latest.tar.xz
f5aa875c23185cbfc3a50739d7295b0caba2cf0e38ba082850be338cc9541154  README
fa76f82f7e3664afa4394623afedbc696a2ee90925be65ca57fc9e4b399f3ed6  RESOURCES
1d5064c86b6813865a033763f43212064c0a67ef05f5af13b13c4feb08264a33  THANKS
817ce098a213836d8664201f3eb46fa7969626526c2b31da4297340e0c115524  VERSION-INFO.dcf
b42a7921400386645b10105b91c68728787db5c4c83c9f6c30acdce632e1bb70  R-4/R-4.5.1.tar.gz
3c29f587f438588160cc8a82a2b3fcc0abff392f731d930b4eaa7f85fa022a32  R-4/R-4.5.1.tar.xz

This is the relevant part of the NEWS file

CHANGES IN R 4.5.1:

  NEW FEATURES:

    ? The internal method of unzip() now follows unzip 6.00 in how it
      handles extracted file paths which contain "../".  With thanks to
      Ivan Krylov.

  INSTALLATION:

    ? Standalone nmath can be built with early-2025 versions of
      clang-based compilers such as LLVM clang 20, Apple clang 17 and
      Intel icx 2025.0.

    ? Tcl/Tk 9 can be used to build package tcltk: this has become the
      default in some Linux distributions.  *N.B.* several third-party
      packages currently require Tcl/Tk 8 or even 8.6 without declaring
      so.

  BUG FIXES:

    ? Java detection in javareconf could not detect libjvm.* in the
      zero variant of the JDK (PR#18884).  All valid variants as of JDK
      24u are now supported.

    ? factanal(.., rotation=*) now correctly updates rotmat, fixing
      PR#18886.

    ? dnbinom(<large>, <muchlarger>, ..) now is 0 correctly, instead of
      NaN or Inf sometimes.

    ? dbinom(<large>, n=Inf, ..) is 0 now correctly, instead of NaN
      which also fixes many dnbinom() cases, notably those mentioned in
      PR#16727 comment #5.

    ? Fixing C level ?binomial deviance? bd0() for extreme arguments
      (preventing under-/overflow) solves more PR#16727 cases and also
      prevents some full accuracy loss in such cases for dbinom(),
      dnbinom(), and via dbinom_raw() potentially dgeom(), dhyper(),
      dbeta(), and df().

    ? signif(1.**e308, digits) no longer truncates unnecessarily (but
      still to prevent overflow to Inf), fixing PR#18889.

    ? prettyNum(*, zero.print={>=1-char}, replace.zero=TRUE) now works
      as documented, thanks to Marttila Mikko and Ivan Krylov's
      messages on R-devel.

    ? pbeta(x, a,b, ..) for very large a,b no longer returns NaN but
      the correct values (0 or 1, or their logs for log.p = TRUE).
      This improves Mathlib's C level bratio() and hence also
      pnbinom(), etc..

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


