From j@goreck| @end|ng |rom w|t@edu@p|  Mon Dec  2 06:55:30 2019
From: j@goreck| @end|ng |rom w|t@edu@p| (Jan Gorecki)
Date: Mon, 2 Dec 2019 11:25:30 +0530
Subject: [Rd] data.frame could handle long vectors
Message-ID: <CAOO9MKWTNc5ROB1RsioM0dfdkZb1GcsyoDiW==OQq7dZEvR_Ew@mail.gmail.com>

Dear R-devel,

It seems that data.frame class could be improved to handle long
vectors better. It fails while using `data.frame(.)` and the same
using, I believe, lower overhead, `as.data.frame(list(.)). Please find
reproducible example below, tested on 2019-12-01 r77492.

id1 = sample.int(3e9, replace=TRUE)
v1 = runif(3e9)

df = data.frame(id1=id1, v1=v1)
#Error in if (mirn && nrows[i] > 0L) { :
#  missing value where TRUE/FALSE needed
#In addition: Warning message:
#In attributes(.Data) <- c(attributes(.Data), attrib) :
#  NAs introduced by coercion to integer range

df = as.data.frame(list(id1=id1, v1=v1))
#Error in if (mirn && nrows[i] > 0L) { :
#  missing value where TRUE/FALSE needed
#In addition: Warning message:
#In attributes(.Data) <- c(attributes(.Data), attrib) :
#  NAs introduced by coercion to integer range


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec  2 12:36:56 2019
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 2 Dec 2019 12:36:56 +0100
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
Message-ID: <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>

Dear Laurent,

could you please provide a complete reproducible example where parsing 
results in a crash of R? Calling parse(text="list(''=123") from R works 
fine for me (gives Error: attempt to use zero-length variable name).

I don't think the problem you observed could be related to the memory 
leak. The leak is on the heap, not stack.

Zero-length names of elements in a list are allowed. They are not the 
same thing as zero-length variables in an environment. If you try to 
convert "lst" from your example to an environment, you would get the 
error (attempt to use zero-length variable name).

Best
Tomas


On 11/30/19 11:55 PM, Laurent Gautier wrote:
> Hi again,
>
> Beside R_ParseVector()'s possible inconsistent behavior, R's handling of
> zero-length named elements does not seem consistent either:
>
> ```
>> lst <- list()
>> lst[[""]] <- 1
>> names(lst)
> [1] ""
>> list("" = 1)
> Error: attempt to use zero-length variable name
> ```
>
> Should the parser be made to accept as valid what is otherwise possible
> when using `[[<` ?
>
>
> Best,
>
> Laurent
>
>
>
> Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a ?crit :
>
>> I found the following code comment in `src/main/gram.c`:
>>
>> ```
>>
>> /* Memory leak
>>
>> yyparse(), as generated by bison, allocates extra space for the parser
>> stack using malloc(). Unfortunately this means that there is a memory
>> leak in case of an R error (long-jump). In principle, we could define
>> yyoverflow() to relocate the parser stacks for bison and allocate say on
>> the R heap, but yyoverflow() is undocumented and somewhat complicated
>> (we would have to replicate some macros from the generated parser here).
>> The same problem exists at least in the Rd and LaTeX parsers in tools.
>> */
>>
>> ```
>>
>> Could this be related to be issue ?
>>
>> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com> a
>> ?crit :
>>
>>> Hi,
>>>
>>> The behavior of
>>> ```
>>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>>> ```
>>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
>>> depending on the string to be parsed.
>>>
>>> Trying to parse a string such as `"list(''=1+"` sets the
>>> `ParseStatus` to incomplete parsing error but trying to parse
>>> `"list(''=123"` will result in R sending a message to the console (followed but a crash):
>>>
>>> ```
>>> R[write to console]: Error: attempt to use zero-length variable nameR[write to console]: Fatal error: unable to initialize the JIT*** stack smashing detected ***: <unknown> terminated
>>> ```
>>>
>>> Is there a reason for the difference in behavior, and is there a workaround ?
>>>
>>> Thanks,
>>>
>>>
>>> Laurent
>>>
>>>
> 	[[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Dec  2 15:10:31 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 2 Dec 2019 15:10:31 +0100
Subject: [Rd] 
 Inappropriate class(o)[!inherits(o,"AsIs")] in get_all_vars
In-Reply-To: <2095928073.968101.1575050734883@mail.yahoo.com>
References: <1709347581.898771.1573986871851@mail.yahoo.com>
 <24018.32090.951327.313003@stat.math.ethz.ch>
 <24018.39079.286099.958408@stat.math.ethz.ch>
 <2095928073.968101.1575050734883@mail.yahoo.com>
Message-ID: <24037.6999.144969.273038@stat.math.ethz.ch>

>>>>> suharto anggono--- via R-devel 
>>>>>     on Fri, 29 Nov 2019 18:05:34 +0000 writes:

    > class(o)[!inherits(o,"AsIs")] is still in function
    > 'get_all_vars' in R patched (in
    > https://svn.r-project.org/R/branches/R-3-6-branch/src/library/stats/R/models.R). It
    > was ported to R patched by r77402. 

You are right.... it's no longer now,  thank you very much,
Suharto!

Martin


    > On Monday, 18 November 2019, 8:12:10 PM GMT+7, Martin Maechler
    > <maechler at stat.math.ethz.ch> wrote:
 
    >>>>>> Martin Maechler ? ? on Mon, 18 Nov 2019 12:15:38
    >>>>>> +0100 writes:

>>>>> suharto anggono--- via R-devel 
    >>>>>> ? ? on Sun, 17 Nov 2019 10:34:31 +0000 writes:

    > ? ? >> SVN revision 77401 changes ? ? >> x[isM] <-
    > lapply(x[isM], function(o) `class<-`(o, class(o)[class(o)
    > != "AsIs"])) ? ? >> to ? ? >> x[isM] <- lapply(x[isM],
    > function(o) `class<-`(o, class(o)[!inherits(o,"AsIs")])) ?
    > ? >> in function 'get_all_vars' in
    > src/library/stats/R/models.R in R devel.

    > ? ? >> The change is inappropriate.

    > ? ? >> class(o)[class(o) != "AsIs"] removes "AsIs" from
    > class(o), giving class(o) without "AsIs".

    > ? ? >> On the other hand, inherits(o,"AsIs") is just a
    > single logical value. If "AsIs" is in class(o),
    > inherits(o,"AsIs") is TRUE. In that case, by recycling of
    > logical index, class(o)[!inherits(o,"AsIs")] removes all
    > elements of class(o), giving character(0).

    > ? ? > Thank you, Suharto !

    > ? ? > You are obviously right,? and I'm a bit embarrassed
    > by my ? ? > overzealousness to follow my own
    > recommendations in the? R Blog

    > ? ? > http://bit.ly/R_blog_class_think_2x

    > ? ? > {*wrongly*: The recommendation was to "think again"
    > ...}

    > ? ? > It's a "shame" that the wrong code did not trigger
    > any checks, ? ? > so if anybody has time... I'd be
    > grateful for such a regression ? ? > check.

    > Once I started thinking, it was easy to modify the
    > previous reg.check? to trigger in the case of the erronous
    > r77401.

    > Fixed now in 77435.  Martin
  
    > 	[[alternative HTML version deleted]]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From |uke-t|erney @end|ng |rom u|ow@@edu  Tue Dec  3 17:04:00 2019
From: |uke-t|erney @end|ng |rom u|ow@@edu (Tierney, Luke)
Date: Tue, 3 Dec 2019 16:04:00 +0000
Subject: [Rd] switch to reference counting in R-devel
In-Reply-To: <alpine.OSX.2.21.1911240826360.566@macbook-air-5.local>
References: <alpine.OSX.2.21.1911240826360.566@macbook-air-5.local>
Message-ID: <alpine.DEB.2.21.1912031002260.3579@luke-Latitude-7480>

R-devel has been switched to use reference counting by default with
r77508. Building with -DSWITCH_TO_NAMED goes back to the NAMED
mechanism.

Best,

luke

On Sun, 24 Nov 2019, luke-tierney at uiowa.edu wrote:

> Baring any unforeseen issues R-devel will switch in about a week from
> the NAMED mechanism to reference counting for determining when objects
> can be safely mutated in base C code. This is expected to have minimal
> impact on packages not using unsupported coding practices in their C
> code.
>
>
> The transition to reference counting has been in progress for a
> number of years. Some older notes on this are available at
> http://developer.r-project.org/Refcnt.html.  These may no longer be
> completely accurate but should give you an idea of what is going on.
>
> If you want to test your package under reference counting you can do
> so by building R with -DSWITCH_TO_REFCNT added to CFLAGS or DEFS in a
> config.site file.
>
> A small number of packages are still using the NAMED or SET_NAMED
> functions even though this has been discouraged for some  time.
> For now these will not produce errors but also not do anything useful.
> They will probably be removed before R 4.0.0 is released, so you
> should look at why you are using them and adjust accordingly.
>
> Best,
>
> luke
>
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From henr|k@bengt@@on @end|ng |rom gm@||@com  Tue Dec  3 19:11:15 2019
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Tue, 3 Dec 2019 10:11:15 -0800
Subject: [Rd] switch to reference counting in R-devel
In-Reply-To: <alpine.DEB.2.21.1912031002260.3579@luke-Latitude-7480>
References: <alpine.OSX.2.21.1911240826360.566@macbook-air-5.local>
 <alpine.DEB.2.21.1912031002260.3579@luke-Latitude-7480>
Message-ID: <CAFDcVCRAvE8jQjZv5AY+VSZ=edLu=sMJ3G0cSk5t2qEOOF-kZg@mail.gmail.com>

This is very exciting news.  Luke, thank you for all your work on this
- I know it's been a long journey.

All the best,

Henrik

On Tue, Dec 3, 2019 at 8:04 AM Tierney, Luke <luke-tierney at uiowa.edu> wrote:
>
> R-devel has been switched to use reference counting by default with
> r77508. Building with -DSWITCH_TO_NAMED goes back to the NAMED
> mechanism.
>
> Best,
>
> luke
>
> On Sun, 24 Nov 2019, luke-tierney at uiowa.edu wrote:
>
> > Baring any unforeseen issues R-devel will switch in about a week from
> > the NAMED mechanism to reference counting for determining when objects
> > can be safely mutated in base C code. This is expected to have minimal
> > impact on packages not using unsupported coding practices in their C
> > code.
> >
> >
> > The transition to reference counting has been in progress for a
> > number of years. Some older notes on this are available at
> > http://developer.r-project.org/Refcnt.html.  These may no longer be
> > completely accurate but should give you an idea of what is going on.
> >
> > If you want to test your package under reference counting you can do
> > so by building R with -DSWITCH_TO_REFCNT added to CFLAGS or DEFS in a
> > config.site file.
> >
> > A small number of packages are still using the NAMED or SET_NAMED
> > functions even though this has been discouraged for some  time.
> > For now these will not produce errors but also not do anything useful.
> > They will probably be removed before R 4.0.0 is released, so you
> > should look at why you are using them and adjust accordingly.
> >
> > Best,
> >
> > luke
> >
> >
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Tue Dec  3 19:19:31 2019
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Tue, 3 Dec 2019 13:19:31 -0500
Subject: [Rd] switch to reference counting in R-devel
In-Reply-To: <CAFDcVCRAvE8jQjZv5AY+VSZ=edLu=sMJ3G0cSk5t2qEOOF-kZg@mail.gmail.com>
References: <alpine.OSX.2.21.1911240826360.566@macbook-air-5.local>
 <alpine.DEB.2.21.1912031002260.3579@luke-Latitude-7480>
 <CAFDcVCRAvE8jQjZv5AY+VSZ=edLu=sMJ3G0cSk5t2qEOOF-kZg@mail.gmail.com>
Message-ID: <CAL6gwnKE6-rWJra-9NN6mKVcs4O0wTubhOq6zqEeJ8UEk7Rm3g@mail.gmail.com>

Agreed. Now is as good a time as any to send many,  many thanks are due to
Luke, Martin, Uwe, Duncan, the redoubtable  Professor B. and the entire
R-Core team for their seemingly countless hours of toil keeping R not only
afloat but healthy and vibrant. Your work is deeply appreciated, even if it
isn?t expressed often enough.

Thank you again!

Avi

On Tue, Dec 3, 2019 at 1:11 PM Henrik Bengtsson <henrik.bengtsson at gmail.com>
wrote:

> This is very exciting news.  Luke, thank you for all your work on this
> - I know it's been a long journey.
>
> All the best,
>
> Henrik
>
> On Tue, Dec 3, 2019 at 8:04 AM Tierney, Luke <luke-tierney at uiowa.edu>
> wrote:
> >
> > R-devel has been switched to use reference counting by default with
> > r77508. Building with -DSWITCH_TO_NAMED goes back to the NAMED
> > mechanism.
> >
> > Best,
> >
> > luke
> >
> > On Sun, 24 Nov 2019, luke-tierney at uiowa.edu wrote:
> >
> > > Baring any unforeseen issues R-devel will switch in about a week from
> > > the NAMED mechanism to reference counting for determining when objects
> > > can be safely mutated in base C code. This is expected to have minimal
> > > impact on packages not using unsupported coding practices in their C
> > > code.
> > >
> > >
> > > The transition to reference counting has been in progress for a
> > > number of years. Some older notes on this are available at
> > > http://developer.r-project.org/Refcnt.html.  These may no longer be
> > > completely accurate but should give you an idea of what is going on.
> > >
> > > If you want to test your package under reference counting you can do
> > > so by building R with -DSWITCH_TO_REFCNT added to CFLAGS or DEFS in a
> > > config.site file.
> > >
> > > A small number of packages are still using the NAMED or SET_NAMED
> > > functions even though this has been discouraged for some  time.
> > > For now these will not produce errors but also not do anything useful.
> > > They will probably be removed before R 4.0.0 is released, so you
> > > should look at why you are using them and adjust accordingly.
> > >
> > > Best,
> > >
> > > luke
> > >
> > >
> > >
> >
> > --
> > Luke Tierney
> > Ralph E. Wareham Professor of Mathematical Sciences
> > University of Iowa                  Phone:             319-335-3386
> > Department of Statistics and        Fax:               319-335-3017
> >     Actuarial Science
> > 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> > Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


From ncrook@ton@|@ @end|ng |rom gm@||@com  Tue Dec  3 22:41:56 2019
From: ncrook@ton@|@ @end|ng |rom gm@||@com (Nicholas Crookston)
Date: Tue, 3 Dec 2019 13:41:56 -0800
Subject: [Rd] Dynamic load library problem using R 4.0.0
Message-ID: <CAAk+MXz+XSXaFcogbRPBPPyWzUzM8-Mg=1DfU6WOUXuDrEfK0A@mail.gmail.com>

I'm having problems getting code that runs under 3.6.1 on MacOSX (and
Ubuntu)
to run the R version 4.0.0 on Windows. I have not tested R 4.0.0 on mac
(yet).

Key question: Has anything changed in R 4.0.0/Windows regarding how
dynamically loaded
libraries are accessed?  Can someone please point me in the right direction?

WORKS On MacOSX Under:
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
after dynamically loading ../../bin/qFVSie.so:

> getLoadedDLLs()$qFVSie
DLL name: qFVSie
Filename:

/Users/ncrookston/open-fvs/branches/NickDev/tests/APIviaR/../../bin/qFVSie.so
Dynamic lookup: TRUE

# expected output is correct:
> i=1
> .C("CfvsSpeciesCode",fvs_code="",fia_code="",plant_code="",
indx=as.integer(i))
$fvs_code
[1] "WP"
$fia_code
[1] "119"
$plant_code
[1] "PIMO3"
$indx
[1] 1

----- from the nm command:
$ nm ../../bin/qFVSie.so | grep -i cfvsspeciescode
00000000000a7980 T _CfvsSpeciesCode

------------------------------------

Fails On Win10 Under:
R version 4.0.0 Under development (Rtools 4.0) (2019-11-23 r77455) --
"Blame Jeroen"
NOTE: The .dll is built using the most recent Rtools as advised by Jeroen.

> getLoadedDLLs()$qFVSie
DLL name: qFVSie
Filename:

C:/Users/nickc/open-fvs/branches/NickDev/tests/APIviaR/../../bin/qFVSie.dll
Dynamic lookup: TRUE

> i=1
> .C("CfvsSpeciesCode",fvs_code="",fia_code="",plant_code="",
indx=as.integer(i))
Error in .C("CfvsSpeciesCode", fvs_code = "", fia_code = "", plant_code =
"",  :
  C symbol name "CfvsSpeciesCode" not in load table

----- from the nm command on Win10:
nm ../../bin/qFVSie.dll | grep -i cfvsspeciescode
00000000707a21f0 T CfvsSpeciesCode

-----------------------------------

If advised to do so, I'll create a simple and fully reproducible example,
but perhaps
I missing something simple (like compiler switch needed to create my .dll
that has not
been necessary until now).

Thanks, Nick

-- 
Nicholas L. Crookston
Forestry Research Consultant
Moscow Idaho USA

	[[alternative HTML version deleted]]


From peter@ruckde@che| @end|ng |rom web@de  Wed Dec  4 11:30:19 2019
From: peter@ruckde@che| @end|ng |rom web@de (Peter Ruckdeschel)
Date: Wed, 4 Dec 2019 11:30:19 +0100
Subject: [Rd] Assumption of Gaussian innovations in function stats::arima
Message-ID: <54c52f7e-8ea5-643b-93d2-8f2bdb429cf9@web.de>

Hi, if I read the help to function stats::arima carefully enough, I have not found any mentioning of the assumption that
the innovations e[t] (notation from the help file) be Gaussian. I think this assumption should be included. In
particular, the returned information on the log likelihood would be wrong otherwise.

Best regards, Peter Ruckdeschel


From r-deve| @end|ng |rom @ker@t|ng@de  Wed Dec  4 12:58:40 2019
From: r-deve| @end|ng |rom @ker@t|ng@de (Andreas Kersting)
Date: Wed, 04 Dec 2019 12:58:40 +0100 (CET)
Subject: [Rd] error in parallel:::sendMaster
Message-ID: <E1icTIm-0004VX-EO@rmmprod05.runbox>

Hi all,

With the help of Tomas, I was able to track the issue down: Prior to R v3.6.0 the parallel package passes an uninitialized variable as the file descriptor argument to the close system call. 

In my particular R session this uninitialized variable (reproducibly) was holding the value 7, which corresponded to the file descriptor of the write end of the pipe the second child would use to send its results to the master. Hence, the child unintentionally closed this pipe directly after fork in close_fds_child_ci() resulting in sendMaster() later failing with EBADF.

It was fixed with this commit: https://github.com/wch/r-source/commit/e08cffac1c5b9015a1625938d568b648eb1d8aee

Regards,
Andreas

2019-11-28 13:54 GMT+01:00 Andreas Kersting<r-devel at akersting.de>:
> Hi Tomas,
> 
> I rebuild R (v3.5.2 for now, R-devel to follow) from the Debian package with MC_DEBUG defined and hopefully also with "-Wall -O0 -gdwarf-2 -g3", though I still have to verify this.
> 
> Below is the output. I think it is a total of two mclapply invocations in this R session, the failing one starting around the lines "[1] 15381" and "[1] 15382". The "Error in partDF::write_partDF ..." is because the script/package checks the return value of mclapply and detects that it is not a list of length 85 with only the elements "TRUE".
> 
> Regarding sending you the complete example: I first have to figure out if this is possible at all, because it would involve data of a client.
> 
> Regards,
> Andreas
> 
> parent[15366] created pipes: comm (6->5), sir (8->7)
> parent registers new child 15379
> child process 15379 started
> parent[15366] created pipes: comm (7->6), sir (10->9)
> parent registers new child 15380
> child process 15380 started
> select_children: added child 15380 (6)
> select_children: added child 15379 (5)
> select_children: maxfd=6, wlen=2, wcount=2, timeout=-1.000000
> child 15380: send_master (550 bytes)
>   sr = 1
>  - read select 1 children: 15380 
> child 15380: 'mcexit' called
> child 15380 is waiting for permission to exit
> read_child_ci(15380) - read length returned 8
> read_child_ci(15380) - read 550 at 0 returned 550
> select_children: added child 15380 (6)
> select_children: added child 15379 (5)
> select_children: maxfd=6, wlen=2, wcount=2, timeout=-1.000000
>   sr = 1
>  - read select 1 children: 15380 
> read_child_ci(15380) - read length returned 8
> detached child 15380 (signal 10)
> child process 15380 got SIGUSR1; child_exit_status=-1
> child 15380: exiting
> select_children: added child 15379 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
> child 15380 terminated with exit status 0
> child 15379: send_master (550 bytes)
>   sr = 1
>  - read select 1 children: 15379 
> read_child_ci(15379) - read length returned 8
> read_child_ci(15379) - read 550 at 0 returned 550
> select_children: added child 15379 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
> child 15379: 'mcexit' called
> child 15379 is waiting for permission to exit
>   sr = 1
>  - read select 1 children: 15379 
> read_child_ci(15379) - read length returned 8
> detached child 15379 (signal 10)
> child process 15379 got SIGUSR1; child_exit_status=-1
> child 15379: exiting
> removing waited-for child 15380 from the list
> killed detached child 15379 (signal 15)
> removing waited-for child 2147483647 from the list
> child 15379 terminated with exit status 0
> removing waited-for child 15379 from the list
> parent[15366] created pipes: comm (6->5), sir (8->7)
> parent registers new child 15381
> child process 15381 started
> parent[15366] created pipes: comm (7->6), sir (10->9)
> [1] 15381
> parent registers new child 15382
> child process 15382 started
> select_children: added child 15382 (6)
> select_children: added child 15381 (5)
> select_children: maxfd=6, wlen=2, wcount=2, timeout=-1.000000
>   sr = 1
>  - read select 1 children: 15382 
> read_child_ci(15382) - read length returned 0
> detached child 15382 (signal 10)
> child process 15382 got SIGUSR1; child_exit_status=-1
> select_children: added child 15381 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
> [1] 15382
> child 15382: send_master (526 bytes)
> Error in sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE)) : 
>   write error, closing pipe to the master
> Calls: lapply ... <Anonymous> -> <Anonymous> -> lapply -> FUN -> sendMaster
> child 15382: 'mcexit' called
> child 15382: exiting
> child 15382 terminated with exit status 1
> child 15381: send_master (538 bytes)
>   sr = 1
>  - read select 1 children: 15381 
> read_child_ci(15381) - read length returned 8
> read_child_ci(15381) - read 538 at 0 returned 538
> child 15381: 'mcexit' called
> child 15381 is waiting for permission to exit
> select_children: added child 15381 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
>   sr = 1
>  - read select 1 children: 15381 
> read_child_ci(15381) - read length returned 8
> detached child 15381 (signal 10)
> child process 15381 got SIGUSR1; child_exit_status=-1
> child 15381: exiting
> removing waited-for child 15382 from the list
> killed detached child 15381 (signal 15)
> removing waited-for child 2147483647 from the list
> Error in partDF::write_partDF(X, out_path, c("Date", "Panel", "Type",  : 
>   at least one core did not return from parllel write; maybe it was killed (be the Linux Out of Memory Killer ?) or there was a fatal error in the forked process(es)
> Calls: lapply -> FUN -> write_partDF_repo -> <Anonymous>
> Execution halted
> killed detached child 15381 (signal 9)
> child 15381 terminated with exit status 0
> removing waited-for child 15381 from the list
> process 15366 parallel shutdown ok
> 
> 
> 2019-11-28 10:40 GMT+01:00 Tomas Kalibera<tomas.kalibera at gmail.com>:
>> Hi Andreas,
>> thank you very much, good job finding it was EBADF. Now the question is=20
>> why the pipe has been closed prematurely; it could be accidentally by R=20
>> (a race condition in the cleanup code in fork.c) or possibly by some=20
>> other code running in the same process (maybe the R program itself or=20
>> some other code it runs). Maybe we can take this off the list and come=20
>> back when we know the cause or have it fixed.
>> 
>> It would help a lot if you could try with R built from source, with=20
>> optimizations disabled to get more accurate debug symbols (e.g. env=20
>> CFLAGS=3D"-Wall -O0 -gdwarf-2 -g3" CXXFLAGS=3D"-Wall -O0 -gdwarf-2 -g3"=20
>> =2E/configure), and with MC_DEBUG defined in fork.c - line 26. Ideally in=
>> =20
>> R-devel, so that we are sure the problem still exists. The debug=20
>> messages should give a hint whether it was R (fork.c) that closed the=20
>> pipe and why. Maybe you could also add a debug message to=20
>> close_fds_child_ci() to see if it was closed there. Maybe you could find =
>> 
>> this out even in your current debugging setup via breakpoints and=20
>> backtraces, but I think it may be easier to build from source with these =
>> 
>> debugging messages.
>> 
>> Also if you could send me a complete example I could run that causes=20
>> this on your system, that would be nice (even if it didn't cause the=20
>> problem on my system).
>> 
>> Thanks
>> Tomas
>> 
>> On 11/28/19 6:35 AM, Andreas Kersting wrote:
>>> Hi Tomas,
>>>
>>> Thanks for your prompt reply and your offer to help. I might need to ge=
>> t back to this since I am not too experienced in debugging these kinds of=
>> issues. Anyway, I gave it a try and I think I have found the immediate c=
>> ause:
>>>
>>> I installed the debug symbols (r-base-core-dbg), placed https://github.=
>> com/wch/r-source/blob/tags/R-3-5-2/src/library/parallel/src/fork.c in cwd=
>> and changed the wrapper code to:
>>>
>>> mc_ret <- parallel::mclapply(seq_len(nrow(parts)), function(i) {
>>>      # we fail for the input resulting in parts having 85 rows
>>>      if (nrow(parts) =3D=3D 85L && !file.exists(as.character(Sys.getpid=
>> ()))) {
>>>        file.create(as.character(Sys.getpid()))
>>>        print(Sys.getpid())
>>>        Sys.sleep(30)
>>>      }
>>>
>>>      # ...
>>>
>>>      return(TRUE)
>>>    }, mc.preschedule =3D TRUE, mc.cores =3D 2L)
>>>
>>> This way I ended up with only two child processes to which I each attac=
>> hed a debugger. In total I ran about 10 debugging sessions and it was alw=
>> ays the second child process failing. The errno after write returned -1 w=
>> as 9 (EBADF).
>>>
>>>  From what I can see, the reason for this is that the second child trie=
>> s to write to fd 7, but already during the very beginning of the first in=
>> vocation of the anonymous function to parallelize, i.e. during Sys.sleep(=
>> 30), there is no such file descriptor. From this observation I would conc=
>> lude that it is NOT the code run from that function, i.e. # ...,  causing=
>> the issue. Let me point out again, that this is NOT the very first invoc=
>> ation of mclapply in this R session. There is at least one previous call =
>> to it, which works fine.
>>>
>>>
>>> File descriptors directly after attaching gdb to both child processes d=
>> uring Sys.sleep(30):
>>>
>>> ### master
>>> root at ip-10-0-48-30:~/latest_test# ls -l /proc/22119/fd
>>> total 0
>>> lrwx------ 1 root root 64 Nov 28 04:49 0 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:49 1 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:49 2 -> /dev/pts/0
>>> lr-x------ 1 root root 64 Nov 28 04:49 3 -> /path/to/script.R
>>> lrwx------ 1 root root 64 Nov 28 04:49 4 -> /path/on/nfs/write.lock
>>> lr-x------ 1 root root 64 Nov 28 04:49 5 -> 'pipe:[266120]'
>>> l-wx------ 1 root root 64 Nov 28 04:49 8 -> 'pipe:[266121]'
>>>
>>>
>>> ### first child (writes to fd 6)
>>> (gdb) shell ls -l /proc/22134/fd
>>> total 0
>>> lrwx------ 1 root root 64 Nov 28 04:42 0 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:42 1 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:42 2 -> /dev/pts/0
>>> lr-x------ 1 root root 64 Nov 28 04:42 3 -> /path/to/script.R
>>> lrwx------ 1 root root 64 Nov 28 04:42 4 -> /path/on/nfs/write.lock
>>> l-wx------ 1 root root 64 Nov 28 04:42 6 -> 'pipe:[266120]'
>>> l-wx------ 1 root root 64 Nov 28 04:42 8 -> 'pipe:[266121]'
>>>
>>> ### second child (tries writing to fd 7)
>>> (gdb) shell ls -l /proc/22135/fd
>>> total 0
>>> lr-x------ 1 root root 64 Nov 28 04:42 0 -> 'pipe:[266123]'
>>> lrwx------ 1 root root 64 Nov 28 04:42 1 -> /dev/pts/0
>>> l-wx------ 1 root root 64 Nov 28 04:42 10 -> 'pipe:[266123]'
>>> lrwx------ 1 root root 64 Nov 28 04:42 2 -> /dev/pts/0
>>> lr-x------ 1 root root 64 Nov 28 04:42 3 -> /path/to/script.R
>>> lrwx------ 1 root root 64 Nov 28 04:42 4 -> /path/on/nfs/write.lock
>>>
>>>
>>> # debugging mc_send_master in both child processes:
>>>
>>> ### first child (all OK):
>>> (gdb) break mc_send_master
>>> Breakpoint 1 at 0x7f5b2687b0a0: file fork.c, line 681.
>>> (gdb) c
>>> Continuing.
>>>
>>> Breakpoint 1, mc_send_master (what=3D0x555c6dd2cd00) at fork.c:681
>>> warning: Source file is more recent than executable.
>>> 681	{
>>> (gdb) info args
>>> what =3D 0x555c6dd2cd00
>>> (gdb) n
>>> 682	    if (is_master)
>>> (gdb) n
>>> 684	    if (master_fd =3D=3D -1)
>>> (gdb) n
>>> 686	    if (TYPEOF(what) !=3D RAWSXP)
>>> (gdb) n
>>> 688	    R_xlen_t len =3D XLENGTH(what);
>>> (gdb) n
>>> 689	    unsigned char *b =3D RAW(what);
>>> (gdb) n
>>> 693	    if (writerep(master_fd, &len, sizeof(len)) !=3D sizeof(len)) {
>>> (gdb) info locals
>>> len =3D 538
>>> b =3D <optimized out>
>>> n =3D <optimized out>
>>> (gdb) s
>>> writerep (fildes=3D6, buf=3Dbuf at entry=3D0x7ffdd6da7db0, nbyte=3Dnbyte at e=
>> ntry=3D8)
>>>      at fork.c:653
>>> 653	{
>>> (gdb) info args
>>> fildes =3D 6
>>> buf =3D 0x7ffdd6da7db0
>>> nbyte =3D 8
>>> (gdb) n
>>> 654	    size_t wbyte =3D 0;
>>> (gdb) n
>>> 653	{
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) n
>>> 664		if (w =3D=3D 0) {
>>> (gdb) n
>>> 670		wbyte +=3D w;
>>> (gdb) n
>>> 671		if (wbyte =3D=3D nbyte)
>>> (gdb) n
>>> 672		    return wbyte;
>>> (gdb) n
>>> 674	}
>>> (gdb) n
>>> mc_send_master (what=3D<optimized out>) at fork.c:699
>>> 699	    for (R_xlen_t i =3D 0; i < len; i +=3D n) {
>>> (gdb) n
>>> 700		n =3D writerep(master_fd, b + i, len - i);
>>> (gdb) n
>>> 701		if (n < 1) {
>>> (gdb) n
>>> 699	    for (R_xlen_t i =3D 0; i < len; i +=3D n) {
>>> (gdb) n
>>> 707	    return ScalarLogical(1);
>>> (gdb) n
>>> 708	}
>>>
>>>
>>>
>>> ### second child (write fails with EBADF):
>>> (gdb) break mc_send_master
>>> Breakpoint 1 at 0x7f5016f3e0a0: file fork.c, line 681.
>>> (gdb) c
>>> Continuing.
>>>
>>> Breakpoint 1, mc_send_master (what=3D0x563382a71910) at fork.c:681
>>> warning: Source file is more recent than executable.
>>> 681	{
>>> (gdb) info args
>>> what =3D 0x563382a71910
>>> (gdb) n
>>> 682	    if (is_master)
>>> (gdb) n
>>> 684	    if (master_fd =3D=3D -1)
>>> (gdb) n
>>> 686	    if (TYPEOF(what) !=3D RAWSXP)
>>> (gdb) n
>>> 688	    R_xlen_t len =3D XLENGTH(what);
>>> (gdb) n
>>> 689	    unsigned char *b =3D RAW(what);
>>> (gdb) n
>>> 693	    if (writerep(master_fd, &len, sizeof(len)) !=3D sizeof(len)) {
>>> (gdb) info locals
>>> len =3D 526
>>> b =3D <optimized out>
>>> n =3D <optimized out>
>>> (gdb) s
>>> writerep (fildes=3D7, buf=3Dbuf at entry=3D0x7fff4027ad60, nbyte=3Dnbyte at e=
>> ntry=3D8)
>>>      at fork.c:653
>>> 653	{
>>> (gdb) info args
>>> fildes =3D 7
>>> buf =3D 0x7fff4027ad60
>>> nbyte =3D 8
>>> (gdb) n
>>> 654	    size_t wbyte =3D 0;
>>> (gdb) n
>>> 653	{
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) info locals
>>> w =3D <optimized out>
>>> wbyte =3D 0
>>> ptr =3D 0x7fff4027ad60 "\016\002"
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) n
>>> 659		    if (errno =3D=3D EINTR)
>>> (gdb) n
>>> 674	}
>>> (gdb) p __errno_location()
>>> $1 =3D (int *) 0x7f50322cb540
>>> (gdb) x/x $1
>>> 0x7f50322cb540:	0x00000009
>>> (gdb) python import errno
>>> (gdb) python print(errno.errorcode[9])
>>> EBADF
>>> (gdb) n
>>> mc_send_master (what=3D<optimized out>) at fork.c:702
>>> 702		    close(master_fd);
>>> (gdb) n
>>> 704		    error(_("write error, closing pipe to the master"));
>>> (gdb) n
>>> 703		    master_fd =3D -1;
>>> (gdb) n
>>> 704		    error(_("write error, closing pipe to the master"));
>>> (gdb) n
>>> 685		error(_("there is no pipe to the master process"));
>>>
>>>
>>> Does this help in any way?
>>>
>>> Is there something else I can/should look at?
>>>
>>> Regards,
>>> Andreas
>>>
>>>
>>> 2019-11-27 15:04 GMT+01:00 Tomas Kalibera<tomas.kalibera at gmail.com>:
>>>> Hi Andreas,
>>>> the error is reported when some child process cannot send results to t=
>> he master process, which originates from an error returned by write() - w=
>> hen write() returns -1 or 0. The logic around the writing has not changed=
>> since R 3.5.2. It should not be related to the printing in the child, on=
>> ly to returning the value. The problem may be originating from the execut=
>> ion environment, virtualization, and/or possibly from a lack of robustnes=
>> s in R. To resolve this we need to find out which error was returned and =
>> why. Either you can try to create a reproducible example (something I cou=
>> ld use to trigger an error on my system and then debug) or to debug on yo=
>> ur system (build R from source, ensure the bug is still triggered, then i=
>> nstrument to print the exact error from the OS and where it was detected,=
>> etc). In principle you could also try without code instrumentation just =
>> using strace. Just from looking at the code in R around the writing I am =
>> not seeing any bug there. If you choose to debug on your system I can hel=
>> p with the instrumentation.
>>>>
>>>> Best
>>>> Tomas
>>>>
>>>> On 11/27/19 12:40 PM, Andreas Kersting wrote:
>>>>> Hi again,
>>>>>
>>>>> One important correction of my first message: I misinterpreted the ou=
>> tput. Actually in that R session 2 input files were processed one after t=
>> he other in a loop. The first (with 88 parts went fine). The second (with=
>> 85 parts) produced the sendMaster errors and failed. If (in a new sessio=
>> n via Rscript) I only process the second input file it will work. The oth=
>> er observations on R vs Rscript, NFS share etc. still hold.
>>>>>
>>>>> Sorry for this! Regards,
>>>>> Andreas
>>>>>
>>>>> 2019-11-27 12:10 GMT+01:00 Andreas Kersting<r-devel at akersting.de>:
>>>>>> Hi,
>>>>>>
>>>>>> I am facing a very weird problem with parallel::mclapply. I have a s=
>> cript which does some data wrangling on an input dataset in parallel and =
>> then writes the results to disk. I have been using this script daily for =
>> more than one year always on an EC2 instance launched from the same AMI (=
>> no updates installed after launch) and processed thousands of different i=
>> nput data sets successfully. I now have an input dataset for which I face=
>> the following bug:
>>>>>>
>>>>>> The basic outline of the problematic section of the script:
>>>>>>
>>>>>> # parts is a data.table with 88 rows
>>>>>> mc_ret <- parallel::mclapply(sample.int(nrow(parts)), function(i) {
>>>>>>     # do some data wrangling and write the result to a file
>>>>>>     # ...
>>>>>>
>>>>>>     print(paste0("part ", i, " written successfully."))
>>>>>>     return(TRUE)
>>>>>> }, mc.preschedule =3D FALSE, mc.cores =3D 2L)
>>>>>>
>>>>>> str(mc_ret)
>>>>>>
>>>>>>
>>>>>> Expected output: "part i written successfully." is printed 88 times,=
>> once for each value of i. mc_ret is a list of length 88, each element be=
>> ing TRUE. Its structure is printed once. All outputs are created successf=
>> ully.
>>>>>>
>>>>>> Actual output (see end of the message): "part i written successfully=
>> =2E" is printed 88 times, once for each value of i. mc_ret is a list of l=
>> ength 88, each element being TRUE. Its structure is printed. All outputs =
>> are created successfully. So far so good.
>>>>>>
>>>>>> But then "part i written successfully." it is printed another X time=
>> s, for values of i for which it was already printed. This output is inter=
>> mingled with X-1 times the following error message:
>>>>>>
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>>
>>>>>> and Y times the message "Execution halted". mc_ret is printed again,=
>> now being a list of length 85, with the first element being TRUE and all=
>> other elements being NULL. X and Y vary from run to run.
>>>>>>
>>>>>>
>>>>>> Now to the main problem: I tried very hard to create a reproducible =
>> example, but I failed. What I observed:
>>>>>> - The output is (and has always been) written to path which is on an=
>> NFS share. If I instead write to a path on a local disk it will work.
>>>>>> - The script is invoked using Rscript. If I instead source it from a=
>> n interactive R session it works. There are at least two more people who =
>> have observed this: https://stackoverflow.com/questions/51986674/mclapply=
>> -sendmaster-error-only-with-rscript
>>>>>> - Before the call to mclapply the code acquires an exclusive file lo=
>> ck on a dedicated lock file, not written to but also on the NFS share. If=
>> I remove the code acquiring the lock, the whole script will also work if=
>> called using Rscript.
>>>>>> - The problem also occurs for mc.preschedule =3D TRUE.
>>>>>> - There is no error if I set mc.cores to 1.
>>>>>> - And stressing again: the code works without any changes from Rscri=
>> pt for thousands of other data sets.
>>>>>>
>>>>>>
>>>>>> Rscript -e "sessionInfo()":
>>>>>> R version 3.5.2 (2018-12-20)
>>>>>> Platform: x86_64-pc-linux-gnu (64-bit)
>>>>>> Running under: Ubuntu 18.04.2 LTS
>>>>>>
>>>>>> Matrix products: default
>>>>>> BLAS: /usr/lib/x86_64-linux-gnu/openblas/libblas.so.3
>>>>>> LAPACK: /usr/lib/x86_64-linux-gnu/libopenblasp-r0.2.20.so
>>>>>>
>>>>>> locale:
>>>>>>    [1] LC_CTYPE=3DC.UTF-8       LC_NUMERIC=3DC           LC_TIME=3DC=
>> =2EUTF-8
>>>>>>    [4] LC_COLLATE=3DC.UTF-8     LC_MONETARY=3DC.UTF-8    LC_MESSAGES=
>> =3DC.UTF-8
>>>>>>    [7] LC_PAPER=3DC.UTF-8       LC_NAME=3DC              LC_ADDRESS=3D=
>> C
>>>>>> [10] LC_TELEPHONE=3DC         LC_MEASUREMENT=3DC.UTF-8 LC_IDENTIFICA=
>> TION=3DC
>>>>>>
>>>>>> attached base packages:
>>>>>> [1] stats     graphics  grDevices utils     datasets  methods   base=
>> 
>>>>>>
>>>>>> loaded via a namespace (and not attached):
>>>>>> [1] compiler_3.5.2
>>>>>>
>>>>>>
>>>>>> I know this is a fairly old R version. I have not been able to repro=
>> duce the bug with a more recent version, but since it is so difficult to =
>> trigger, this does not mean much, I guess. I have looked through the chan=
>> ges made to the code of mclapply since that version and could not find so=
>> mething directly related. I am not even sure if it is a problem in the pa=
>> rallel package or some other (memory) bug. What strikes me is that others=
>> have observed a very similar error when using Rscript but not when using=
>> an interactive R session, just like I do.
>>>>>>
>>>>>> I am not expecting a fix based on the information I provide, but may=
>> be someone has some thoughts on this!?
>>>>>>
>>>>>> Regards,
>>>>>> Andreas
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> Actual output:
>>>>>>
>>>>>> [1] "part 51 written successfully."
>>>>>> [1] "part 30 written successfully."
>>>>>> [1] "part 32 written successfully."
>>>>>> [1] "part 48 written successfully."
>>>>>> [1] "part 63 written successfully."
>>>>>> [1] "part 5 written successfully."
>>>>>> [1][1] "part 14 written successfully." "part 18 written successfully=
>> =2E"
>>>>>>
>>>>>> [1] "part 38 written successfully."
>>>>>> [1] "part 11 written successfully."
>>>>>> [1] "part 68 written successfully."
>>>>>> [1] "part 45 written successfully."
>>>>>> [1] "part 88 written successfully."
>>>>>> [1] "part 36 written successfully."
>>>>>> [1] "part 44 written successfully."
>>>>>> [1] "part 55 written successfully."
>>>>>> [1] "part 26 written successfully."
>>>>>> [1] "part 37 written successfully."
>>>>>> [1] "part 22 written successfully."
>>>>>> [1] "part 13 written successfully."
>>>>>> [1] "part 67 written successfully."
>>>>>> [1] "part 10 written successfully."
>>>>>> [1] "part 24 written successfully."
>>>>>> [1] "part 20 written successfully."
>>>>>> [1] "part 74 written successfully."
>>>>>> [1] "part 50 written successfully."
>>>>>> [1] "part 2 written successfully."
>>>>>> [1] "part 17 written successfully."
>>>>>> [1] "part 66 written successfully."
>>>>>> [1] "part 61 written successfully."
>>>>>> [1][1] "part 7 written successfully." "part 31 written successfully.=
>> "
>>>>>>
>>>>>> [1] "part 70 written successfully."
>>>>>> [1] "part 71 written successfully."
>>>>>> [1][1] "part 76 written successfully."
>>>>>>    "part 42 written successfully."
>>>>>> [1][1] "part 72 written successfully." "part 12 written successfully=
>> =2E"
>>>>>>
>>>>>> [1] "part 39 written successfully."
>>>>>> [1] "part 58 written successfully."
>>>>>> [1] "part 87 written successfully."
>>>>>> [1] "part 81 written successfully."
>>>>>> [1] "part 3 written successfully."
>>>>>> [1] "part 29 written successfully."
>>>>>> [1] "part 82 written successfully."
>>>>>> [1] "part 54 written successfully."
>>>>>> [1] "part 23 written successfully."
>>>>>> [1] "part 56 written successfully."
>>>>>> [1] "part 73 written successfully."
>>>>>> [1] "part 27 written successfully."
>>>>>> [1] "part 64 written successfully."
>>>>>> [1] "part 46 written successfully."
>>>>>> [1] "part 80 written successfully."
>>>>>> [1] "part 53 written successfully."
>>>>>> [1] "part 43 written successfully."
>>>>>> [1] "part 47 written successfully."
>>>>>> [1] "part 57 written successfully."
>>>>>> [1] "part 75 written successfully."
>>>>>> [1] "part 84 written successfully."
>>>>>> [1] "part 85 written successfully."
>>>>>> [1][1] "part 86 written successfully."
>>>>>>    "part 19 written successfully."
>>>>>> [1][1] "part 33 written successfully." "part 34 written successfully=
>> =2E"
>>>>>>
>>>>>> [1] "part 21 written successfully."
>>>>>> [1] "part 40 written successfully."
>>>>>> [1][1] "part 4 written successfully."
>>>>>>    "part 28 written successfully."
>>>>>> [1] "part 62 written successfully."
>>>>>> [1] "part 16 written successfully."
>>>>>> [1] "part 79 written successfully."
>>>>>> [1] "part 6 written successfully."
>>>>>> [1] "part 77 written successfully."
>>>>>> [1] "part 65 written successfully."
>>>>>> [1] "part 60 written successfully."
>>>>>> [1] "part 78 written successfully."
>>>>>> [1] "part 1 written successfully."
>>>>>> [1] "part 83 written successfully."
>>>>>> [1] "part 9 written successfully."
>>>>>> [1] "part 15 written successfully."
>>>>>> [1][1] "part 41 written successfully."
>>>>>>    "part 35 written successfully."
>>>>>> [1][1] "part 8 written successfully." "part 69 written successfully.=
>> "
>>>>>>
>>>>>> [1] "part 59 written successfully."
>>>>>> [1] "part 25 written successfully."
>>>>>> [1] "part 49 written successfully."
>>>>>> [1] "part 52 written successfully."
>>>>>> List of 88
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>> [1] "part 31 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> lapply -> FUN -> mcparallel -> send=
>> Master
>>>>>> [1] "part 71 written successfully."
>>>>>> [1] "part 35 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 42 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 4 written successfully."
>>>>>> Execution halted
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1][1] "part 30 written successfully." "part 40 written successfully=
>> =2E"
>>>>>>
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 41 written successfully."
>>>>>> [1] "part 80 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 45 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 82 written successfully."
>>>>>> [1] "part 54 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 59 written successfully."
>>>>>> Execution halted
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 27 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 36 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 44 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 83 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 61 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 70 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 66 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 10 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 53 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 55 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 15 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 50 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 5 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 48 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 32 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 69 written successfully."
>>>>>> Execution halted
>>>>>> [1] "part 52 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 77 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 24 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 56 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 6 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 62 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 33 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 16 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 34 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 74 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 2 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 19 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 9 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 11 written successfully."
>>>>>> [1] "part 28 written successfully."
>>>>>> [1] "part 29 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 17 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 65 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 68 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 43 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 38 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 1 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 57 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 8 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 25 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1]List of 85
>>>>>>    $ : logi TRUE
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>> 
>> 
>> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
>

From We|g@nd@Stephen @end|ng |rom m@yo@edu  Wed Dec  4 20:12:52 2019
From: We|g@nd@Stephen @end|ng |rom m@yo@edu (Weigand, Stephen D.)
Date: Wed, 04 Dec 2019 19:12:52 +0000
Subject: [Rd] foreign:::writeForeignSAS patch not released?
In-Reply-To: <9ecfbe$bqh68u@ironport10.mayo.edu>
References: <9ecfbe$bqh68u@ironport10.mayo.edu>
Message-ID: <28fddd$cs94qb@ironport10.mayo.edu>

Hi,
Thank you to R-core since this issue is solved. 

Both CRAN and R-devel_2019-12-03_r77513.tar.gz 
have version 0.8-72 of the foreign package which includes
the improvements to foreign:::writeForeignSAS.

Thank you again,
Stephen

-----Original Message-----
Sent: Tuesday, June 04, 2019 8:27 AM
Hello,

In May 2018 there was some R-devel discussion about a bug in 
foreign:::writeForeignSAS. See here:

  https://stat.ethz.ch/pipermail/r-devel/2018-May/076220.html

and it resulted in a patch. See:

  https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17256

And I see the changes in Subversion here:

  https://svn.r-project.org/R-packages/trunk/foreign/R/writeForeignSAS.R

But I don't think the patched version is being released with R or on CRAN.  
Subversion shows version 0.8-72 of the 'foreign' package but CRAN and 
'R-3.6.0.tar.gz' both have version 0.8-71.

Sincerely,
Stephen

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From @ndre@@ @end|ng |rom @ker@t|ng@de  Wed Dec  4 12:52:42 2019
From: @ndre@@ @end|ng |rom @ker@t|ng@de (Andreas Kersting)
Date: Wed, 04 Dec 2019 12:52:42 +0100 (CET)
Subject: [Rd] error in parallel:::sendMaster
Message-ID: <E1icTD1-00045r-19@rmmprod05.runbox>

Hi all,

With the help of Tomas, I was able to track the issue down: Prior to R v3.6.0 the parallel package passes an uninitialized variable as the file descriptor argument to the close system call. 

In my particular R session this uninitialized variable (reproducibly) was holding the value 7, which corresponded to the file descriptor of the write end of the pipe the second child would use to send its results to the master. Hence, the child unintentionally closed this pipe directly after fork in close_fds_child_ci() resulting in sendMaster() later failing with EBADF.

It was fixed with this commit: https://github.com/wch/r-source/commit/e08cffac1c5b9015a1625938d568b648eb1d8aee

Regards,
Andreas

2019-11-28 13:54 GMT+01:00 Andreas Kersting<r-devel at akersting.de>:
> Hi Tomas,
> 
> I rebuild R (v3.5.2 for now, R-devel to follow) from the Debian package with MC_DEBUG defined and hopefully also with "-Wall -O0 -gdwarf-2 -g3", though I still have to verify this.
> 
> Below is the output. I think it is a total of two mclapply invocations in this R session, the failing one starting around the lines "[1] 15381" and "[1] 15382". The "Error in partDF::write_partDF ..." is because the script/package checks the return value of mclapply and detects that it is not a list of length 85 with only the elements "TRUE".
> 
> Regarding sending you the complete example: I first have to figure out if this is possible at all, because it would involve data of a client.
> 
> Regards,
> Andreas
> 
> parent[15366] created pipes: comm (6->5), sir (8->7)
> parent registers new child 15379
> child process 15379 started
> parent[15366] created pipes: comm (7->6), sir (10->9)
> parent registers new child 15380
> child process 15380 started
> select_children: added child 15380 (6)
> select_children: added child 15379 (5)
> select_children: maxfd=6, wlen=2, wcount=2, timeout=-1.000000
> child 15380: send_master (550 bytes)
>   sr = 1
>  - read select 1 children: 15380 
> child 15380: 'mcexit' called
> child 15380 is waiting for permission to exit
> read_child_ci(15380) - read length returned 8
> read_child_ci(15380) - read 550 at 0 returned 550
> select_children: added child 15380 (6)
> select_children: added child 15379 (5)
> select_children: maxfd=6, wlen=2, wcount=2, timeout=-1.000000
>   sr = 1
>  - read select 1 children: 15380 
> read_child_ci(15380) - read length returned 8
> detached child 15380 (signal 10)
> child process 15380 got SIGUSR1; child_exit_status=-1
> child 15380: exiting
> select_children: added child 15379 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
> child 15380 terminated with exit status 0
> child 15379: send_master (550 bytes)
>   sr = 1
>  - read select 1 children: 15379 
> read_child_ci(15379) - read length returned 8
> read_child_ci(15379) - read 550 at 0 returned 550
> select_children: added child 15379 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
> child 15379: 'mcexit' called
> child 15379 is waiting for permission to exit
>   sr = 1
>  - read select 1 children: 15379 
> read_child_ci(15379) - read length returned 8
> detached child 15379 (signal 10)
> child process 15379 got SIGUSR1; child_exit_status=-1
> child 15379: exiting
> removing waited-for child 15380 from the list
> killed detached child 15379 (signal 15)
> removing waited-for child 2147483647 from the list
> child 15379 terminated with exit status 0
> removing waited-for child 15379 from the list
> parent[15366] created pipes: comm (6->5), sir (8->7)
> parent registers new child 15381
> child process 15381 started
> parent[15366] created pipes: comm (7->6), sir (10->9)
> [1] 15381
> parent registers new child 15382
> child process 15382 started
> select_children: added child 15382 (6)
> select_children: added child 15381 (5)
> select_children: maxfd=6, wlen=2, wcount=2, timeout=-1.000000
>   sr = 1
>  - read select 1 children: 15382 
> read_child_ci(15382) - read length returned 0
> detached child 15382 (signal 10)
> child process 15382 got SIGUSR1; child_exit_status=-1
> select_children: added child 15381 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
> [1] 15382
> child 15382: send_master (526 bytes)
> Error in sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE)) : 
>   write error, closing pipe to the master
> Calls: lapply ... <Anonymous> -> <Anonymous> -> lapply -> FUN -> sendMaster
> child 15382: 'mcexit' called
> child 15382: exiting
> child 15382 terminated with exit status 1
> child 15381: send_master (538 bytes)
>   sr = 1
>  - read select 1 children: 15381 
> read_child_ci(15381) - read length returned 8
> read_child_ci(15381) - read 538 at 0 returned 538
> child 15381: 'mcexit' called
> child 15381 is waiting for permission to exit
> select_children: added child 15381 (5)
> select_children: maxfd=5, wlen=1, wcount=1, timeout=-1.000000
>   sr = 1
>  - read select 1 children: 15381 
> read_child_ci(15381) - read length returned 8
> detached child 15381 (signal 10)
> child process 15381 got SIGUSR1; child_exit_status=-1
> child 15381: exiting
> removing waited-for child 15382 from the list
> killed detached child 15381 (signal 15)
> removing waited-for child 2147483647 from the list
> Error in partDF::write_partDF(X, out_path, c("Date", "Panel", "Type",  : 
>   at least one core did not return from parllel write; maybe it was killed (be the Linux Out of Memory Killer ?) or there was a fatal error in the forked process(es)
> Calls: lapply -> FUN -> write_partDF_repo -> <Anonymous>
> Execution halted
> killed detached child 15381 (signal 9)
> child 15381 terminated with exit status 0
> removing waited-for child 15381 from the list
> process 15366 parallel shutdown ok
> 
> 
> 2019-11-28 10:40 GMT+01:00 Tomas Kalibera<tomas.kalibera at gmail.com>:
>> Hi Andreas,
>> thank you very much, good job finding it was EBADF. Now the question is=20
>> why the pipe has been closed prematurely; it could be accidentally by R=20
>> (a race condition in the cleanup code in fork.c) or possibly by some=20
>> other code running in the same process (maybe the R program itself or=20
>> some other code it runs). Maybe we can take this off the list and come=20
>> back when we know the cause or have it fixed.
>> 
>> It would help a lot if you could try with R built from source, with=20
>> optimizations disabled to get more accurate debug symbols (e.g. env=20
>> CFLAGS=3D"-Wall -O0 -gdwarf-2 -g3" CXXFLAGS=3D"-Wall -O0 -gdwarf-2 -g3"=20
>> =2E/configure), and with MC_DEBUG defined in fork.c - line 26. Ideally in=
>> =20
>> R-devel, so that we are sure the problem still exists. The debug=20
>> messages should give a hint whether it was R (fork.c) that closed the=20
>> pipe and why. Maybe you could also add a debug message to=20
>> close_fds_child_ci() to see if it was closed there. Maybe you could find =
>> 
>> this out even in your current debugging setup via breakpoints and=20
>> backtraces, but I think it may be easier to build from source with these =
>> 
>> debugging messages.
>> 
>> Also if you could send me a complete example I could run that causes=20
>> this on your system, that would be nice (even if it didn't cause the=20
>> problem on my system).
>> 
>> Thanks
>> Tomas
>> 
>> On 11/28/19 6:35 AM, Andreas Kersting wrote:
>>> Hi Tomas,
>>>
>>> Thanks for your prompt reply and your offer to help. I might need to ge=
>> t back to this since I am not too experienced in debugging these kinds of=
>> issues. Anyway, I gave it a try and I think I have found the immediate c=
>> ause:
>>>
>>> I installed the debug symbols (r-base-core-dbg), placed https://github.=
>> com/wch/r-source/blob/tags/R-3-5-2/src/library/parallel/src/fork.c in cwd=
>> and changed the wrapper code to:
>>>
>>> mc_ret <- parallel::mclapply(seq_len(nrow(parts)), function(i) {
>>>      # we fail for the input resulting in parts having 85 rows
>>>      if (nrow(parts) =3D=3D 85L && !file.exists(as.character(Sys.getpid=
>> ()))) {
>>>        file.create(as.character(Sys.getpid()))
>>>        print(Sys.getpid())
>>>        Sys.sleep(30)
>>>      }
>>>
>>>      # ...
>>>
>>>      return(TRUE)
>>>    }, mc.preschedule =3D TRUE, mc.cores =3D 2L)
>>>
>>> This way I ended up with only two child processes to which I each attac=
>> hed a debugger. In total I ran about 10 debugging sessions and it was alw=
>> ays the second child process failing. The errno after write returned -1 w=
>> as 9 (EBADF).
>>>
>>>  From what I can see, the reason for this is that the second child trie=
>> s to write to fd 7, but already during the very beginning of the first in=
>> vocation of the anonymous function to parallelize, i.e. during Sys.sleep(=
>> 30), there is no such file descriptor. From this observation I would conc=
>> lude that it is NOT the code run from that function, i.e. # ...,  causing=
>> the issue. Let me point out again, that this is NOT the very first invoc=
>> ation of mclapply in this R session. There is at least one previous call =
>> to it, which works fine.
>>>
>>>
>>> File descriptors directly after attaching gdb to both child processes d=
>> uring Sys.sleep(30):
>>>
>>> ### master
>>> root at ip-10-0-48-30:~/latest_test# ls -l /proc/22119/fd
>>> total 0
>>> lrwx------ 1 root root 64 Nov 28 04:49 0 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:49 1 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:49 2 -> /dev/pts/0
>>> lr-x------ 1 root root 64 Nov 28 04:49 3 -> /path/to/script.R
>>> lrwx------ 1 root root 64 Nov 28 04:49 4 -> /path/on/nfs/write.lock
>>> lr-x------ 1 root root 64 Nov 28 04:49 5 -> 'pipe:[266120]'
>>> l-wx------ 1 root root 64 Nov 28 04:49 8 -> 'pipe:[266121]'
>>>
>>>
>>> ### first child (writes to fd 6)
>>> (gdb) shell ls -l /proc/22134/fd
>>> total 0
>>> lrwx------ 1 root root 64 Nov 28 04:42 0 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:42 1 -> /dev/pts/0
>>> lrwx------ 1 root root 64 Nov 28 04:42 2 -> /dev/pts/0
>>> lr-x------ 1 root root 64 Nov 28 04:42 3 -> /path/to/script.R
>>> lrwx------ 1 root root 64 Nov 28 04:42 4 -> /path/on/nfs/write.lock
>>> l-wx------ 1 root root 64 Nov 28 04:42 6 -> 'pipe:[266120]'
>>> l-wx------ 1 root root 64 Nov 28 04:42 8 -> 'pipe:[266121]'
>>>
>>> ### second child (tries writing to fd 7)
>>> (gdb) shell ls -l /proc/22135/fd
>>> total 0
>>> lr-x------ 1 root root 64 Nov 28 04:42 0 -> 'pipe:[266123]'
>>> lrwx------ 1 root root 64 Nov 28 04:42 1 -> /dev/pts/0
>>> l-wx------ 1 root root 64 Nov 28 04:42 10 -> 'pipe:[266123]'
>>> lrwx------ 1 root root 64 Nov 28 04:42 2 -> /dev/pts/0
>>> lr-x------ 1 root root 64 Nov 28 04:42 3 -> /path/to/script.R
>>> lrwx------ 1 root root 64 Nov 28 04:42 4 -> /path/on/nfs/write.lock
>>>
>>>
>>> # debugging mc_send_master in both child processes:
>>>
>>> ### first child (all OK):
>>> (gdb) break mc_send_master
>>> Breakpoint 1 at 0x7f5b2687b0a0: file fork.c, line 681.
>>> (gdb) c
>>> Continuing.
>>>
>>> Breakpoint 1, mc_send_master (what=3D0x555c6dd2cd00) at fork.c:681
>>> warning: Source file is more recent than executable.
>>> 681	{
>>> (gdb) info args
>>> what =3D 0x555c6dd2cd00
>>> (gdb) n
>>> 682	    if (is_master)
>>> (gdb) n
>>> 684	    if (master_fd =3D=3D -1)
>>> (gdb) n
>>> 686	    if (TYPEOF(what) !=3D RAWSXP)
>>> (gdb) n
>>> 688	    R_xlen_t len =3D XLENGTH(what);
>>> (gdb) n
>>> 689	    unsigned char *b =3D RAW(what);
>>> (gdb) n
>>> 693	    if (writerep(master_fd, &len, sizeof(len)) !=3D sizeof(len)) {
>>> (gdb) info locals
>>> len =3D 538
>>> b =3D <optimized out>
>>> n =3D <optimized out>
>>> (gdb) s
>>> writerep (fildes=3D6, buf=3Dbuf at entry=3D0x7ffdd6da7db0, nbyte=3Dnbyte at e=
>> ntry=3D8)
>>>      at fork.c:653
>>> 653	{
>>> (gdb) info args
>>> fildes =3D 6
>>> buf =3D 0x7ffdd6da7db0
>>> nbyte =3D 8
>>> (gdb) n
>>> 654	    size_t wbyte =3D 0;
>>> (gdb) n
>>> 653	{
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) n
>>> 664		if (w =3D=3D 0) {
>>> (gdb) n
>>> 670		wbyte +=3D w;
>>> (gdb) n
>>> 671		if (wbyte =3D=3D nbyte)
>>> (gdb) n
>>> 672		    return wbyte;
>>> (gdb) n
>>> 674	}
>>> (gdb) n
>>> mc_send_master (what=3D<optimized out>) at fork.c:699
>>> 699	    for (R_xlen_t i =3D 0; i < len; i +=3D n) {
>>> (gdb) n
>>> 700		n =3D writerep(master_fd, b + i, len - i);
>>> (gdb) n
>>> 701		if (n < 1) {
>>> (gdb) n
>>> 699	    for (R_xlen_t i =3D 0; i < len; i +=3D n) {
>>> (gdb) n
>>> 707	    return ScalarLogical(1);
>>> (gdb) n
>>> 708	}
>>>
>>>
>>>
>>> ### second child (write fails with EBADF):
>>> (gdb) break mc_send_master
>>> Breakpoint 1 at 0x7f5016f3e0a0: file fork.c, line 681.
>>> (gdb) c
>>> Continuing.
>>>
>>> Breakpoint 1, mc_send_master (what=3D0x563382a71910) at fork.c:681
>>> warning: Source file is more recent than executable.
>>> 681	{
>>> (gdb) info args
>>> what =3D 0x563382a71910
>>> (gdb) n
>>> 682	    if (is_master)
>>> (gdb) n
>>> 684	    if (master_fd =3D=3D -1)
>>> (gdb) n
>>> 686	    if (TYPEOF(what) !=3D RAWSXP)
>>> (gdb) n
>>> 688	    R_xlen_t len =3D XLENGTH(what);
>>> (gdb) n
>>> 689	    unsigned char *b =3D RAW(what);
>>> (gdb) n
>>> 693	    if (writerep(master_fd, &len, sizeof(len)) !=3D sizeof(len)) {
>>> (gdb) info locals
>>> len =3D 526
>>> b =3D <optimized out>
>>> n =3D <optimized out>
>>> (gdb) s
>>> writerep (fildes=3D7, buf=3Dbuf at entry=3D0x7fff4027ad60, nbyte=3Dnbyte at e=
>> ntry=3D8)
>>>      at fork.c:653
>>> 653	{
>>> (gdb) info args
>>> fildes =3D 7
>>> buf =3D 0x7fff4027ad60
>>> nbyte =3D 8
>>> (gdb) n
>>> 654	    size_t wbyte =3D 0;
>>> (gdb) n
>>> 653	{
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) info locals
>>> w =3D <optimized out>
>>> wbyte =3D 0
>>> ptr =3D 0x7fff4027ad60 "\016\002"
>>> (gdb) n
>>> 657		ssize_t w =3D write(fildes, ptr + wbyte, nbyte - wbyte);
>>> (gdb) n
>>> 658		if (w =3D=3D -1) {
>>> (gdb) n
>>> 659		    if (errno =3D=3D EINTR)
>>> (gdb) n
>>> 674	}
>>> (gdb) p __errno_location()
>>> $1 =3D (int *) 0x7f50322cb540
>>> (gdb) x/x $1
>>> 0x7f50322cb540:	0x00000009
>>> (gdb) python import errno
>>> (gdb) python print(errno.errorcode[9])
>>> EBADF
>>> (gdb) n
>>> mc_send_master (what=3D<optimized out>) at fork.c:702
>>> 702		    close(master_fd);
>>> (gdb) n
>>> 704		    error(_("write error, closing pipe to the master"));
>>> (gdb) n
>>> 703		    master_fd =3D -1;
>>> (gdb) n
>>> 704		    error(_("write error, closing pipe to the master"));
>>> (gdb) n
>>> 685		error(_("there is no pipe to the master process"));
>>>
>>>
>>> Does this help in any way?
>>>
>>> Is there something else I can/should look at?
>>>
>>> Regards,
>>> Andreas
>>>
>>>
>>> 2019-11-27 15:04 GMT+01:00 Tomas Kalibera<tomas.kalibera at gmail.com>:
>>>> Hi Andreas,
>>>> the error is reported when some child process cannot send results to t=
>> he master process, which originates from an error returned by write() - w=
>> hen write() returns -1 or 0. The logic around the writing has not changed=
>> since R 3.5.2. It should not be related to the printing in the child, on=
>> ly to returning the value. The problem may be originating from the execut=
>> ion environment, virtualization, and/or possibly from a lack of robustnes=
>> s in R. To resolve this we need to find out which error was returned and =
>> why. Either you can try to create a reproducible example (something I cou=
>> ld use to trigger an error on my system and then debug) or to debug on yo=
>> ur system (build R from source, ensure the bug is still triggered, then i=
>> nstrument to print the exact error from the OS and where it was detected,=
>> etc). In principle you could also try without code instrumentation just =
>> using strace. Just from looking at the code in R around the writing I am =
>> not seeing any bug there. If you choose to debug on your system I can hel=
>> p with the instrumentation.
>>>>
>>>> Best
>>>> Tomas
>>>>
>>>> On 11/27/19 12:40 PM, Andreas Kersting wrote:
>>>>> Hi again,
>>>>>
>>>>> One important correction of my first message: I misinterpreted the ou=
>> tput. Actually in that R session 2 input files were processed one after t=
>> he other in a loop. The first (with 88 parts went fine). The second (with=
>> 85 parts) produced the sendMaster errors and failed. If (in a new sessio=
>> n via Rscript) I only process the second input file it will work. The oth=
>> er observations on R vs Rscript, NFS share etc. still hold.
>>>>>
>>>>> Sorry for this! Regards,
>>>>> Andreas
>>>>>
>>>>> 2019-11-27 12:10 GMT+01:00 Andreas Kersting<r-devel at akersting.de>:
>>>>>> Hi,
>>>>>>
>>>>>> I am facing a very weird problem with parallel::mclapply. I have a s=
>> cript which does some data wrangling on an input dataset in parallel and =
>> then writes the results to disk. I have been using this script daily for =
>> more than one year always on an EC2 instance launched from the same AMI (=
>> no updates installed after launch) and processed thousands of different i=
>> nput data sets successfully. I now have an input dataset for which I face=
>> the following bug:
>>>>>>
>>>>>> The basic outline of the problematic section of the script:
>>>>>>
>>>>>> # parts is a data.table with 88 rows
>>>>>> mc_ret <- parallel::mclapply(sample.int(nrow(parts)), function(i) {
>>>>>>     # do some data wrangling and write the result to a file
>>>>>>     # ...
>>>>>>
>>>>>>     print(paste0("part ", i, " written successfully."))
>>>>>>     return(TRUE)
>>>>>> }, mc.preschedule =3D FALSE, mc.cores =3D 2L)
>>>>>>
>>>>>> str(mc_ret)
>>>>>>
>>>>>>
>>>>>> Expected output: "part i written successfully." is printed 88 times,=
>> once for each value of i. mc_ret is a list of length 88, each element be=
>> ing TRUE. Its structure is printed once. All outputs are created successf=
>> ully.
>>>>>>
>>>>>> Actual output (see end of the message): "part i written successfully=
>> =2E" is printed 88 times, once for each value of i. mc_ret is a list of l=
>> ength 88, each element being TRUE. Its structure is printed. All outputs =
>> are created successfully. So far so good.
>>>>>>
>>>>>> But then "part i written successfully." it is printed another X time=
>> s, for values of i for which it was already printed. This output is inter=
>> mingled with X-1 times the following error message:
>>>>>>
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>>
>>>>>> and Y times the message "Execution halted". mc_ret is printed again,=
>> now being a list of length 85, with the first element being TRUE and all=
>> other elements being NULL. X and Y vary from run to run.
>>>>>>
>>>>>>
>>>>>> Now to the main problem: I tried very hard to create a reproducible =
>> example, but I failed. What I observed:
>>>>>> - The output is (and has always been) written to path which is on an=
>> NFS share. If I instead write to a path on a local disk it will work.
>>>>>> - The script is invoked using Rscript. If I instead source it from a=
>> n interactive R session it works. There are at least two more people who =
>> have observed this: https://stackoverflow.com/questions/51986674/mclapply=
>> -sendmaster-error-only-with-rscript
>>>>>> - Before the call to mclapply the code acquires an exclusive file lo=
>> ck on a dedicated lock file, not written to but also on the NFS share. If=
>> I remove the code acquiring the lock, the whole script will also work if=
>> called using Rscript.
>>>>>> - The problem also occurs for mc.preschedule =3D TRUE.
>>>>>> - There is no error if I set mc.cores to 1.
>>>>>> - And stressing again: the code works without any changes from Rscri=
>> pt for thousands of other data sets.
>>>>>>
>>>>>>
>>>>>> Rscript -e "sessionInfo()":
>>>>>> R version 3.5.2 (2018-12-20)
>>>>>> Platform: x86_64-pc-linux-gnu (64-bit)
>>>>>> Running under: Ubuntu 18.04.2 LTS
>>>>>>
>>>>>> Matrix products: default
>>>>>> BLAS: /usr/lib/x86_64-linux-gnu/openblas/libblas.so.3
>>>>>> LAPACK: /usr/lib/x86_64-linux-gnu/libopenblasp-r0.2.20.so
>>>>>>
>>>>>> locale:
>>>>>>    [1] LC_CTYPE=3DC.UTF-8       LC_NUMERIC=3DC           LC_TIME=3DC=
>> =2EUTF-8
>>>>>>    [4] LC_COLLATE=3DC.UTF-8     LC_MONETARY=3DC.UTF-8    LC_MESSAGES=
>> =3DC.UTF-8
>>>>>>    [7] LC_PAPER=3DC.UTF-8       LC_NAME=3DC              LC_ADDRESS=3D=
>> C
>>>>>> [10] LC_TELEPHONE=3DC         LC_MEASUREMENT=3DC.UTF-8 LC_IDENTIFICA=
>> TION=3DC
>>>>>>
>>>>>> attached base packages:
>>>>>> [1] stats     graphics  grDevices utils     datasets  methods   base=
>> 
>>>>>>
>>>>>> loaded via a namespace (and not attached):
>>>>>> [1] compiler_3.5.2
>>>>>>
>>>>>>
>>>>>> I know this is a fairly old R version. I have not been able to repro=
>> duce the bug with a more recent version, but since it is so difficult to =
>> trigger, this does not mean much, I guess. I have looked through the chan=
>> ges made to the code of mclapply since that version and could not find so=
>> mething directly related. I am not even sure if it is a problem in the pa=
>> rallel package or some other (memory) bug. What strikes me is that others=
>> have observed a very similar error when using Rscript but not when using=
>> an interactive R session, just like I do.
>>>>>>
>>>>>> I am not expecting a fix based on the information I provide, but may=
>> be someone has some thoughts on this!?
>>>>>>
>>>>>> Regards,
>>>>>> Andreas
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> Actual output:
>>>>>>
>>>>>> [1] "part 51 written successfully."
>>>>>> [1] "part 30 written successfully."
>>>>>> [1] "part 32 written successfully."
>>>>>> [1] "part 48 written successfully."
>>>>>> [1] "part 63 written successfully."
>>>>>> [1] "part 5 written successfully."
>>>>>> [1][1] "part 14 written successfully." "part 18 written successfully=
>> =2E"
>>>>>>
>>>>>> [1] "part 38 written successfully."
>>>>>> [1] "part 11 written successfully."
>>>>>> [1] "part 68 written successfully."
>>>>>> [1] "part 45 written successfully."
>>>>>> [1] "part 88 written successfully."
>>>>>> [1] "part 36 written successfully."
>>>>>> [1] "part 44 written successfully."
>>>>>> [1] "part 55 written successfully."
>>>>>> [1] "part 26 written successfully."
>>>>>> [1] "part 37 written successfully."
>>>>>> [1] "part 22 written successfully."
>>>>>> [1] "part 13 written successfully."
>>>>>> [1] "part 67 written successfully."
>>>>>> [1] "part 10 written successfully."
>>>>>> [1] "part 24 written successfully."
>>>>>> [1] "part 20 written successfully."
>>>>>> [1] "part 74 written successfully."
>>>>>> [1] "part 50 written successfully."
>>>>>> [1] "part 2 written successfully."
>>>>>> [1] "part 17 written successfully."
>>>>>> [1] "part 66 written successfully."
>>>>>> [1] "part 61 written successfully."
>>>>>> [1][1] "part 7 written successfully." "part 31 written successfully.=
>> "
>>>>>>
>>>>>> [1] "part 70 written successfully."
>>>>>> [1] "part 71 written successfully."
>>>>>> [1][1] "part 76 written successfully."
>>>>>>    "part 42 written successfully."
>>>>>> [1][1] "part 72 written successfully." "part 12 written successfully=
>> =2E"
>>>>>>
>>>>>> [1] "part 39 written successfully."
>>>>>> [1] "part 58 written successfully."
>>>>>> [1] "part 87 written successfully."
>>>>>> [1] "part 81 written successfully."
>>>>>> [1] "part 3 written successfully."
>>>>>> [1] "part 29 written successfully."
>>>>>> [1] "part 82 written successfully."
>>>>>> [1] "part 54 written successfully."
>>>>>> [1] "part 23 written successfully."
>>>>>> [1] "part 56 written successfully."
>>>>>> [1] "part 73 written successfully."
>>>>>> [1] "part 27 written successfully."
>>>>>> [1] "part 64 written successfully."
>>>>>> [1] "part 46 written successfully."
>>>>>> [1] "part 80 written successfully."
>>>>>> [1] "part 53 written successfully."
>>>>>> [1] "part 43 written successfully."
>>>>>> [1] "part 47 written successfully."
>>>>>> [1] "part 57 written successfully."
>>>>>> [1] "part 75 written successfully."
>>>>>> [1] "part 84 written successfully."
>>>>>> [1] "part 85 written successfully."
>>>>>> [1][1] "part 86 written successfully."
>>>>>>    "part 19 written successfully."
>>>>>> [1][1] "part 33 written successfully." "part 34 written successfully=
>> =2E"
>>>>>>
>>>>>> [1] "part 21 written successfully."
>>>>>> [1] "part 40 written successfully."
>>>>>> [1][1] "part 4 written successfully."
>>>>>>    "part 28 written successfully."
>>>>>> [1] "part 62 written successfully."
>>>>>> [1] "part 16 written successfully."
>>>>>> [1] "part 79 written successfully."
>>>>>> [1] "part 6 written successfully."
>>>>>> [1] "part 77 written successfully."
>>>>>> [1] "part 65 written successfully."
>>>>>> [1] "part 60 written successfully."
>>>>>> [1] "part 78 written successfully."
>>>>>> [1] "part 1 written successfully."
>>>>>> [1] "part 83 written successfully."
>>>>>> [1] "part 9 written successfully."
>>>>>> [1] "part 15 written successfully."
>>>>>> [1][1] "part 41 written successfully."
>>>>>>    "part 35 written successfully."
>>>>>> [1][1] "part 8 written successfully." "part 69 written successfully.=
>> "
>>>>>>
>>>>>> [1] "part 59 written successfully."
>>>>>> [1] "part 25 written successfully."
>>>>>> [1] "part 49 written successfully."
>>>>>> [1] "part 52 written successfully."
>>>>>> List of 88
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>>    $ : logi TRUE
>>>>>> [1] "part 31 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> lapply -> FUN -> mcparallel -> send=
>> Master
>>>>>> [1] "part 71 written successfully."
>>>>>> [1] "part 35 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 42 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 4 written successfully."
>>>>>> Execution halted
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1][1] "part 30 written successfully." "part 40 written successfully=
>> =2E"
>>>>>>
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 41 written successfully."
>>>>>> [1] "part 80 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 45 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 82 written successfully."
>>>>>> [1] "part 54 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 59 written successfully."
>>>>>> Execution halted
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 27 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 36 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 44 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 83 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 61 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 70 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 66 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 10 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 53 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 55 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 15 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 50 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 5 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 48 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 32 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 69 written successfully."
>>>>>> Execution halted
>>>>>> [1] "part 52 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 77 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 24 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 56 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 6 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 62 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 33 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 16 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 34 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 74 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 2 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 19 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> [1] "part 9 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 11 written successfully."
>>>>>> [1] "part 28 written successfully."
>>>>>> [1] "part 29 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 17 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 65 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> Execution halted
>>>>>> Execution halted
>>>>>> [1] "part 68 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 43 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 38 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 1 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 57 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 8 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1] "part 25 written successfully."
>>>>>> Error in sendMaster(try(eval(expr, env), silent =3D TRUE)) :
>>>>>>     write error, closing pipe to the master
>>>>>> Calls: lapply ... <Anonymous> -> <Anonymous> -> mcparallel -> sendMa=
>> ster
>>>>>> [1]List of 85
>>>>>>    $ : logi TRUE
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>>    $ : NULL
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>> 
>> 
>> 

From joh@nn@k|e|nbub @end|ng |rom gm@||@com  Thu Dec  5 17:00:57 2019
From: joh@nn@k|e|nbub @end|ng |rom gm@||@com (Johann R. Kleinbub)
Date: Thu, 5 Dec 2019 17:00:57 +0100
Subject: [Rd] Maybe bug? Using non-integer frequencies in stats::ts
In-Reply-To: <CALTZUioLKO3ynX0swMnwygMYOxtTS2UvPbCP1K4NDPyrfr+x4A@mail.gmail.com>
References: <CALTZUioLKO3ynX0swMnwygMYOxtTS2UvPbCP1K4NDPyrfr+x4A@mail.gmail.com>
Message-ID: <CALTZUirEBDc_jqebSuvLbpEh3h0J8HJp6g0BRGvmpJHYcODRsg@mail.gmail.com>

It's been three months without an answer, is it ok to thread bump?
Would someone provide a pointer?

Thank you for your consideration,
Johann


On Mon, 16 Sep 2019 at 15:53, Johann R. Kleinbub <johann.kleinbub at gmail.com>
wrote:
>
> I am developing a package to analyse physiological time-series and I
thought that the most reliable and robust solution was to base it on the
native stats::ts class. In my domain it is common to express series
frequencies as samples-per-second. So ts(..., frequency=10) would mean a
signal sampled 10 times every second, and ts(..., frequency = 1) a signal
sampled every second. Following this logic, a few slower signals are
sampled every 5 seconds (or more), resulting in a frequency of e.g. 0.2
> Nowhere in the documentation is stated that the frequency must be an
integer value, but using fractional values gives inconsistent results.
> For instance, in this example, foo and bar are identical, just with
start-end values shifted by 1. Yet when extracting an arbitrary window, the
'bar' series gives error.
>
> x = 1:22
> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2)
> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2)
>
> window(foo, start = 20, end = 30, extend=TRUE)
>
> # Time Series:
> # Start = 20
> # End = 25
> # Frequency = 0.2
> # [1] 5 6
>
> window(bar, start = 20, end = 30, extend=TRUE)
>
> # Error in attr(y, "tsp") <- c(ystart, yend, xfreq) :
> #   invalid time series parameters specified
>
> The reason is in the rounding procedures for ystart and yend at the end
of the stats::window function. For the 'foo' series the ystart and yend
values are calculated as: c(20, 25), whereas for the 'bar' series, they
become c(20, 30) although the window should be of the very same size in
both cases. (A further discussion on the example is at:
https://stackoverflow.com/questions/57928054 )
> Should I report a bug or am I misunderstanding something?
>
> --
> Johann R. Kleinbub, PhD
> University of Padova
> FISPPA Dep. - Section of Applied Psychology
> Cell: +39 3495986373



--
Johann R. Kleinbub, PhD
University of Padova
FISPPA Dep. - Section of Applied Psychology
Cell: +39 3495986373

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Thu Dec  5 17:46:44 2019
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Thu, 5 Dec 2019 11:46:44 -0500
Subject: [Rd] Maybe bug? Using non-integer frequencies in stats::ts
In-Reply-To: <CALTZUirEBDc_jqebSuvLbpEh3h0J8HJp6g0BRGvmpJHYcODRsg@mail.gmail.com>
References: <CALTZUioLKO3ynX0swMnwygMYOxtTS2UvPbCP1K4NDPyrfr+x4A@mail.gmail.com>
 <CALTZUirEBDc_jqebSuvLbpEh3h0J8HJp6g0BRGvmpJHYcODRsg@mail.gmail.com>
Message-ID: <3867dc12-07c3-b2cc-d575-f3450a5dab35@gmail.com>

On 05/12/2019 11:00 a.m., Johann R. Kleinbub wrote:
> It's been three months without an answer, is it ok to thread bump?
> Would someone provide a pointer?

I agree it's a bug, and agree with your analysis.  You should report it 
on bugs.r-project.org.  (If you don't have an account there, let us 
know, and either someone will give you one, or someone will report it 
for you.)

As a workaround, I don't see it happening with extend=FALSE, but of 
course that might not suit your needs in general.

Duncan Murdoch



> 
> Thank you for your consideration,
> Johann
> 
> 
> On Mon, 16 Sep 2019 at 15:53, Johann R. Kleinbub <johann.kleinbub at gmail.com>
> wrote:
>>
>> I am developing a package to analyse physiological time-series and I
> thought that the most reliable and robust solution was to base it on the
> native stats::ts class. In my domain it is common to express series
> frequencies as samples-per-second. So ts(..., frequency=10) would mean a
> signal sampled 10 times every second, and ts(..., frequency = 1) a signal
> sampled every second. Following this logic, a few slower signals are
> sampled every 5 seconds (or more), resulting in a frequency of e.g. 0.2
>> Nowhere in the documentation is stated that the frequency must be an
> integer value, but using fractional values gives inconsistent results.
>> For instance, in this example, foo and bar are identical, just with
> start-end values shifted by 1. Yet when extracting an arbitrary window, the
> 'bar' series gives error.
>>
>> x = 1:22
>> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2)
>> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2)
>>
>> window(foo, start = 20, end = 30, extend=TRUE)
>>
>> # Time Series:
>> # Start = 20
>> # End = 25
>> # Frequency = 0.2
>> # [1] 5 6
>>
>> window(bar, start = 20, end = 30, extend=TRUE)
>>
>> # Error in attr(y, "tsp") <- c(ystart, yend, xfreq) :
>> #   invalid time series parameters specified
>>
>> The reason is in the rounding procedures for ystart and yend at the end
> of the stats::window function. For the 'foo' series the ystart and yend
> values are calculated as: c(20, 25), whereas for the 'bar' series, they
> become c(20, 30) although the window should be of the very same size in
> both cases. (A further discussion on the example is at:
> https://stackoverflow.com/questions/57928054 )
>> Should I report a bug or am I misunderstanding something?
>>
>> --
>> Johann R. Kleinbub, PhD
>> University of Padova
>> FISPPA Dep. - Section of Applied Psychology
>> Cell: +39 3495986373
> 
> 
> 
> --
> Johann R. Kleinbub, PhD
> University of Padova
> FISPPA Dep. - Section of Applied Psychology
> Cell: +39 3495986373
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From btyner @end|ng |rom gm@||@com  Fri Dec  6 02:46:50 2019
From: btyner @end|ng |rom gm@||@com (Benjamin Tyner)
Date: Thu, 5 Dec 2019 20:46:50 -0500
Subject: [Rd] Error in close.connection(p) : ignoring SIGPIPE signal
Message-ID: <a0461c12-0e5d-104c-5fb4-32631667c9d9@gmail.com>

Not sure if this is a bug, so posting here first. If I run:

 ?? cnt <- 0L
 ?? while (TRUE) {
 ? ? ?? cnt <- cnt + 1L
 ? ? ?? p <- pipe("echo /dev/stdin > /dev/null", open = "w")
 ? ? ?? writeLines("foobar", p)
 ? ? ?? tryCatch(close(p), error = function(e) { print(cnt); stop(e)})
 ?? }

then once cnt gets to around 650, it fails with:

 ?? [1] 654
 ?? Error in close.connection(p) : ignoring SIGPIPE signal

Should I not be using pipe() in this way? Here is my sessionInfo()

 ?? R version 3.6.0 (2019-04-26)
 ?? Platform: x86_64-pc-linux-gnu (64-bit)
 ?? Running under: Ubuntu 18.04.3 LTS

 ?? Matrix products: default
 ?? BLAS:?? /home/btyner/R360/lib64/R/lib/libRblas.so
 ?? LAPACK: /home/btyner/R360/lib64/R/lib/libRlapack.so

 ?? locale:
 ? ? [1] LC_CTYPE=en_US.UTF-8?????? LC_NUMERIC=C
 ? ? [3] LC_TIME=en_US.UTF-8??????? LC_COLLATE=en_US.UTF-8
 ? ? [5] LC_MONETARY=en_US.UTF-8??? LC_MESSAGES=en_US.UTF-8
 ? ? [7] LC_PAPER=en_US.UTF-8?????? LC_NAME=C
 ? ? [9] LC_ADDRESS=C?????????????? LC_TELEPHONE=C
 ?? [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C

 ?? attached base packages:
 ?? [1] stats???? graphics? grDevices utils???? datasets? methods base

 ?? loaded via a namespace (and not attached):
 ?? [1] compiler_3.6.0

Regards,
Ben


From r-deve| @end|ng |rom @ker@t|ng@de  Fri Dec  6 08:04:53 2019
From: r-deve| @end|ng |rom @ker@t|ng@de (Andreas Kersting)
Date: Fri, 06 Dec 2019 08:04:53 +0100 (CET)
Subject: [Rd] Error in close.connection(p) : ignoring SIGPIPE signal
In-Reply-To: <a0461c12-0e5d-104c-5fb4-32631667c9d9@gmail.com>
Message-ID: <E1id7fZ-0000XB-A0@rmmprod05.runbox>

Hi Benjamin,

you cannot pipe to echo, since it does not read from stdin. 

echo just echos is first arg, i.e. echo /dev/stdin > /dev/null will echo the string "/dev/stdin"to /dev/stdout, which is redirected to /dev/null.

Try 

p <- pipe("cat > /dev/null", open = "w")

instead.

Regards,
Andreas

2019-12-06 02:46 GMT+01:00 Benjamin Tyner<btyner at gmail.com>:
> Not sure if this is a bug, so posting here first. If I run:
> ?? cnt <- 0L
> ?? while (TRUE) {
> ? ? ?? cnt <- cnt + 1L
> ? ? ?? p <- pipe("echo /dev/stdin > /dev/null", open = "w")
> ? ? ?? writeLines("foobar", p)
> ? ? ?? tryCatch(close(p), error = function(e) { print(cnt); stop(e)})
> ?? }
> 
> then once cnt gets to around 650, it fails with:
> 
> ?? [1] 654
> ?? Error in close.connection(p) : ignoring SIGPIPE signal
> 
> Should I not be using pipe() in this way? Here is my sessionInfo()
> 
> ?? R version 3.6.0 (2019-04-26)
> ?? Platform: x86_64-pc-linux-gnu (64-bit)
> ?? Running under: Ubuntu 18.04.3 LTS
> 
> ?? Matrix products: default
> ?? BLAS:?? /home/btyner/R360/lib64/R/lib/libRblas.so
> ?? LAPACK: /home/btyner/R360/lib64/R/lib/libRlapack.so
> 
> ?? locale:
> ? ? [1] LC_CTYPE=en_US.UTF-8?????? LC_NUMERIC=C
> ? ? [3] LC_TIME=en_US.UTF-8??????? LC_COLLATE=en_US.UTF-8
> ? ? [5] LC_MONETARY=en_US.UTF-8??? LC_MESSAGES=en_US.UTF-8
> ? ? [7] LC_PAPER=en_US.UTF-8?????? LC_NAME=C
> ? ? [9] LC_ADDRESS=C?????????????? LC_TELEPHONE=C
> ?? [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C
> 
> ?? attached base packages:
> ?? [1] stats???? graphics? grDevices utils???? datasets? methods base
> 
> ?? loaded via a namespace (and not attached):
> ?? [1] compiler_3.6.0
> 
> Regards,
> Ben
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

From btyner @end|ng |rom gm@||@com  Fri Dec  6 13:29:00 2019
From: btyner @end|ng |rom gm@||@com (Benjamin Tyner)
Date: Fri, 6 Dec 2019 07:29:00 -0500
Subject: [Rd] Error in close.connection(p) : ignoring SIGPIPE signal
In-Reply-To: <E1id7fZ-0000XB-A0@rmmprod05.runbox>
References: <E1id7fZ-0000XB-A0@rmmprod05.runbox>
Message-ID: <c525244e-cd3c-6dc5-52a8-837ff982489d@gmail.com>

Andreas,

How right you are! Still, I find it curious that in the context of the 
while(TRUE) loop, I am allowed to do this 653 times, with failure on the 
654th attempt. Perhaps there is something asynchronous going on? If I 
eliminate the looping, it does indeed fail (as expected) on the first 
attempt to close the pipe.

Regards

Ben

On 12/6/19 2:04 AM, Andreas Kersting wrote:
> Hi Benjamin,
>
> you cannot pipe to echo, since it does not read from stdin.
>
> echo just echos is first arg, i.e. echo /dev/stdin > /dev/null will echo the string "/dev/stdin"to /dev/stdout, which is redirected to /dev/null.
>
> Try
>
> p <- pipe("cat > /dev/null", open = "w")
>
> instead.
>
> Regards,
> Andreas
>
> 2019-12-06 02:46 GMT+01:00 Benjamin Tyner<btyner at gmail.com>:
>> Not sure if this is a bug, so posting here first. If I run:
>>  ?? cnt <- 0L
>>  ?? while (TRUE) {
>>  ? ? ?? cnt <- cnt + 1L
>>  ? ? ?? p <- pipe("echo /dev/stdin > /dev/null", open = "w")
>>  ? ? ?? writeLines("foobar", p)
>>  ? ? ?? tryCatch(close(p), error = function(e) { print(cnt); stop(e)})
>>  ?? }
>>
>> then once cnt gets to around 650, it fails with:
>>
>>  ?? [1] 654
>>  ?? Error in close.connection(p) : ignoring SIGPIPE signal
>>
>> Should I not be using pipe() in this way? Here is my sessionInfo()
>>
>>  ?? R version 3.6.0 (2019-04-26)
>>  ?? Platform: x86_64-pc-linux-gnu (64-bit)
>>  ?? Running under: Ubuntu 18.04.3 LTS
>>
>>  ?? Matrix products: default
>>  ?? BLAS:?? /home/btyner/R360/lib64/R/lib/libRblas.so
>>  ?? LAPACK: /home/btyner/R360/lib64/R/lib/libRlapack.so
>>
>>  ?? locale:
>>  ? ? [1] LC_CTYPE=en_US.UTF-8?????? LC_NUMERIC=C
>>  ? ? [3] LC_TIME=en_US.UTF-8??????? LC_COLLATE=en_US.UTF-8
>>  ? ? [5] LC_MONETARY=en_US.UTF-8??? LC_MESSAGES=en_US.UTF-8
>>  ? ? [7] LC_PAPER=en_US.UTF-8?????? LC_NAME=C
>>  ? ? [9] LC_ADDRESS=C?????????????? LC_TELEPHONE=C
>>  ?? [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C
>>
>>  ?? attached base packages:
>>  ?? [1] stats???? graphics? grDevices utils???? datasets? methods base
>>
>>  ?? loaded via a namespace (and not attached):
>>  ?? [1] compiler_3.6.0
>>
>> Regards,
>> Ben
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From joh@nn@k|e|nbub @end|ng |rom gm@||@com  Fri Dec  6 16:00:35 2019
From: joh@nn@k|e|nbub @end|ng |rom gm@||@com (Johann R. Kleinbub)
Date: Fri, 6 Dec 2019 16:00:35 +0100
Subject: [Rd] Maybe bug? Using non-integer frequencies in stats::ts
In-Reply-To: <3867dc12-07c3-b2cc-d575-f3450a5dab35@gmail.com>
References: <CALTZUioLKO3ynX0swMnwygMYOxtTS2UvPbCP1K4NDPyrfr+x4A@mail.gmail.com>
 <CALTZUirEBDc_jqebSuvLbpEh3h0J8HJp6g0BRGvmpJHYcODRsg@mail.gmail.com>
 <3867dc12-07c3-b2cc-d575-f3450a5dab35@gmail.com>
Message-ID: <CALTZUirin0md5V2-=otM8vGN_m-XEefk50Y8uGFBe43CB5p87w@mail.gmail.com>

Thank you for the quick follow up, Duncan.
Unfortunately extend=TRUE is called internally in various instances such as
when replacing parts of the time-series with  window<-.ts
Consider the following examples of time series with ugly values:
x = 1:22
foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2) # a ts of 525 cycles
bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2) # a ts of 525 cycles
starting 5 cycles later than foo
qux = ts(x, start = 2.5, end = 102.5, frequency = 0.2) # a ts of 500 cycles
starting 5 cycles later than foo

# extraction works fine
window(foo, start = 20, end = 30)  # works fine
window(bar, start = 20, end = 30)  # works fine
window(qux, start = 20, end = 30)  # works fine

# assignment fails in different ways for bar and qux
window(foo, start = 20, end = 30) <- NA  # works fine
window(bar, start = 20, end = 30) <- NA  # ERROR: "invalid time series
parameters specified"
window(qux, start = 20, end = 30) <- NA  # ERROR: "times to be replaced do
not match"

If extraction works fine, there's no reason why replacing the values should
fail.
I don't have an account on bugs.r-project.org yet. I'd be available to do
the report if I'm assigned one.
Best,
Johann

On Thu, 5 Dec 2019 at 17:46, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 05/12/2019 11:00 a.m., Johann R. Kleinbub wrote:
> > It's been three months without an answer, is it ok to thread bump?
> > Would someone provide a pointer?
>
> I agree it's a bug, and agree with your analysis.  You should report it
> on bugs.r-project.org.  (If you don't have an account there, let us
> know, and either someone will give you one, or someone will report it
> for you.)
>
> As a workaround, I don't see it happening with extend=FALSE, but of
> course that might not suit your needs in general.
>
> Duncan Murdoch
>
>
>
> >
> > Thank you for your consideration,
> > Johann
> >
> >
> > On Mon, 16 Sep 2019 at 15:53, Johann R. Kleinbub <
> johann.kleinbub at gmail.com>
> > wrote:
> >>
> >> I am developing a package to analyse physiological time-series and I
> > thought that the most reliable and robust solution was to base it on the
> > native stats::ts class. In my domain it is common to express series
> > frequencies as samples-per-second. So ts(..., frequency=10) would mean a
> > signal sampled 10 times every second, and ts(..., frequency = 1) a signal
> > sampled every second. Following this logic, a few slower signals are
> > sampled every 5 seconds (or more), resulting in a frequency of e.g. 0.2
> >> Nowhere in the documentation is stated that the frequency must be an
> > integer value, but using fractional values gives inconsistent results.
> >> For instance, in this example, foo and bar are identical, just with
> > start-end values shifted by 1. Yet when extracting an arbitrary window,
> the
> > 'bar' series gives error.
> >>
> >> x = 1:22
> >> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2)
> >> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2)
> >>
> >> window(foo, start = 20, end = 30, extend=TRUE)
> >>
> >> # Time Series:
> >> # Start = 20
> >> # End = 25
> >> # Frequency = 0.2
> >> # [1] 5 6
> >>
> >> window(bar, start = 20, end = 30, extend=TRUE)
> >>
> >> # Error in attr(y, "tsp") <- c(ystart, yend, xfreq) :
> >> #   invalid time series parameters specified
> >>
> >> The reason is in the rounding procedures for ystart and yend at the end
> > of the stats::window function. For the 'foo' series the ystart and yend
> > values are calculated as: c(20, 25), whereas for the 'bar' series, they
> > become c(20, 30) although the window should be of the very same size in
> > both cases. (A further discussion on the example is at:
> > https://stackoverflow.com/questions/57928054 )
> >> Should I report a bug or am I misunderstanding something?
> >>
> >> --
> >> Johann R. Kleinbub, PhD
> >> University of Padova
> >> FISPPA Dep. - Section of Applied Psychology
> >> Cell: +39 3495986373
> >
> >
> >
> > --
> > Johann R. Kleinbub, PhD
> > University of Padova
> > FISPPA Dep. - Section of Applied Psychology
> > Cell: +39 3495986373
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>

-- 
Johann R. Kleinbub, PhD
University of Padova
FISPPA Dep. - Section of Applied Psychology
Cell: +39 3495986373

	[[alternative HTML version deleted]]


From wdun|@p @end|ng |rom t|bco@com  Fri Dec  6 18:13:59 2019
From: wdun|@p @end|ng |rom t|bco@com (William Dunlap)
Date: Fri, 6 Dec 2019 09:13:59 -0800
Subject: [Rd] Error in close.connection(p) : ignoring SIGPIPE signal
In-Reply-To: <c525244e-cd3c-6dc5-52a8-837ff982489d@gmail.com>
References: <E1id7fZ-0000XB-A0@rmmprod05.runbox>
 <c525244e-cd3c-6dc5-52a8-837ff982489d@gmail.com>
Message-ID: <CAF8bMcaRW3S0mDJjsCKV7gz5dK4GaGe7S3fZ=0ga+_9R12ef4Q@mail.gmail.com>

You may be running out of file descriptors because the pipe objects are not
getting garbage collected often enough.  Adding the line
   if (cnt %% 100 == 0) { cat(cnt, "\n"); gc() }
to your loop  lets it continue indefinitely.

Bill Dunlap
TIBCO Software
wdunlap tibco.com


On Fri, Dec 6, 2019 at 4:29 AM Benjamin Tyner <btyner at gmail.com> wrote:

> Andreas,
>
> How right you are! Still, I find it curious that in the context of the
> while(TRUE) loop, I am allowed to do this 653 times, with failure on the
> 654th attempt. Perhaps there is something asynchronous going on? If I
> eliminate the looping, it does indeed fail (as expected) on the first
> attempt to close the pipe.
>
> Regards
>
> Ben
>
> On 12/6/19 2:04 AM, Andreas Kersting wrote:
> > Hi Benjamin,
> >
> > you cannot pipe to echo, since it does not read from stdin.
> >
> > echo just echos is first arg, i.e. echo /dev/stdin > /dev/null will echo
> the string "/dev/stdin"to /dev/stdout, which is redirected to /dev/null.
> >
> > Try
> >
> > p <- pipe("cat > /dev/null", open = "w")
> >
> > instead.
> >
> > Regards,
> > Andreas
> >
> > 2019-12-06 02:46 GMT+01:00 Benjamin Tyner<btyner at gmail.com>:
> >> Not sure if this is a bug, so posting here first. If I run:
> >>     cnt <- 0L
> >>     while (TRUE) {
> >>         cnt <- cnt + 1L
> >>         p <- pipe("echo /dev/stdin > /dev/null", open = "w")
> >>         writeLines("foobar", p)
> >>         tryCatch(close(p), error = function(e) { print(cnt); stop(e)})
> >>     }
> >>
> >> then once cnt gets to around 650, it fails with:
> >>
> >>     [1] 654
> >>     Error in close.connection(p) : ignoring SIGPIPE signal
> >>
> >> Should I not be using pipe() in this way? Here is my sessionInfo()
> >>
> >>     R version 3.6.0 (2019-04-26)
> >>     Platform: x86_64-pc-linux-gnu (64-bit)
> >>     Running under: Ubuntu 18.04.3 LTS
> >>
> >>     Matrix products: default
> >>     BLAS:   /home/btyner/R360/lib64/R/lib/libRblas.so
> >>     LAPACK: /home/btyner/R360/lib64/R/lib/libRlapack.so
> >>
> >>     locale:
> >>      [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
> >>      [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
> >>      [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
> >>      [7] LC_PAPER=en_US.UTF-8       LC_NAME=C
> >>      [9] LC_ADDRESS=C               LC_TELEPHONE=C
> >>     [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C
> >>
> >>     attached base packages:
> >>     [1] stats     graphics  grDevices utils     datasets  methods base
> >>
> >>     loaded via a namespace (and not attached):
> >>     [1] compiler_3.6.0
> >>
> >> Regards,
> >> Ben
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Fri Dec  6 18:35:32 2019
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Fri, 6 Dec 2019 12:35:32 -0500
Subject: [Rd] Maybe bug? Using non-integer frequencies in stats::ts
In-Reply-To: <CALTZUirin0md5V2-=otM8vGN_m-XEefk50Y8uGFBe43CB5p87w@mail.gmail.com>
References: <CALTZUioLKO3ynX0swMnwygMYOxtTS2UvPbCP1K4NDPyrfr+x4A@mail.gmail.com>
 <CALTZUirEBDc_jqebSuvLbpEh3h0J8HJp6g0BRGvmpJHYcODRsg@mail.gmail.com>
 <3867dc12-07c3-b2cc-d575-f3450a5dab35@gmail.com>
 <CALTZUirin0md5V2-=otM8vGN_m-XEefk50Y8uGFBe43CB5p87w@mail.gmail.com>
Message-ID: <624c28a5-e428-0655-9fe7-c91baae72723@gmail.com>

To R-devel:

I've sent this to Johann privately already; just in case anyone else is 
interested in this issue, here's what I wrote:

Just started looking into it, and discovered this paragraph in ?ts:

"The value of argument frequency is used when the series is sampled an
integral number of times in each unit time interval. For example, one
could use a value of 7 for frequency when the data are sampled daily,
and the natural time period is a week, or 12 when the data are sampled
monthly and the natural time period is a year. Values of 4 and 12 are
assumed in (e.g.) print methods to imply a quarterly and monthly series
respectively."

That says that frequency will be a positive integer, so frequency=0.2
was not intended to be covered, and I'd say it's not exactly a bug that
it doesn't work.  (It might be called a bug that there's no error message.)

On the other hand, it comes close to working, and it seems like allowing
frequency=0.2 would be a useful addition.  I'm going to keep looking,
and see how hard it would be to get this to work properly.  If it 
doesn't break other things, I may submit this as an enhancement.

Duncan Murdoch


On 06/12/2019 10:00 a.m., Johann R. Kleinbub wrote:
> Thank you for the quick follow up, Duncan.
> Unfortunately extend=TRUE is called internally in various instances such as
> when replacing parts of the time-series with  window<-.ts
> Consider the following examples of time series with ugly values:
> x = 1:22
> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2) # a ts of 525 cycles
> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2) # a ts of 525 cycles
> starting 5 cycles later than foo
> qux = ts(x, start = 2.5, end = 102.5, frequency = 0.2) # a ts of 500 cycles
> starting 5 cycles later than foo
> 
> # extraction works fine
> window(foo, start = 20, end = 30)  # works fine
> window(bar, start = 20, end = 30)  # works fine
> window(qux, start = 20, end = 30)  # works fine
> 
> # assignment fails in different ways for bar and qux
> window(foo, start = 20, end = 30) <- NA  # works fine
> window(bar, start = 20, end = 30) <- NA  # ERROR: "invalid time series
> parameters specified"
> window(qux, start = 20, end = 30) <- NA  # ERROR: "times to be replaced do
> not match"
> 
> If extraction works fine, there's no reason why replacing the values should
> fail.
> I don't have an account on bugs.r-project.org yet. I'd be available to do
> the report if I'm assigned one.
> Best,
> Johann
> 
> On Thu, 5 Dec 2019 at 17:46, Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> 
>> On 05/12/2019 11:00 a.m., Johann R. Kleinbub wrote:
>>> It's been three months without an answer, is it ok to thread bump?
>>> Would someone provide a pointer?
>>
>> I agree it's a bug, and agree with your analysis.  You should report it
>> on bugs.r-project.org.  (If you don't have an account there, let us
>> know, and either someone will give you one, or someone will report it
>> for you.)
>>
>> As a workaround, I don't see it happening with extend=FALSE, but of
>> course that might not suit your needs in general.
>>
>> Duncan Murdoch
>>
>>
>>
>>>
>>> Thank you for your consideration,
>>> Johann
>>>
>>>
>>> On Mon, 16 Sep 2019 at 15:53, Johann R. Kleinbub <
>> johann.kleinbub at gmail.com>
>>> wrote:
>>>>
>>>> I am developing a package to analyse physiological time-series and I
>>> thought that the most reliable and robust solution was to base it on the
>>> native stats::ts class. In my domain it is common to express series
>>> frequencies as samples-per-second. So ts(..., frequency=10) would mean a
>>> signal sampled 10 times every second, and ts(..., frequency = 1) a signal
>>> sampled every second. Following this logic, a few slower signals are
>>> sampled every 5 seconds (or more), resulting in a frequency of e.g. 0.2
>>>> Nowhere in the documentation is stated that the frequency must be an
>>> integer value, but using fractional values gives inconsistent results.
>>>> For instance, in this example, foo and bar are identical, just with
>>> start-end values shifted by 1. Yet when extracting an arbitrary window,
>> the
>>> 'bar' series gives error.
>>>>
>>>> x = 1:22
>>>> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2)
>>>> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2)
>>>>
>>>> window(foo, start = 20, end = 30, extend=TRUE)
>>>>
>>>> # Time Series:
>>>> # Start = 20
>>>> # End = 25
>>>> # Frequency = 0.2
>>>> # [1] 5 6
>>>>
>>>> window(bar, start = 20, end = 30, extend=TRUE)
>>>>
>>>> # Error in attr(y, "tsp") <- c(ystart, yend, xfreq) :
>>>> #   invalid time series parameters specified
>>>>
>>>> The reason is in the rounding procedures for ystart and yend at the end
>>> of the stats::window function. For the 'foo' series the ystart and yend
>>> values are calculated as: c(20, 25), whereas for the 'bar' series, they
>>> become c(20, 30) although the window should be of the very same size in
>>> both cases. (A further discussion on the example is at:
>>> https://stackoverflow.com/questions/57928054 )
>>>> Should I report a bug or am I misunderstanding something?
>>>>
>>>> --
>>>> Johann R. Kleinbub, PhD
>>>> University of Padova
>>>> FISPPA Dep. - Section of Applied Psychology
>>>> Cell: +39 3495986373
>>>
>>>
>>>
>>> --
>>> Johann R. Kleinbub, PhD
>>> University of Padova
>>> FISPPA Dep. - Section of Applied Psychology
>>> Cell: +39 3495986373
>>>
>>>        [[alternative HTML version deleted]]
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>>
>


From rmh @end|ng |rom temp|e@edu  Fri Dec  6 18:46:39 2019
From: rmh @end|ng |rom temp|e@edu (Richard M. Heiberger)
Date: Fri, 6 Dec 2019 12:46:39 -0500
Subject: [Rd] inappropriate warning in latticeExtra
In-Reply-To: <CADfFDC4n7dH9wsf5YHRtOPyZPMRMVGLuFqZ-DcL2B+PFA0WJ+A@mail.gmail.com>
References: <CAGx1TMCADAAvL0wa6hyHSuRtrrpU1qFNvPpsaorRAtm6P0roaw@mail.gmail.com>
 <CADfFDC54=15F4F=9FC4QJdPBG+WyAt_SepWJ81FE0aJkP=XA-A@mail.gmail.com>
 <CAGx1TMBKiBFWuRr-_avryrqypmf_YtL_tvCi4hUNVnNCpmXM-A@mail.gmail.com>
 <CADfFDC4n7dH9wsf5YHRtOPyZPMRMVGLuFqZ-DcL2B+PFA0WJ+A@mail.gmail.com>
Message-ID: <CAGx1TMCFJYRf0gurRakdokGk-c41R5r=UZWQ4R8OD47dAJw+kA@mail.gmail.com>

This problem is still present in

> version
               _
platform       x86_64-w64-mingw32
arch           x86_64
os             mingw32
system         x86_64, mingw32
status         Under development (unstable)
major          4
minor          0.0
year           2019
month          12
day            03
svn rev        77513
language       R
version.string R Under development (unstable) (2019-12-03 r77513)
nickname       Unsuffered Consequences

Rich



On Sat, Jun 15, 2019 at 3:13 AM Deepayan Sarkar
<deepayan.sarkar at gmail.com> wrote:
>
> On Fri, Jun 14, 2019 at 6:42 PM Richard M. Heiberger <rmh at temple.edu> wrote:
> >
> > This is still not repaired in
> >  R version 3.6.0 Patched (2019-05-17 r76528)
> > > library(latticeExtra)
> > >  a <- xyplot(1 ~ 1)
> > > c(a,a)
> > Warning message:
> > In formals(fun) : argument is not a function
> >
> > Can we have it in R-3.6.1 that Peter just announced?
>
> Sorry I have been neglecting this (and some lattice bugs as well). I
> should get time to work on this after mid-July.
>
> -Deepayan
>
> >
> > Rich
> >
> > On Mon, Apr 2, 2018 at 4:08 AM Deepayan Sarkar
> > <deepayan.sarkar at gmail.com> wrote:
> > >
> > > On Fri, Mar 23, 2018 at 7:58 AM, Richard M. Heiberger <rmh at temple.edu> wrote:
> > > > The warning message in the last line of this email is incorrect.
> > > > This is behavior which Duncan Murdoch labeled a bug in
> > > >    https://stat.ethz.ch/pipermail/r-help/2017-December/450494.html
> > >
> > > Yes, sorry, this has been fixed in the r-forge sources for a while
> > > now, but I haven't had the time to finish up some other fixes and push
> > > an update to CRAN.
> > >
> > > Hopefully over the summer break.
> > >
> > > Regards,
> > > -Deepayan
> > >
> > >
> > > > This is a fresh install of R-devel (2018-03-21 r74436)
> > > >
> > > >
> > > >
> > > >
> > > > R Under development (unstable) (2018-03-21 r74436) -- "Unsuffered Consequences"
> > > > Copyright (C) 2018 The R Foundation for Statistical Computing
> > > > Platform: x86_64-w64-mingw32/x64 (64-bit)
> > > >
> > > > R is free software and comes with ABSOLUTELY NO WARRANTY.
> > > > You are welcome to redistribute it under certain conditions.
> > > > Type 'license()' or 'licence()' for distribution details.
> > > >
> > > >   Natural language support but running in an English locale
> > > >
> > > > R is a collaborative project with many contributors.
> > > > Type 'contributors()' for more information and
> > > > 'citation()' on how to cite R or R packages in publications.
> > > >
> > > > Type 'demo()' for some demos, 'help()' for on-line help, or
> > > > 'help.start()' for an HTML browser interface to help.
> > > > Type 'q()' to quit R.
> > > >
> > > >> library(latticeExtra)
> > > > Error in library(latticeExtra) :
> > > >   there is no package called ?latticeExtra?
> > > >> install.packages("latticeExtra")
> > > > Warning in install.packages("latticeExtra") :
> > > >   'lib = "C:/Program Files/R/R-devel/library"' is not writable
> > > > --- Please select a CRAN mirror for use in this session ---
> > > > also installing the dependency ?RColorBrewer?
> > > >
> > > > Warning: unable to access index for repository
> > > > http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.5:
> > > >   cannot open URL
> > > > 'http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.5/PACKAGES'
> > > > trying URL 'https://cran.wu.ac.at/bin/windows/contrib/3.5/RColorBrewer_1.1-2.zip'
> > > > Content type 'application/zip' length 55444 bytes (54 KB)
> > > > downloaded 54 KB
> > > >
> > > > trying URL 'https://cran.wu.ac.at/bin/windows/contrib/3.5/latticeExtra_0.6-28.zip'
> > > > Content type 'application/zip' length 2191524 bytes (2.1 MB)
> > > > downloaded 2.1 MB
> > > >
> > > > package ?RColorBrewer? successfully unpacked and MD5 sums checked
> > > > package ?latticeExtra? successfully unpacked and MD5 sums checked
> > > >
> > > > The downloaded binary packages are in
> > > >         C:\Users\rmh.DESKTOP-60G4CCO\AppData\Local\Temp\RtmpqA7Rqg\downloaded_packages
> > > >> library(latticeExtra)
> > > > Loading required package: lattice
> > > > Loading required package: RColorBrewer
> > > >> a <- xyplot(1 ~ 1)
> > > >> c(a,a)
> > > > Warning message:
> > > > In formals(fun) : argument is not a function
> > > >>
> > > >
> > > > ______________________________________________
> > > > R-devel at r-project.org mailing list
> > > > https://stat.ethz.ch/mailman/listinfo/r-devel


From w|||@|@nd@u @end|ng |rom gm@||@com  Fri Dec  6 22:02:59 2019
From: w|||@|@nd@u @end|ng |rom gm@||@com (Will L)
Date: Fri, 6 Dec 2019 16:02:59 -0500
Subject: [Rd] long vector support
Message-ID: <CAC-MUvsRCK1tSzhPjc_YzkOye3inNp3m8rL=mDnqZUoCOsqveg@mail.gmail.com>

All,


At first glance, a recent commit to R-devel (
https://github.com/wch/r-source/commit/2c182014ecc8c2407a89092c9162d86046bd18da)
appears to be related to long vector support. But as Henrik Bengtsson
points out at
https://github.com/HenrikBengtsson/Wishlist-for-R/issues/97#issuecomment-562659134,
writeBin() still prohibits long vectors. Are there any plans to add long
vector support to R 4.0.0?

x <- raw(2^31)
writeBin(x, con = nullfile())
# Error in writeBin(x, con = nullfile()) :
#  long vectors not supported yet: connections.c:4430

x <- raw(2^31)
con <- rawConnection(raw(0L), "w")
writeBin(raw(2^31), con = con)
# Error in writeBin(raw(2^31), con = con) :
#  long vectors not supported yet: connections.c:4430


Will

	[[alternative HTML version deleted]]


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Sat Dec  7 00:13:16 2019
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Sat, 7 Dec 2019 00:13:16 +0100
Subject: [Rd] inappropriate warning in latticeExtra
In-Reply-To: <CAGx1TMCFJYRf0gurRakdokGk-c41R5r=UZWQ4R8OD47dAJw+kA@mail.gmail.com>
References: <CAGx1TMCADAAvL0wa6hyHSuRtrrpU1qFNvPpsaorRAtm6P0roaw@mail.gmail.com>
 <CADfFDC54=15F4F=9FC4QJdPBG+WyAt_SepWJ81FE0aJkP=XA-A@mail.gmail.com>
 <CAGx1TMBKiBFWuRr-_avryrqypmf_YtL_tvCi4hUNVnNCpmXM-A@mail.gmail.com>
 <CADfFDC4n7dH9wsf5YHRtOPyZPMRMVGLuFqZ-DcL2B+PFA0WJ+A@mail.gmail.com>
 <CAGx1TMCFJYRf0gurRakdokGk-c41R5r=UZWQ4R8OD47dAJw+kA@mail.gmail.com>
Message-ID: <CADfFDC6OYj_4Kx24W1awWki533HgU91JzAgkYb7UD4mj+Vdz0A@mail.gmail.com>

On Fri 6 Dec, 2019, 6:46 PM Richard M. Heiberger, <rmh at temple.edu> wrote:

> This problem is still present in
>

Yes, my bad. I'm traveling till Monday, but will get an update out as soon
as possible after I'm back.

-Deepayan


> > version
>                _
> platform       x86_64-w64-mingw32
> arch           x86_64
> os             mingw32
> system         x86_64, mingw32
> status         Under development (unstable)
> major          4
> minor          0.0
> year           2019
> month          12
> day            03
> svn rev        77513
> language       R
> version.string R Under development (unstable) (2019-12-03 r77513)
> nickname       Unsuffered Consequences
>
> Rich
>
>
>
> On Sat, Jun 15, 2019 at 3:13 AM Deepayan Sarkar
> <deepayan.sarkar at gmail.com> wrote:
> >
> > On Fri, Jun 14, 2019 at 6:42 PM Richard M. Heiberger <rmh at temple.edu>
> wrote:
> > >
> > > This is still not repaired in
> > >  R version 3.6.0 Patched (2019-05-17 r76528)
> > > > library(latticeExtra)
> > > >  a <- xyplot(1 ~ 1)
> > > > c(a,a)
> > > Warning message:
> > > In formals(fun) : argument is not a function
> > >
> > > Can we have it in R-3.6.1 that Peter just announced?
> >
> > Sorry I have been neglecting this (and some lattice bugs as well). I
> > should get time to work on this after mid-July.
> >
> > -Deepayan
> >
> > >
> > > Rich
> > >
> > > On Mon, Apr 2, 2018 at 4:08 AM Deepayan Sarkar
> > > <deepayan.sarkar at gmail.com> wrote:
> > > >
> > > > On Fri, Mar 23, 2018 at 7:58 AM, Richard M. Heiberger <
> rmh at temple.edu> wrote:
> > > > > The warning message in the last line of this email is incorrect.
> > > > > This is behavior which Duncan Murdoch labeled a bug in
> > > > >    https://stat.ethz.ch/pipermail/r-help/2017-December/450494.html
> > > >
> > > > Yes, sorry, this has been fixed in the r-forge sources for a while
> > > > now, but I haven't had the time to finish up some other fixes and
> push
> > > > an update to CRAN.
> > > >
> > > > Hopefully over the summer break.
> > > >
> > > > Regards,
> > > > -Deepayan
> > > >
> > > >
> > > > > This is a fresh install of R-devel (2018-03-21 r74436)
> > > > >
> > > > >
> > > > >
> > > > >
> > > > > R Under development (unstable) (2018-03-21 r74436) -- "Unsuffered
> Consequences"
> > > > > Copyright (C) 2018 The R Foundation for Statistical Computing
> > > > > Platform: x86_64-w64-mingw32/x64 (64-bit)
> > > > >
> > > > > R is free software and comes with ABSOLUTELY NO WARRANTY.
> > > > > You are welcome to redistribute it under certain conditions.
> > > > > Type 'license()' or 'licence()' for distribution details.
> > > > >
> > > > >   Natural language support but running in an English locale
> > > > >
> > > > > R is a collaborative project with many contributors.
> > > > > Type 'contributors()' for more information and
> > > > > 'citation()' on how to cite R or R packages in publications.
> > > > >
> > > > > Type 'demo()' for some demos, 'help()' for on-line help, or
> > > > > 'help.start()' for an HTML browser interface to help.
> > > > > Type 'q()' to quit R.
> > > > >
> > > > >> library(latticeExtra)
> > > > > Error in library(latticeExtra) :
> > > > >   there is no package called ?latticeExtra?
> > > > >> install.packages("latticeExtra")
> > > > > Warning in install.packages("latticeExtra") :
> > > > >   'lib = "C:/Program Files/R/R-devel/library"' is not writable
> > > > > --- Please select a CRAN mirror for use in this session ---
> > > > > also installing the dependency ?RColorBrewer?
> > > > >
> > > > > Warning: unable to access index for repository
> > > > > http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.5:
> > > > >   cannot open URL
> > > > > '
> http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.5/PACKAGES'
> > > > > trying URL '
> https://cran.wu.ac.at/bin/windows/contrib/3.5/RColorBrewer_1.1-2.zip'
> > > > > Content type 'application/zip' length 55444 bytes (54 KB)
> > > > > downloaded 54 KB
> > > > >
> > > > > trying URL '
> https://cran.wu.ac.at/bin/windows/contrib/3.5/latticeExtra_0.6-28.zip'
> > > > > Content type 'application/zip' length 2191524 bytes (2.1 MB)
> > > > > downloaded 2.1 MB
> > > > >
> > > > > package ?RColorBrewer? successfully unpacked and MD5 sums checked
> > > > > package ?latticeExtra? successfully unpacked and MD5 sums checked
> > > > >
> > > > > The downloaded binary packages are in
> > > > >
>  C:\Users\rmh.DESKTOP-60G4CCO\AppData\Local\Temp\RtmpqA7Rqg\downloaded_packages
> > > > >> library(latticeExtra)
> > > > > Loading required package: lattice
> > > > > Loading required package: RColorBrewer
> > > > >> a <- xyplot(1 ~ 1)
> > > > >> c(a,a)
> > > > > Warning message:
> > > > > In formals(fun) : argument is not a function
> > > > >>
> > > > >
> > > > > ______________________________________________
> > > > > R-devel at r-project.org mailing list
> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Sat Dec  7 12:17:09 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Sat, 7 Dec 2019 12:17:09 +0100
Subject: [Rd] long vector support
In-Reply-To: <CAC-MUvsRCK1tSzhPjc_YzkOye3inNp3m8rL=mDnqZUoCOsqveg@mail.gmail.com>
References: <CAC-MUvsRCK1tSzhPjc_YzkOye3inNp3m8rL=mDnqZUoCOsqveg@mail.gmail.com>
Message-ID: <24043.35381.634233.282740@stat.math.ethz.ch>

>>>>> Will L 
>>>>>     on Fri, 6 Dec 2019 16:02:59 -0500 writes:

    > All, At first glance, a recent commit to R-devel (
    > https://github.com/wch/r-source/commit/2c182014ecc8c2407a89092c9162d86046bd18da)
    > appears to be related to long vector support.

yes, for a very limited case, with a very nice minimal
reproducible example and proper R bug report, where the change
was very simple indeed , PR#17665, i.e.
    https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17665

    > But as
    > Henrik Bengtsson points out at
    > https://github.com/HenrikBengtsson/Wishlist-for-R/issues/97#issuecomment-562659134,
    > writeBin() still prohibits long vectors. Are there any
    > plans to add long vector support to R 4.0.0?

well.. there *is* a lot of long vector support in R 3.x.y
already.

Where there are gaps,
1) we have to be told about (i.e. it should be a case where
   people at least have stumbled about it) -- preferably with
   form PR in R's bugzilla,  see https://www.r-project.org/bugs.html
   
2) sometimes a fix takes quite a bit of time, and we would close
   the case much more quickly if people looked at the case in
   detail and found *how* to fix it.

   [For the Matrix package and the case of sparse matrices,
    I'd be very happy if a C-savvy R developer would start
    collaborating with me to get this (incl interface to SuiteSparse)]

In the present case, it may be that a change does not take much
effort; my first try seems to work already .. and may just a bit
more safeguarding ..

So thank you, Will, for the reminder!

Martin Maechler
ETH Zurich  and  R Core Team


    > x <- raw(2^31)
    > writeBin(x, con = nullfile())
    > # Error in writeBin(x, con = nullfile()) :
    > #  long vectors not supported yet: connections.c:4430

    > x <- raw(2^31)
    > con <- rawConnection(raw(0L), "w")
    > writeBin(raw(2^31), con = con)
    > # Error in writeBin(raw(2^31), con = con) :
    > #  long vectors not supported yet: connections.c:4430


    > Will

    > [[alternative HTML version deleted]]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Sat Dec  7 19:55:36 2019
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (Karolis =?utf-8?Q?Koncevi=C4=8Dius?=)
Date: Sat, 7 Dec 2019 20:55:36 +0200
Subject: [Rd] Inconsistencies in wilcox.test
Message-ID: <20191207185536.b6cmmkzywwyuateq@PMW>

Hello,

Writing to share some things I've found about wilcox.test() that seem a
a bit inconsistent.

1. Inf values are not removed if paired=TRUE

# returns different results (Inf is removed):
wilcox.test(c(1,2,3,4), c(0,9,8,7))
wilcox.test(c(1,2,3,4), c(0,9,8,Inf))

# returns the same result (Inf is left as value with highest rank):
wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)

2. tolerance issues with paired=TRUE.

wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
# ...
# Warning:  cannot compute exact p-value with ties

wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
# ...
# no warning

3. Always 'x observations are missing' when paired=TRUE

wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
# ...
# Error:  not enough (finite) 'x' observations

4. No indication if normal approximation was used:

# different numbers, but same "method" name
wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)


 From all of these I am pretty sure the 1st one is likely unintended,
so attaching a small patch to adjust it. Can also try patching others if 
consensus is reached that the behavioiur has to be modified.

Kind regards,
Karolis Koncevi?ius.

---

Index: wilcox.test.R
===================================================================
--- wilcox.test.R  (revision 77540)
+++ wilcox.test.R  (working copy)
@@ -42,7 +42,7 @@
          if(paired) {
              if(length(x) != length(y))
                  stop("'x' and 'y' must have the same length")
-            OK <- complete.cases(x, y)
+            OK <- is.finite(x) & is.finite(y)
              x <- x[OK] - y[OK]
              y <- NULL
          }


From bbo|ker @end|ng |rom gm@||@com  Sat Dec  7 20:41:03 2019
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sat, 7 Dec 2019 14:41:03 -0500
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <20191207185536.b6cmmkzywwyuateq@PMW>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
Message-ID: <3271ba73-48d4-1061-92bd-d5839b45c744@gmail.com>


 Your second issue seems like a more or less unavoidable floating-point
computation issue.  The paired test operates by computing differences
between corresponding values of x and y.

  It's not impossible to try to detect "almost-ties" (by testing for
differences less than, say, sqrt(.Machine$double.eps)), but it's
delicate and somewhat subjective/problem-dependent.

  Example:

options(digits=20)
> unique(c(4,3,2)-c(3,2,1))
[1] 1
> unique(c(0.4,0.3,0.2)-c(0.3,0.2,0.1))
[1] 0.100000000000000033307 0.099999999999999977796 0.100000000000000005551

On 2019-12-07 1:55 p.m., Karolis Koncevi?ius wrote:
> Hello,
> 
> Writing to share some things I've found about wilcox.test() that seem a
> a bit inconsistent.
> 
> 1. Inf values are not removed if paired=TRUE
> 
> # returns different results (Inf is removed):
> wilcox.test(c(1,2,3,4), c(0,9,8,7))
> wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
> 
> # returns the same result (Inf is left as value with highest rank):
> wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
> wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)
> 
> 2. tolerance issues with paired=TRUE.
> 
> wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
> # ...
> # Warning:? cannot compute exact p-value with ties
> 
> wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
> # ...
> # no warning
> 
> 3. Always 'x observations are missing' when paired=TRUE
> 
> wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
> # ...
> # Error:? not enough (finite) 'x' observations
> 
> 4. No indication if normal approximation was used:
> 
> # different numbers, but same "method" name
> wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
> wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
> 
> 
> From all of these I am pretty sure the 1st one is likely unintended,
> so attaching a small patch to adjust it. Can also try patching others if
> consensus is reached that the behavioiur has to be modified.
> 
> Kind regards,
> Karolis Koncevi?ius.
> 
> ---
> 
> Index: wilcox.test.R
> ===================================================================
> --- wilcox.test.R? (revision 77540)
> +++ wilcox.test.R? (working copy)
> @@ -42,7 +42,7 @@
> ???????? if(paired) {
> ???????????? if(length(x) != length(y))
> ???????????????? stop("'x' and 'y' must have the same length")
> -??????????? OK <- complete.cases(x, y)
> +??????????? OK <- is.finite(x) & is.finite(y)
> ???????????? x <- x[OK] - y[OK]
> ???????????? y <- NULL
> ???????? }
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Sat Dec  7 21:38:34 2019
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (Karolis =?utf-8?Q?Koncevi=C4=8Dius?=)
Date: Sat, 7 Dec 2019 22:38:34 +0200
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <3271ba73-48d4-1061-92bd-d5839b45c744@gmail.com>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
 <3271ba73-48d4-1061-92bd-d5839b45c744@gmail.com>
Message-ID: <20191207203834.uedqgm2xy4x556yj@PMW>

Thank you for responding, and so quickly at that.

Yes, I do understand that this is a floating point issue.
However, since wilcox.test() works on ranks this might be a bit 
dangerous in my opinion. Maybe more so than for magnitude based tests.
Any small precision error will be ranked and it becomes a matter of 
errors being systematically >0 or <0 in one group.

Here is one example that I do not like:

x <- seq(0.9, 0.2, -0.1)
y <- seq(0.8, 0.1, -0.1)
wilcox.test(x, y, paired=TRUE, mu=0.1)

   Wilcoxon signed rank test with continuity correction

   data:  x and y
   V = 0, p-value = 0.01471
   alternative hypothesis: true location shift is not equal to 0.1
   # ... Warning, due to some precision deviations being duplicated ...

x-y
[1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1

sign(x-y - 0.1)
[1] -1 -1 -1 -1 -1 -1 -1  0


t.test() uses .Machine$double.eps with stderr and avoids this issue:

t.test(x, y, paired=TRUE, mu=0.1)
   Error in t.test.default(x, y, paired = TRUE, mu = 0.1) :
     data are essentially constant

On 2019-12-07 14:41, Ben Bolker wrote:
>
> Your second issue seems like a more or less unavoidable floating-point
>computation issue.  The paired test operates by computing differences
>between corresponding values of x and y.
>
>  It's not impossible to try to detect "almost-ties" (by testing for
>differences less than, say, sqrt(.Machine$double.eps)), but it's
>delicate and somewhat subjective/problem-dependent.
>
>  Example:
>
>options(digits=20)
>> unique(c(4,3,2)-c(3,2,1))
>[1] 1
>> unique(c(0.4,0.3,0.2)-c(0.3,0.2,0.1))
>[1] 0.100000000000000033307 0.099999999999999977796 0.100000000000000005551
>
>On 2019-12-07 1:55 p.m., Karolis Koncevi?ius wrote:
>> Hello,
>>
>> Writing to share some things I've found about wilcox.test() that seem a
>> a bit inconsistent.
>>
>> 1. Inf values are not removed if paired=TRUE
>>
>> # returns different results (Inf is removed):
>> wilcox.test(c(1,2,3,4), c(0,9,8,7))
>> wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
>>
>> # returns the same result (Inf is left as value with highest rank):
>> wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
>> wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)
>>
>> 2. tolerance issues with paired=TRUE.
>>
>> wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
>> # ...
>> # Warning:? cannot compute exact p-value with ties
>>
>> wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
>> # ...
>> # no warning
>>
>> 3. Always 'x observations are missing' when paired=TRUE
>>
>> wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
>> # ...
>> # Error:? not enough (finite) 'x' observations
>>
>> 4. No indication if normal approximation was used:
>>
>> # different numbers, but same "method" name
>> wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
>> wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
>>
>>
>> From all of these I am pretty sure the 1st one is likely unintended,
>> so attaching a small patch to adjust it. Can also try patching others if
>> consensus is reached that the behavioiur has to be modified.
>>
>> Kind regards,
>> Karolis Koncevi?ius.
>>
>> ---
>>
>> Index: wilcox.test.R
>> ===================================================================
>> --- wilcox.test.R? (revision 77540)
>> +++ wilcox.test.R? (working copy)
>> @@ -42,7 +42,7 @@
>> ???????? if(paired) {
>> ???????????? if(length(x) != length(y))
>> ???????????????? stop("'x' and 'y' must have the same length")
>> -??????????? OK <- complete.cases(x, y)
>> +??????????? OK <- is.finite(x) & is.finite(y)
>> ???????????? x <- x[OK] - y[OK]
>> ???????????? y <- NULL
>> ???????? }
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>______________________________________________
>R-devel at r-project.org mailing list
>https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Sat Dec  7 21:59:01 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Sat, 7 Dec 2019 21:59:01 +0100
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <20191207185536.b6cmmkzywwyuateq@PMW>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
Message-ID: <20191207205901.4265F22877@v-lynne.math.ethz.ch>

>>>>> Karolis Koncevi?ius 
>>>>>     on Sat, 7 Dec 2019 20:55:36 +0200 writes:

    > Hello,
    > Writing to share some things I've found about wilcox.test() that seem a
    > a bit inconsistent.

    > 1. Inf values are not removed if paired=TRUE

    > # returns different results (Inf is removed):
    > wilcox.test(c(1,2,3,4), c(0,9,8,7))
    > wilcox.test(c(1,2,3,4), c(0,9,8,Inf))

    > # returns the same result (Inf is left as value with highest rank):
    > wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
    > wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)

Now which of the two cases do you consider correct ?

IHMO, the 2nd one is correct: it is exactly one property of the
*robustness* of the wilcoxon test and very desirable that any
(positive) outlier is treated the same as just "the largest
value" and the test statistic (and hence the p-value) should not
change.

So I think the first case is wrong, notably if modified, (such
that the last  y  is the overall maximal value (slightly larger sample):

> wilcox.test(1:7, 1/8+ c(9:4, 12))

	Wilcoxon rank sum test

data:  1:7 and 1/8 + c(9:4, 12)
W = 6, p-value = 0.01748
alternative hypothesis: true location shift is not equal to 0

> wilcox.test(1:7, 1/8+ c(9:4, 10000))

	Wilcoxon rank sum test

data:  1:7 and 1/8 + c(9:4, 10000)
W = 6, p-value = 0.01748
alternative hypothesis: true location shift is not equal to 0

> wilcox.test(1:7, 1/8+ c(9:4, Inf))

	Wilcoxon rank sum test

data:  1:7 and 1/8 + c(9:4, Inf)
W = 6, p-value = 0.03497
alternative hypothesis: true location shift is not equal to 0

The  Inf  case should definitely give the same as the  10'000 case.
That's exactly one property of a robust statistic.

Thank you, Karolis, this is pretty embarrassing to only be detected now after 25+ years of R in use ...

The correct fix starts with replacing the  is.finite()  by   !is.na() and keep the 'Inf' in the rank computations...
(but then probably also deal with the case of more than one Inf, notably the  Inf - Inf  "exception" which is not triggered by your example...)


---

Ben addressed the "rounding" / numerical issues unavoidable for
the other problems.

    > 2. tolerance issues with paired=TRUE.

    > wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
    > # ...
    > # Warning:  cannot compute exact p-value with ties

    > wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
    > # ...
    > # no warning

    > 3. Always 'x observations are missing' when paired=TRUE

    > wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
    > # ...
    > # Error:  not enough (finite) 'x' observations

    > 4. No indication if normal approximation was used:

    > # different numbers, but same "method" name
    > wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
    > wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)


    > From all of these I am pretty sure the 1st one is likely unintended,
    > so attaching a small patch to adjust it. Can also try patching others if 
    > consensus is reached that the behavioiur has to be modified.

    > Kind regards,
    > Karolis Koncevi?ius.

    > ---

    > Index: wilcox.test.R
    > ===================================================================
    > --- wilcox.test.R  (revision 77540)
    > +++ wilcox.test.R  (working copy)
    > @@ -42,7 +42,7 @@
    > if(paired) {
    > if(length(x) != length(y))
    > stop("'x' and 'y' must have the same length")
    > -            OK <- complete.cases(x, y)
    > +            OK <- is.finite(x) & is.finite(y)
    > x <- x[OK] - y[OK]
    > y <- NULL
    > }

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Sat Dec  7 22:18:58 2019
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (Karolis =?utf-8?Q?Koncevi=C4=8Dius?=)
Date: Sat, 7 Dec 2019 23:18:58 +0200
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <20191207205901.4265F22877@v-lynne.math.ethz.ch>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
 <20191207205901.4265F22877@v-lynne.math.ethz.ch>
Message-ID: <20191207211858.dpnqeslbln5caz2v@PMW>

Thank you for a fast response. Nice to see this mailing list being so 
alive.

Regarding Inf issue: I agree with your assessment that Inf should not be 
removed. The code gave me an impression that Inf values were 
intentionally removed (since is.finite() was used everywhere, except for 
paired case). I will try to adjust my patch according to your feedback.

One more thing: it seems like you assumed that issues 2:4 are all 
related to machine precision, which is not the case - only 2nd issue is.
Just wanted to draw this to your attention, in case you might have some 
feedback and guidelines about issues 3 and 4 as well.



On 2019-12-07 21:59, Martin Maechler wrote:
>>>>>> Karolis Koncevi?ius
>>>>>>     on Sat, 7 Dec 2019 20:55:36 +0200 writes:
>
>    > Hello,
>    > Writing to share some things I've found about wilcox.test() that seem a
>    > a bit inconsistent.
>
>    > 1. Inf values are not removed if paired=TRUE
>
>    > # returns different results (Inf is removed):
>    > wilcox.test(c(1,2,3,4), c(0,9,8,7))
>    > wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
>
>    > # returns the same result (Inf is left as value with highest rank):
>    > wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
>    > wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)
>
>Now which of the two cases do you consider correct ?
>
>IHMO, the 2nd one is correct: it is exactly one property of the
>*robustness* of the wilcoxon test and very desirable that any
>(positive) outlier is treated the same as just "the largest
>value" and the test statistic (and hence the p-value) should not
>change.
>
>So I think the first case is wrong, notably if modified, (such
>that the last  y  is the overall maximal value (slightly larger sample):
>
>> wilcox.test(1:7, 1/8+ c(9:4, 12))
>
>	Wilcoxon rank sum test
>
>data:  1:7 and 1/8 + c(9:4, 12)
>W = 6, p-value = 0.01748
>alternative hypothesis: true location shift is not equal to 0
>
>> wilcox.test(1:7, 1/8+ c(9:4, 10000))
>
>	Wilcoxon rank sum test
>
>data:  1:7 and 1/8 + c(9:4, 10000)
>W = 6, p-value = 0.01748
>alternative hypothesis: true location shift is not equal to 0
>
>> wilcox.test(1:7, 1/8+ c(9:4, Inf))
>
>	Wilcoxon rank sum test
>
>data:  1:7 and 1/8 + c(9:4, Inf)
>W = 6, p-value = 0.03497
>alternative hypothesis: true location shift is not equal to 0
>
>The  Inf  case should definitely give the same as the  10'000 case.
>That's exactly one property of a robust statistic.
>
>Thank you, Karolis, this is pretty embarrassing to only be detected now after 25+ years of R in use ...
>
>The correct fix starts with replacing the  is.finite()  by   !is.na() and keep the 'Inf' in the rank computations...
>(but then probably also deal with the case of more than one Inf, notably the  Inf - Inf  "exception" which is not triggered by your example...)
>
>
>---
>
>Ben addressed the "rounding" / numerical issues unavoidable for
>the other problems.
>
>    > 2. tolerance issues with paired=TRUE.
>
>    > wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
>    > # ...
>    > # Warning:  cannot compute exact p-value with ties
>
>    > wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
>    > # ...
>    > # no warning
>
>    > 3. Always 'x observations are missing' when paired=TRUE
>
>    > wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
>    > # ...
>    > # Error:  not enough (finite) 'x' observations
>
>    > 4. No indication if normal approximation was used:
>
>    > # different numbers, but same "method" name
>    > wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
>    > wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
>
>
>    > From all of these I am pretty sure the 1st one is likely unintended,
>    > so attaching a small patch to adjust it. Can also try patching others if
>    > consensus is reached that the behavioiur has to be modified.
>
>    > Kind regards,
>    > Karolis Koncevi?ius.
>
>    > ---
>
>    > Index: wilcox.test.R
>    > ===================================================================
>    > --- wilcox.test.R  (revision 77540)
>    > +++ wilcox.test.R  (working copy)
>    > @@ -42,7 +42,7 @@
>    > if(paired) {
>    > if(length(x) != length(y))
>    > stop("'x' and 'y' must have the same length")
>    > -            OK <- complete.cases(x, y)
>    > +            OK <- is.finite(x) & is.finite(y)
>    > x <- x[OK] - y[OK]
>    > y <- NULL
>    > }
>
>    > ______________________________________________
>    > R-devel at r-project.org mailing list
>    > https://stat.ethz.ch/mailman/listinfo/r-devel


From |g@ut|er @end|ng |rom gm@||@com  Sat Dec  7 22:32:27 2019
From: |g@ut|er @end|ng |rom gm@||@com (Laurent Gautier)
Date: Sat, 7 Dec 2019 16:32:27 -0500
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
Message-ID: <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>

Thanks for the quick response Tomas.

The same error is indeed happening when trying to have a zero-length
variable name in an environment. The surprising bit is then "why is this
happening during parsing" (that is why are variables assigned to an
environment) ?

We are otherwise aware that the error is not occurring in the R console,
but can be traced to a call to R_ParseVector() in R's C API:(
https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509
).

Our specific setup is calling an embedded R from Python, using the cffi
library. An error on end was the first possibility considered, but the
puzzling specificity of the error (as shown below other parsing errors are
handled properly) and the difficulty tracing what is in happening in
R_ParseVector() made me ask whether someone on this list had a suggestion
about the possible issue"

```

>>> import rpy2.rinterface as ri>>> ri.initr()>>> e = ri.parse("list(''=1+") ---------------------------------------------------------------------------RParsingError                             Traceback (most recent call last)
>>> e = ri.parse("list(''=123") R[write to console]: Error: attempt to use zero-length variable name
R[write to console]: Fatal error: unable to initialize the JIT

*** stack smashing detected ***: <unknown> terminated
```


Le lun. 2 d?c. 2019 ? 06:37, Tomas Kalibera <tomas.kalibera at gmail.com> a
?crit :

> Dear Laurent,
>
> could you please provide a complete reproducible example where parsing
> results in a crash of R? Calling parse(text="list(''=123") from R works
> fine for me (gives Error: attempt to use zero-length variable name).
>
> I don't think the problem you observed could be related to the memory
> leak. The leak is on the heap, not stack.
>
> Zero-length names of elements in a list are allowed. They are not the
> same thing as zero-length variables in an environment. If you try to
> convert "lst" from your example to an environment, you would get the
> error (attempt to use zero-length variable name).
>
> Best
> Tomas
>
>
> On 11/30/19 11:55 PM, Laurent Gautier wrote:
> > Hi again,
> >
> > Beside R_ParseVector()'s possible inconsistent behavior, R's handling of
> > zero-length named elements does not seem consistent either:
> >
> > ```
> >> lst <- list()
> >> lst[[""]] <- 1
> >> names(lst)
> > [1] ""
> >> list("" = 1)
> > Error: attempt to use zero-length variable name
> > ```
> >
> > Should the parser be made to accept as valid what is otherwise possible
> > when using `[[<` ?
> >
> >
> > Best,
> >
> > Laurent
> >
> >
> >
> > Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a
> ?crit :
> >
> >> I found the following code comment in `src/main/gram.c`:
> >>
> >> ```
> >>
> >> /* Memory leak
> >>
> >> yyparse(), as generated by bison, allocates extra space for the parser
> >> stack using malloc(). Unfortunately this means that there is a memory
> >> leak in case of an R error (long-jump). In principle, we could define
> >> yyoverflow() to relocate the parser stacks for bison and allocate say on
> >> the R heap, but yyoverflow() is undocumented and somewhat complicated
> >> (we would have to replicate some macros from the generated parser here).
> >> The same problem exists at least in the Rd and LaTeX parsers in tools.
> >> */
> >>
> >> ```
> >>
> >> Could this be related to be issue ?
> >>
> >> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com> a
> >> ?crit :
> >>
> >>> Hi,
> >>>
> >>> The behavior of
> >>> ```
> >>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
> >>> ```
> >>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
> >>> depending on the string to be parsed.
> >>>
> >>> Trying to parse a string such as `"list(''=1+"` sets the
> >>> `ParseStatus` to incomplete parsing error but trying to parse
> >>> `"list(''=123"` will result in R sending a message to the console
> (followed but a crash):
> >>>
> >>> ```
> >>> R[write to console]: Error: attempt to use zero-length variable
> nameR[write to console]: Fatal error: unable to initialize the JIT*** stack
> smashing detected ***: <unknown> terminated
> >>> ```
> >>>
> >>> Is there a reason for the difference in behavior, and is there a
> workaround ?
> >>>
> >>> Thanks,
> >>>
> >>>
> >>> Laurent
> >>>
> >>>
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>

	[[alternative HTML version deleted]]


From We|g@nd@Stephen @end|ng |rom m@yo@edu  Sat Dec  7 23:05:24 2019
From: We|g@nd@Stephen @end|ng |rom m@yo@edu (Weigand, Stephen D.)
Date: Sat, 07 Dec 2019 22:05:24 +0000
Subject: [Rd] What should dnorm(0, 0, -Inf) return?
Message-ID: <28fddd$csrn33@ironport10.mayo.edu>

Hi,
Apropos of a recent Inf question, I've previously wondered if dnorm "does the right thing" with

  dnorm(0, 0, -Inf)

which gives zero. Should that be zero or NaN (or NA)? 

The help says "'sd < 0' is an error and returns 'NaN'" and since -Inf < 0 is TRUE, then... is this a bug?

Thank you,
Stephen
Rochester, MN USA


From @zwj|08 @end|ng |rom gm@||@com  Sat Dec  7 23:40:12 2019
From: @zwj|08 @end|ng |rom gm@||@com (Wang Jiefei)
Date: Sat, 7 Dec 2019 17:40:12 -0500
Subject: [Rd] What should dnorm(0, 0, -Inf) return?
In-Reply-To: <28fddd$csrn33@ironport10.mayo.edu>
References: <28fddd$csrn33@ironport10.mayo.edu>
Message-ID: <CAGiFhPP4AVZnZUfFo=N5CPJZCUSgL6sWUROaT8fXAFRvKqpFVA@mail.gmail.com>

Good question, I cannot speak for R's developers but I would like to
provide some information on the problem. Here are the first few lines of
the dnorm function located at src\nmath\dnorm.c:

```
double dnorm4(double x, double mu, double sigma, int give_log)
{
#ifdef IEEE_754
    if (ISNAN(x) || ISNAN(mu) || ISNAN(sigma))
return x + mu + sigma;
#endif
    if(!R_FINITE(sigma)) return R_D__0;
    if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
    if (sigma <= 0) {
    if (sigma < 0) ML_ERR_return_NAN;
        /* sigma == 0 */
        return (x == mu) ? ML_POSINF : R_D__0;
    }
    ....
}
```

You can clearly see where the problem is. I think either the document or
the code needs a modification.

Best,
Jiefei

On Sat, Dec 7, 2019 at 5:05 PM Weigand, Stephen D. via R-devel <
r-devel at r-project.org> wrote:

> Hi,
> Apropos of a recent Inf question, I've previously wondered if dnorm "does
> the right thing" with
>
>   dnorm(0, 0, -Inf)
>
> which gives zero. Should that be zero or NaN (or NA)?
>
> The help says "'sd < 0' is an error and returns 'NaN'" and since -Inf < 0
> is TRUE, then... is this a bug?
>
> Thank you,
> Stephen
> Rochester, MN USA
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From pd@|gd @end|ng |rom gm@||@com  Sun Dec  8 12:11:50 2019
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Sun, 8 Dec 2019 12:11:50 +0100
Subject: [Rd] What should dnorm(0, 0, -Inf) return?
In-Reply-To: <CAGiFhPP4AVZnZUfFo=N5CPJZCUSgL6sWUROaT8fXAFRvKqpFVA@mail.gmail.com>
References: <28fddd$csrn33@ironport10.mayo.edu>
 <CAGiFhPP4AVZnZUfFo=N5CPJZCUSgL6sWUROaT8fXAFRvKqpFVA@mail.gmail.com>
Message-ID: <2E7FB3D3-4FB2-49CF-983D-77735A79D7AD@gmail.com>

Yes, that looks like a bug and an easily fixable one too.

However, I spy another issue: Why do we check the !R_FINITE(x) && mu == x before checking for sd < 0 ? The difference is whether we 

return ML_NAN;
or
ML_ERR_return_NAN;

but surely negative sd should always be an error?

I'd be inclined to do

    if (sigma < 0) ML_ERR_return_NAN;
    if(!R_FINITE(sigma)) return R_D__0;
    if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
    if (sigma == 0) 
        return (x == mu) ? ML_POSINF : R_D__0;
    x = (x - mu) / sigma;


(Ping Martin...)

-pd

> On 7 Dec 2019, at 23:40 , Wang Jiefei <szwjf08 at gmail.com> wrote:
> 
> Good question, I cannot speak for R's developers but I would like to
> provide some information on the problem. Here are the first few lines of
> the dnorm function located at src\nmath\dnorm.c:
> 
> ```
> double dnorm4(double x, double mu, double sigma, int give_log)
> {
> #ifdef IEEE_754
>    if (ISNAN(x) || ISNAN(mu) || ISNAN(sigma))
> return x + mu + sigma;
> #endif
>    if(!R_FINITE(sigma)) return R_D__0;
>    if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
>    if (sigma <= 0) {
>    if (sigma < 0) ML_ERR_return_NAN;
>        /* sigma == 0 */
>        return (x == mu) ? ML_POSINF : R_D__0;
>    }
>    ....
> }
> ```
> 
> You can clearly see where the problem is. I think either the document or
> the code needs a modification.
> 
> Best,
> Jiefei
> 
> On Sat, Dec 7, 2019 at 5:05 PM Weigand, Stephen D. via R-devel <
> r-devel at r-project.org> wrote:
> 
>> Hi,
>> Apropos of a recent Inf question, I've previously wondered if dnorm "does
>> the right thing" with
>> 
>>  dnorm(0, 0, -Inf)
>> 
>> which gives zero. Should that be zero or NaN (or NA)?
>> 
>> The help says "'sd < 0' is an error and returns 'NaN'" and since -Inf < 0
>> is TRUE, then... is this a bug?
>> 
>> Thank you,
>> Stephen
>> Rochester, MN USA
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Dec  8 21:04:46 2019
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 8 Dec 2019 15:04:46 -0500
Subject: [Rd] Maybe bug? Using non-integer frequencies in stats::ts
In-Reply-To: <624c28a5-e428-0655-9fe7-c91baae72723@gmail.com>
References: <CALTZUioLKO3ynX0swMnwygMYOxtTS2UvPbCP1K4NDPyrfr+x4A@mail.gmail.com>
 <CALTZUirEBDc_jqebSuvLbpEh3h0J8HJp6g0BRGvmpJHYcODRsg@mail.gmail.com>
 <3867dc12-07c3-b2cc-d575-f3450a5dab35@gmail.com>
 <CALTZUirin0md5V2-=otM8vGN_m-XEefk50Y8uGFBe43CB5p87w@mail.gmail.com>
 <624c28a5-e428-0655-9fe7-c91baae72723@gmail.com>
Message-ID: <64f7b867-a759-baaa-fbb9-0a80ffbb04eb@gmail.com>

I've now posted this as an enhancement request:

https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17669

On 06/12/2019 12:35 p.m., Duncan Murdoch wrote:
> To R-devel:
> 
> I've sent this to Johann privately already; just in case anyone else is
> interested in this issue, here's what I wrote:
> 
> Just started looking into it, and discovered this paragraph in ?ts:
> 
> "The value of argument frequency is used when the series is sampled an
> integral number of times in each unit time interval. For example, one
> could use a value of 7 for frequency when the data are sampled daily,
> and the natural time period is a week, or 12 when the data are sampled
> monthly and the natural time period is a year. Values of 4 and 12 are
> assumed in (e.g.) print methods to imply a quarterly and monthly series
> respectively."
> 
> That says that frequency will be a positive integer, so frequency=0.2
> was not intended to be covered, and I'd say it's not exactly a bug that
> it doesn't work.  (It might be called a bug that there's no error message.)
> 
> On the other hand, it comes close to working, and it seems like allowing
> frequency=0.2 would be a useful addition.  I'm going to keep looking,
> and see how hard it would be to get this to work properly.  If it
> doesn't break other things, I may submit this as an enhancement.
> 
> Duncan Murdoch
> 
> 
> On 06/12/2019 10:00 a.m., Johann R. Kleinbub wrote:
>> Thank you for the quick follow up, Duncan.
>> Unfortunately extend=TRUE is called internally in various instances such as
>> when replacing parts of the time-series with  window<-.ts
>> Consider the following examples of time series with ugly values:
>> x = 1:22
>> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2) # a ts of 525 cycles
>> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2) # a ts of 525 cycles
>> starting 5 cycles later than foo
>> qux = ts(x, start = 2.5, end = 102.5, frequency = 0.2) # a ts of 500 cycles
>> starting 5 cycles later than foo
>>
>> # extraction works fine
>> window(foo, start = 20, end = 30)  # works fine
>> window(bar, start = 20, end = 30)  # works fine
>> window(qux, start = 20, end = 30)  # works fine
>>
>> # assignment fails in different ways for bar and qux
>> window(foo, start = 20, end = 30) <- NA  # works fine
>> window(bar, start = 20, end = 30) <- NA  # ERROR: "invalid time series
>> parameters specified"
>> window(qux, start = 20, end = 30) <- NA  # ERROR: "times to be replaced do
>> not match"
>>
>> If extraction works fine, there's no reason why replacing the values should
>> fail.
>> I don't have an account on bugs.r-project.org yet. I'd be available to do
>> the report if I'm assigned one.
>> Best,
>> Johann
>>
>> On Thu, 5 Dec 2019 at 17:46, Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>>
>>> On 05/12/2019 11:00 a.m., Johann R. Kleinbub wrote:
>>>> It's been three months without an answer, is it ok to thread bump?
>>>> Would someone provide a pointer?
>>>
>>> I agree it's a bug, and agree with your analysis.  You should report it
>>> on bugs.r-project.org.  (If you don't have an account there, let us
>>> know, and either someone will give you one, or someone will report it
>>> for you.)
>>>
>>> As a workaround, I don't see it happening with extend=FALSE, but of
>>> course that might not suit your needs in general.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>
>>>>
>>>> Thank you for your consideration,
>>>> Johann
>>>>
>>>>
>>>> On Mon, 16 Sep 2019 at 15:53, Johann R. Kleinbub <
>>> johann.kleinbub at gmail.com>
>>>> wrote:
>>>>>
>>>>> I am developing a package to analyse physiological time-series and I
>>>> thought that the most reliable and robust solution was to base it on the
>>>> native stats::ts class. In my domain it is common to express series
>>>> frequencies as samples-per-second. So ts(..., frequency=10) would mean a
>>>> signal sampled 10 times every second, and ts(..., frequency = 1) a signal
>>>> sampled every second. Following this logic, a few slower signals are
>>>> sampled every 5 seconds (or more), resulting in a frequency of e.g. 0.2
>>>>> Nowhere in the documentation is stated that the frequency must be an
>>>> integer value, but using fractional values gives inconsistent results.
>>>>> For instance, in this example, foo and bar are identical, just with
>>>> start-end values shifted by 1. Yet when extracting an arbitrary window,
>>> the
>>>> 'bar' series gives error.
>>>>>
>>>>> x = 1:22
>>>>> foo = ts(x, start = 1.5, end = 106.5, frequency = 0.2)
>>>>> bar = ts(x, start = 2.5, end = 107.5, frequency = 0.2)
>>>>>
>>>>> window(foo, start = 20, end = 30, extend=TRUE)
>>>>>
>>>>> # Time Series:
>>>>> # Start = 20
>>>>> # End = 25
>>>>> # Frequency = 0.2
>>>>> # [1] 5 6
>>>>>
>>>>> window(bar, start = 20, end = 30, extend=TRUE)
>>>>>
>>>>> # Error in attr(y, "tsp") <- c(ystart, yend, xfreq) :
>>>>> #   invalid time series parameters specified
>>>>>
>>>>> The reason is in the rounding procedures for ystart and yend at the end
>>>> of the stats::window function. For the 'foo' series the ystart and yend
>>>> values are calculated as: c(20, 25), whereas for the 'bar' series, they
>>>> become c(20, 30) although the window should be of the very same size in
>>>> both cases. (A further discussion on the example is at:
>>>> https://stackoverflow.com/questions/57928054 )
>>>>> Should I report a bug or am I misunderstanding something?
>>>>>
>>>>> --
>>>>> Johann R. Kleinbub, PhD
>>>>> University of Padova
>>>>> FISPPA Dep. - Section of Applied Psychology
>>>>> Cell: +39 3495986373
>>>>
>>>>
>>>>
>>>> --
>>>> Johann R. Kleinbub, PhD
>>>> University of Padova
>>>> FISPPA Dep. - Section of Applied Psychology
>>>> Cell: +39 3495986373
>>>>
>>>>         [[alternative HTML version deleted]]
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>>
>>
>


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Dec  9 08:49:26 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 9 Dec 2019 08:49:26 +0100
Subject: [Rd] What should dnorm(0, 0, -Inf) return?
In-Reply-To: <2E7FB3D3-4FB2-49CF-983D-77735A79D7AD@gmail.com>
References: <28fddd$csrn33@ironport10.mayo.edu>
 <CAGiFhPP4AVZnZUfFo=N5CPJZCUSgL6sWUROaT8fXAFRvKqpFVA@mail.gmail.com>
 <2E7FB3D3-4FB2-49CF-983D-77735A79D7AD@gmail.com>
Message-ID: <24045.64646.983266.213654@stat.math.ethz.ch>

>>>>> peter dalgaard 
>>>>>     on Sun, 8 Dec 2019 12:11:50 +0100 writes:

    > Yes, that looks like a bug and an easily fixable one too.

agreed.

    > However, I spy another issue: Why do we check the
    > !R_FINITE(x) && mu == x before checking for sd < 0 ? The
    > difference is whether we

    > return ML_NAN; or ML_ERR_return_NAN;

    > but surely negative sd should always be an error?

    > I'd be inclined to do

    > if (sigma < 0) ML_ERR_return_NAN;
    > if(!R_FINITE(sigma)) return R_D__0;
    > if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
    > if (sigma == 0) 
    >    return (x == mu) ? ML_POSINF : R_D__0;
    > x = (x - mu) / sigma;


    > (Ping Martin...)

I think you are spot on, Peter.
All of this code has a longish history, with incremental border
case improvements.
Let's hope (somewhat unrealistically) this is the last one for
dnorm().

NB: dlnorm() and some of the gamma/chisq/.. may need a
    similar adjustment

Lastly, regression tests for this
(either in  tests/d-p-q-r-tests.{R,Rout.save}
 or easier in reg-tests-1d.R)  should be added too.

    > -pd

    >> On 7 Dec 2019, at 23:40 , Wang Jiefei <szwjf08 at gmail.com> wrote:
    >> 
    >> Good question, I cannot speak for R's developers but I would like to
    >> provide some information on the problem. Here are the first few lines of
    >> the dnorm function located at src\nmath\dnorm.c:
    >> 
    >> ```
    >> double dnorm4(double x, double mu, double sigma, int give_log)
    >> {
    >> #ifdef IEEE_754
    >> if (ISNAN(x) || ISNAN(mu) || ISNAN(sigma))
    >> return x + mu + sigma;
    >> #endif
    >> if(!R_FINITE(sigma)) return R_D__0;
    >> if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
    >> if (sigma <= 0) {
    >> if (sigma < 0) ML_ERR_return_NAN;
    >> /* sigma == 0 */
    >> return (x == mu) ? ML_POSINF : R_D__0;
    >> }
    >> ....
    >> }
    >> ```
    >> 
    >> You can clearly see where the problem is. I think either the document or
    >> the code needs a modification.
    >> 
    >> Best,
    >> Jiefei
    >> 
    >> On Sat, Dec 7, 2019 at 5:05 PM Weigand, Stephen D. via R-devel <
    >> r-devel at r-project.org> wrote:
    >> 
    >>> Hi,
    >>> Apropos of a recent Inf question, I've previously wondered if dnorm "does
    >>> the right thing" with
    >>> 
    >>> dnorm(0, 0, -Inf)
    >>> 
    >>> which gives zero. Should that be zero or NaN (or NA)?
    >>> 
    >>> The help says "'sd < 0' is an error and returns 'NaN'" and since -Inf < 0
    >>> is TRUE, then... is this a bug?
    >>> 
    >>> Thank you,
    >>> Stephen
    >>> Rochester, MN USA
    >>> 
    >>> ______________________________________________
    >>> R-devel at r-project.org mailing list
    >>> https://stat.ethz.ch/mailman/listinfo/r-devel
    >>> 
    >> 
    >> [[alternative HTML version deleted]]
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel

    > -- 
    > Peter Dalgaard, Professor,
    > Center for Statistics, Copenhagen Business School
    > Solbjerg Plads 3, 2000 Frederiksberg, Denmark
    > Phone: (+45)38153501
    > Office: A 4.23
    > Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From ruz@nk|n @end|ng |rom m@th@n@c@ru  Mon Dec  9 03:10:10 2019
From: ruz@nk|n @end|ng |rom m@th@n@c@ru (Pavel S. Ruzankin)
Date: Mon, 9 Dec 2019 09:10:10 +0700
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <20191207185536.b6cmmkzywwyuateq@PMW>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
Message-ID: <df488fee-d28f-6e89-551b-f55e8060130e@math.nsc.ru>

I'd like to ask the developers to include some exact computation for 
ties into wilcox.test(). Just try

wilcox.test(c(1,1,5),c(10,11))

wilcox.test(c(1,2,5),c(10,11))

The p-values differ significantly.

But if I try

library(exactRankTests)

wilcox.exact(c(1,1,5),c(10,11))

wilcox.exact(c(1,2,5),c(10,11))

then the p-values coincide as expected. (R is used by many 
non-mathematicians/non-engineers who pay no attention at warnings.)


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec  9 11:43:56 2019
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 9 Dec 2019 11:43:56 +0100
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
Message-ID: <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>

On 12/7/19 10:32 PM, Laurent Gautier wrote:
> Thanks for the quick response Tomas.
>
> The same error is indeed happening when trying to have a zero-length 
> variable name in an environment. The surprising bit is then "why is 
> this happening during parsing" (that is why are variables assigned to 
> an environment) ?

The emitted R error (in the R console) is not a parse (syntax) error, 
but an error emitted during parsing when the parser tries to intern a 
name - look it up in a symbol table. Empty string is not allowed as a 
symbol name, and hence the error. In the call "list(''=1)" , the empty 
name is what could eventually become a name of a local variable inside 
list(), even though not yet during parsing.

There is probably some error in how the external code is handling R 
errors? (Fatal error: unable to initialize the JIT, stack smashing, etc) 
and possibly also how R is initialized before calling ParseVector. 
Probably you would get the same problem when running say 
"stop('myerror')". Please note R errors are implemented as long-jumps, 
so care has to be taken when calling into R, Writing R Extensions has 
more details (and section 8 specifically about embedding R). This is 
unlike parse (syntax) errors signaled via return value to ParseVector()

Best,
Tomas

>
> We are otherwise aware that the error is not occurring in the R 
> console, but can be traced to a call to R_ParseVector() in R's C 
> API:(https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509).
>
> Our specific setup is calling an embedded R from Python, using the 
> cffi library. An error on end was the first possibility considered, 
> but the puzzling specificity of the error (as shown below other 
> parsing errors are handled properly) and the difficulty tracing what 
> is in happening in R_ParseVector() made me ask whether someone on this 
> list had a suggestion about the possible issue"
>
> ```
> >>>  import  rpy2.rinterface  as  ri
> >>>  ri.initr()
> >>>  e  =  ri.parse("list(''=1+")  
> ---------------------------------------------------------------------------
> RParsingError                              Traceback  (most  recent  call  last)>>> e = ri.parse("list(''=123") R[write to console]: Error: 
> attempt to use zero-length variable name R[write to console]: Fatal 
> error: unable to initialize the JIT *** stack smashing detected ***: 
> <unknown> terminated ```
>
> Le?lun. 2 d?c. 2019 ??06:37, Tomas Kalibera <tomas.kalibera at gmail.com 
> <mailto:tomas.kalibera at gmail.com>> a ?crit?:
>
>     Dear Laurent,
>
>     could you please provide a complete reproducible example where
>     parsing
>     results in a crash of R? Calling parse(text="list(''=123") from R
>     works
>     fine for me (gives Error: attempt to use zero-length variable name).
>
>     I don't think the problem you observed could be related to the memory
>     leak. The leak is on the heap, not stack.
>
>     Zero-length names of elements in a list are allowed. They are not the
>     same thing as zero-length variables in an environment. If you try to
>     convert "lst" from your example to an environment, you would get the
>     error (attempt to use zero-length variable name).
>
>     Best
>     Tomas
>
>
>     On 11/30/19 11:55 PM, Laurent Gautier wrote:
>     > Hi again,
>     >
>     > Beside R_ParseVector()'s possible inconsistent behavior, R's
>     handling of
>     > zero-length named elements does not seem consistent either:
>     >
>     > ```
>     >> lst <- list()
>     >> lst[[""]] <- 1
>     >> names(lst)
>     > [1] ""
>     >> list("" = 1)
>     > Error: attempt to use zero-length variable name
>     > ```
>     >
>     > Should the parser be made to accept as valid what is otherwise
>     possible
>     > when using `[[<` ?
>     >
>     >
>     > Best,
>     >
>     > Laurent
>     >
>     >
>     >
>     > Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier
>     <lgautier at gmail.com <mailto:lgautier at gmail.com>> a ?crit :
>     >
>     >> I found the following code comment in `src/main/gram.c`:
>     >>
>     >> ```
>     >>
>     >> /* Memory leak
>     >>
>     >> yyparse(), as generated by bison, allocates extra space for the
>     parser
>     >> stack using malloc(). Unfortunately this means that there is a
>     memory
>     >> leak in case of an R error (long-jump). In principle, we could
>     define
>     >> yyoverflow() to relocate the parser stacks for bison and
>     allocate say on
>     >> the R heap, but yyoverflow() is undocumented and somewhat
>     complicated
>     >> (we would have to replicate some macros from the generated
>     parser here).
>     >> The same problem exists at least in the Rd and LaTeX parsers in
>     tools.
>     >> */
>     >>
>     >> ```
>     >>
>     >> Could this be related to be issue ?
>     >>
>     >> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier
>     <lgautier at gmail.com <mailto:lgautier at gmail.com>> a
>     >> ?crit :
>     >>
>     >>> Hi,
>     >>>
>     >>> The behavior of
>     >>> ```
>     >>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>     >>> ```
>     >>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
>     >>> depending on the string to be parsed.
>     >>>
>     >>> Trying to parse a string such as `"list(''=1+"` sets the
>     >>> `ParseStatus` to incomplete parsing error but trying to parse
>     >>> `"list(''=123"` will result in R sending a message to the
>     console (followed but a crash):
>     >>>
>     >>> ```
>     >>> R[write to console]: Error: attempt to use zero-length
>     variable nameR[write to console]: Fatal error: unable to
>     initialize the JIT*** stack smashing detected ***: <unknown>
>     terminated
>     >>> ```
>     >>>
>     >>> Is there a reason for the difference in behavior, and is there
>     a workaround ?
>     >>>
>     >>> Thanks,
>     >>>
>     >>>
>     >>> Laurent
>     >>>
>     >>>
>     >? ? ? ?[[alternative HTML version deleted]]
>     >
>     > ______________________________________________
>     > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>


	[[alternative HTML version deleted]]


From pd@|gd @end|ng |rom gm@||@com  Mon Dec  9 12:59:07 2019
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Mon, 9 Dec 2019 12:59:07 +0100
Subject: [Rd] What should dnorm(0, 0, -Inf) return?
In-Reply-To: <24045.64646.983266.213654@stat.math.ethz.ch>
References: <28fddd$csrn33@ironport10.mayo.edu>
 <CAGiFhPP4AVZnZUfFo=N5CPJZCUSgL6sWUROaT8fXAFRvKqpFVA@mail.gmail.com>
 <2E7FB3D3-4FB2-49CF-983D-77735A79D7AD@gmail.com>
 <24045.64646.983266.213654@stat.math.ethz.ch>
Message-ID: <75FD9E0E-2BC1-493E-A4EF-2FE221D2DDAF@gmail.com>

I have committed a fix for r-devel (dnorm only).

-pd

> On 9 Dec 2019, at 08:49 , Martin Maechler <maechler at stat.math.ethz.ch> wrote:
> 
>>>>>> peter dalgaard 
>>>>>>    on Sun, 8 Dec 2019 12:11:50 +0100 writes:
> 
>> Yes, that looks like a bug and an easily fixable one too.
> 
> agreed.
> 
>> However, I spy another issue: Why do we check the
>> !R_FINITE(x) && mu == x before checking for sd < 0 ? The
>> difference is whether we
> 
>> return ML_NAN; or ML_ERR_return_NAN;
> 
>> but surely negative sd should always be an error?
> 
>> I'd be inclined to do
> 
>> if (sigma < 0) ML_ERR_return_NAN;
>> if(!R_FINITE(sigma)) return R_D__0;
>> if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
>> if (sigma == 0) 
>>   return (x == mu) ? ML_POSINF : R_D__0;
>> x = (x - mu) / sigma;
> 
> 
>> (Ping Martin...)
> 
> I think you are spot on, Peter.
> All of this code has a longish history, with incremental border
> case improvements.
> Let's hope (somewhat unrealistically) this is the last one for
> dnorm().
> 
> NB: dlnorm() and some of the gamma/chisq/.. may need a
>    similar adjustment
> 
> Lastly, regression tests for this
> (either in  tests/d-p-q-r-tests.{R,Rout.save}
> or easier in reg-tests-1d.R)  should be added too.
> 
>> -pd
> 
>>> On 7 Dec 2019, at 23:40 , Wang Jiefei <szwjf08 at gmail.com> wrote:
>>> 
>>> Good question, I cannot speak for R's developers but I would like to
>>> provide some information on the problem. Here are the first few lines of
>>> the dnorm function located at src\nmath\dnorm.c:
>>> 
>>> ```
>>> double dnorm4(double x, double mu, double sigma, int give_log)
>>> {
>>> #ifdef IEEE_754
>>> if (ISNAN(x) || ISNAN(mu) || ISNAN(sigma))
>>> return x + mu + sigma;
>>> #endif
>>> if(!R_FINITE(sigma)) return R_D__0;
>>> if(!R_FINITE(x) && mu == x) return ML_NAN;/* x-mu is NaN */
>>> if (sigma <= 0) {
>>> if (sigma < 0) ML_ERR_return_NAN;
>>> /* sigma == 0 */
>>> return (x == mu) ? ML_POSINF : R_D__0;
>>> }
>>> ....
>>> }
>>> ```
>>> 
>>> You can clearly see where the problem is. I think either the document or
>>> the code needs a modification.
>>> 
>>> Best,
>>> Jiefei
>>> 
>>> On Sat, Dec 7, 2019 at 5:05 PM Weigand, Stephen D. via R-devel <
>>> r-devel at r-project.org> wrote:
>>> 
>>>> Hi,
>>>> Apropos of a recent Inf question, I've previously wondered if dnorm "does
>>>> the right thing" with
>>>> 
>>>> dnorm(0, 0, -Inf)
>>>> 
>>>> which gives zero. Should that be zero or NaN (or NA)?
>>>> 
>>>> The help says "'sd < 0' is an error and returns 'NaN'" and since -Inf < 0
>>>> is TRUE, then... is this a bug?
>>>> 
>>>> Thank you,
>>>> Stephen
>>>> Rochester, MN USA
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>> 
>>> [[alternative HTML version deleted]]
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
>> -- 
>> Peter Dalgaard, Professor,
>> Center for Statistics, Copenhagen Business School
>> Solbjerg Plads 3, 2000 Frederiksberg, Denmark
>> Phone: (+45)38153501
>> Office: A 4.23
>> Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @pencer@gr@ve@ @end|ng |rom prod@y@e@com  Mon Dec  9 14:45:23 2019
From: @pencer@gr@ve@ @end|ng |rom prod@y@e@com (Spencer Graves)
Date: Mon, 9 Dec 2019 07:45:23 -0600
Subject: [Rd] default col.names from data.frame not the same as as.data.frame
Message-ID: <b34e0f71-2d07-72bd-1b51-5a54cd0ce42b@prodsyse.com>

Hello, All:


 ????? Consider:


 > data.frame(matrix(1:2, 1))
 ? X1 X2
1? 1? 2
 > as.data.frame(matrix(1:2, 1))
 ? V1 V2
1? 1? 2


 ????? I ask, because I got different default names running the same 
numbers through BMA:::bic.glm.matrix and BMA:::bic.glm.data.frame, so I 
thought I'd ask this group what names you all prefer for examples like 
these.


 ????? Thanks,
 ????? Spencer Graves


From |g@ut|er @end|ng |rom gm@||@com  Mon Dec  9 14:54:47 2019
From: |g@ut|er @end|ng |rom gm@||@com (Laurent Gautier)
Date: Mon, 9 Dec 2019 08:54:47 -0500
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
Message-ID: <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>

Le lun. 9 d?c. 2019 ? 05:43, Tomas Kalibera <tomas.kalibera at gmail.com> a
?crit :

> On 12/7/19 10:32 PM, Laurent Gautier wrote:
>
> Thanks for the quick response Tomas.
>
> The same error is indeed happening when trying to have a zero-length
> variable name in an environment. The surprising bit is then "why is this
> happening during parsing" (that is why are variables assigned to an
> environment) ?
>
> The emitted R error (in the R console) is not a parse (syntax) error, but
> an error emitted during parsing when the parser tries to intern a name -
> look it up in a symbol table. Empty string is not allowed as a symbol name,
> and hence the error. In the call "list(''=1)" , the empty name is what
> could eventually become a name of a local variable inside list(), even
> though not yet during parsing.
>

Thanks Tomas.

I guess this has do with R expressions being lazily evaluated, and names of
arguments in a call are also part of the expression. Now the puzzling part
is why is that at all part of the parsing: I would have expected
R_ParseVector() to be restricted to parsing... Now it feels like
R_ParseVector() is performing parsing, and a first level of evalution for
expressions that "should never work" (the empty name).

There is probably some error in how the external code is handling R errors
> (Fatal error: unable to initialize the JIT, stack smashing, etc) and
> possibly also how R is initialized before calling ParseVector. Probably you
> would get the same problem when running say "stop('myerror')". Please note
> R errors are implemented as long-jumps, so care has to be taken when
> calling into R, Writing R Extensions has more details (and section 8
> specifically about embedding R). This is unlike parse (syntax) errors
> signaled via return value to ParseVector()
>

The issue is that the segfault (because of stack smashing, therefore
because of what also suspected to be an incontrolled jump) is happening
within the execution of R_ParseVector(). I would think that an issue with
the initialization of R is less likely because the project is otherwise
used a fair bit and is well covered by automated continuous tests.

After looking more into R's gram.c I suspect that an execution context is
required for R_ParseVector() to know to properly work (know where to jump
in case of error) when the parsing code decides to fail outside what it
thinks is a syntax error. If the case, this would make R_ParseVector()
function well when called from say, a C-extension to an R package, but fail
the way I am seeing it fail when called from an embedded R.

Best,

Laurent

> Best,
> Tomas
>
>
> We are otherwise aware that the error is not occurring in the R console,
> but can be traced to a call to R_ParseVector() in R's C API:(
> https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509
> ).
>
> Our specific setup is calling an embedded R from Python, using the cffi
> library. An error on end was the first possibility considered, but the
> puzzling specificity of the error (as shown below other parsing errors are
> handled properly) and the difficulty tracing what is in happening in
> R_ParseVector() made me ask whether someone on this list had a suggestion
> about the possible issue"
>
> ```
>
> >>> import rpy2.rinterface as ri>>> ri.initr()>>> e = ri.parse("list(''=1+") ---------------------------------------------------------------------------RParsingError                             Traceback (most recent call last)>>> e = ri.parse("list(''=123") R[write to console]: Error: attempt to use zero-length variable name
> R[write to console]: Fatal error: unable to initialize the JIT
>
> *** stack smashing detected ***: <unknown> terminated
> ```
>
>
> Le lun. 2 d?c. 2019 ? 06:37, Tomas Kalibera <tomas.kalibera at gmail.com> a
> ?crit :
>
>> Dear Laurent,
>>
>> could you please provide a complete reproducible example where parsing
>> results in a crash of R? Calling parse(text="list(''=123") from R works
>> fine for me (gives Error: attempt to use zero-length variable name).
>>
>> I don't think the problem you observed could be related to the memory
>> leak. The leak is on the heap, not stack.
>>
>> Zero-length names of elements in a list are allowed. They are not the
>> same thing as zero-length variables in an environment. If you try to
>> convert "lst" from your example to an environment, you would get the
>> error (attempt to use zero-length variable name).
>>
>> Best
>> Tomas
>>
>>
>> On 11/30/19 11:55 PM, Laurent Gautier wrote:
>> > Hi again,
>> >
>> > Beside R_ParseVector()'s possible inconsistent behavior, R's handling of
>> > zero-length named elements does not seem consistent either:
>> >
>> > ```
>> >> lst <- list()
>> >> lst[[""]] <- 1
>> >> names(lst)
>> > [1] ""
>> >> list("" = 1)
>> > Error: attempt to use zero-length variable name
>> > ```
>> >
>> > Should the parser be made to accept as valid what is otherwise possible
>> > when using `[[<` ?
>> >
>> >
>> > Best,
>> >
>> > Laurent
>> >
>> >
>> >
>> > Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a
>> ?crit :
>> >
>> >> I found the following code comment in `src/main/gram.c`:
>> >>
>> >> ```
>> >>
>> >> /* Memory leak
>> >>
>> >> yyparse(), as generated by bison, allocates extra space for the parser
>> >> stack using malloc(). Unfortunately this means that there is a memory
>> >> leak in case of an R error (long-jump). In principle, we could define
>> >> yyoverflow() to relocate the parser stacks for bison and allocate say
>> on
>> >> the R heap, but yyoverflow() is undocumented and somewhat complicated
>> >> (we would have to replicate some macros from the generated parser
>> here).
>> >> The same problem exists at least in the Rd and LaTeX parsers in tools.
>> >> */
>> >>
>> >> ```
>> >>
>> >> Could this be related to be issue ?
>> >>
>> >> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com> a
>> >> ?crit :
>> >>
>> >>> Hi,
>> >>>
>> >>> The behavior of
>> >>> ```
>> >>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>> >>> ```
>> >>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
>> >>> depending on the string to be parsed.
>> >>>
>> >>> Trying to parse a string such as `"list(''=1+"` sets the
>> >>> `ParseStatus` to incomplete parsing error but trying to parse
>> >>> `"list(''=123"` will result in R sending a message to the console
>> (followed but a crash):
>> >>>
>> >>> ```
>> >>> R[write to console]: Error: attempt to use zero-length variable
>> nameR[write to console]: Fatal error: unable to initialize the JIT*** stack
>> smashing detected ***: <unknown> terminated
>> >>> ```
>> >>>
>> >>> Is there a reason for the difference in behavior, and is there a
>> workaround ?
>> >>>
>> >>> Thanks,
>> >>>
>> >>>
>> >>> Laurent
>> >>>
>> >>>
>> >       [[alternative HTML version deleted]]
>> >
>> > ______________________________________________
>> > R-devel at r-project.org mailing list
>> > https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>>
>

	[[alternative HTML version deleted]]


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec  9 15:57:53 2019
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 9 Dec 2019 15:57:53 +0100
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
 <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
Message-ID: <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>

On 12/9/19 2:54 PM, Laurent Gautier wrote:
>
>
> Le?lun. 9 d?c. 2019 ??05:43, Tomas Kalibera <tomas.kalibera at gmail.com 
> <mailto:tomas.kalibera at gmail.com>> a ?crit?:
>
>     On 12/7/19 10:32 PM, Laurent Gautier wrote:
>>     Thanks for the quick response Tomas.
>>
>>     The same error is indeed happening when trying to have a
>>     zero-length variable name in an environment. The surprising bit
>>     is then "why is this happening during parsing" (that is why are
>>     variables assigned to an environment) ?
>
>     The emitted R error (in the R console) is not a parse (syntax)
>     error, but an error emitted during parsing when the parser tries
>     to intern a name - look it up in a symbol table. Empty string is
>     not allowed as a symbol name, and hence the error. In the call
>     "list(''=1)" , the empty name is what could eventually become a
>     name of a local variable inside list(), even though not yet during
>     parsing.
>
>
> Thanks Tomas.
>
> I guess this has do with R expressions being lazily evaluated, and 
> names of arguments in a call are also part of the expression. Now the 
> puzzling part is why is that at all part of the parsing: I would have 
> expected R_ParseVector() to be restricted to parsing... Now it feels 
> like R_ParseVector() is performing parsing, and a first level of 
> evalution for expressions that "should never work" (the empty name).
Think of it as an exception in say Python. Some failures during parsing 
result in an exception (called error in R and implemented using a long 
jump). Any time you are calling into R you can get an error; out of 
memory is also signalled as R error.
>
>     There is probably some error in how the external code is handling
>     R errors? (Fatal error: unable to initialize the JIT, stack
>     smashing, etc) and possibly also how R is initialized before
>     calling ParseVector. Probably you would get the same problem when
>     running say "stop('myerror')". Please note R errors are
>     implemented as long-jumps, so care has to be taken when calling
>     into R, Writing R Extensions has more details (and section 8
>     specifically about embedding R). This is unlike parse (syntax)
>     errors signaled via return value to ParseVector()
>
>
> The issue is that the segfault (because of stack smashing, therefore 
> because of what also suspected to be an incontrolled jump) is 
> happening within the execution of R_ParseVector(). I would think that 
> an issue with the initialization of R is less likely because the 
> project is otherwise used a fair bit and is well covered by automated 
> continuous tests.
>
> After looking more into R's gram.c I suspect that an execution context 
> is required for R_ParseVector() to know to properly work (know where 
> to jump in case of error) when the parsing code decides to fail 
> outside what it thinks is a syntax error. If the case, this would make 
> R_ParseVector() function well when called from say, a C-extension to 
> an R package, but fail the way I am seeing it fail when called from an 
> embedded R.

Yes, contexts are used internally to handle errors. For external use 
please see Writing R Extensions, section 6.12.

Best
Tomas

> Best,
>
> Laurent
>
>     Best,
>     Tomas
>
>>
>>     We are otherwise aware that the error is not occurring in the R
>>     console, but can be traced to a call to R_ParseVector() in R's C
>>     API:(https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509).
>>
>>     Our specific setup is calling an embedded R from Python, using
>>     the cffi library. An error on end was the first possibility
>>     considered, but the puzzling specificity of the error (as shown
>>     below other parsing errors are handled properly) and the
>>     difficulty tracing what is in happening in R_ParseVector() made
>>     me ask whether someone on this list had a suggestion about the
>>     possible issue"
>>
>>     ```
>>     >>>  import  rpy2.rinterface  as  ri
>>     >>>  ri.initr()
>>     >>>  e  =  ri.parse("list(''=1+")  
>>     ---------------------------------------------------------------------------
>>     RParsingError                              Traceback  (most  recent  call  last)>>> e = ri.parse("list(''=123") R[write to console]: Error:
>>     attempt to use zero-length variable name R[write to console]:
>>     Fatal error: unable to initialize the JIT *** stack smashing
>>     detected ***: <unknown> terminated ```
>>
>>     Le?lun. 2 d?c. 2019 ??06:37, Tomas Kalibera
>>     <tomas.kalibera at gmail.com <mailto:tomas.kalibera at gmail.com>> a
>>     ?crit?:
>>
>>         Dear Laurent,
>>
>>         could you please provide a complete reproducible example
>>         where parsing
>>         results in a crash of R? Calling parse(text="list(''=123")
>>         from R works
>>         fine for me (gives Error: attempt to use zero-length variable
>>         name).
>>
>>         I don't think the problem you observed could be related to
>>         the memory
>>         leak. The leak is on the heap, not stack.
>>
>>         Zero-length names of elements in a list are allowed. They are
>>         not the
>>         same thing as zero-length variables in an environment. If you
>>         try to
>>         convert "lst" from your example to an environment, you would
>>         get the
>>         error (attempt to use zero-length variable name).
>>
>>         Best
>>         Tomas
>>
>>
>>         On 11/30/19 11:55 PM, Laurent Gautier wrote:
>>         > Hi again,
>>         >
>>         > Beside R_ParseVector()'s possible inconsistent behavior,
>>         R's handling of
>>         > zero-length named elements does not seem consistent either:
>>         >
>>         > ```
>>         >> lst <- list()
>>         >> lst[[""]] <- 1
>>         >> names(lst)
>>         > [1] ""
>>         >> list("" = 1)
>>         > Error: attempt to use zero-length variable name
>>         > ```
>>         >
>>         > Should the parser be made to accept as valid what is
>>         otherwise possible
>>         > when using `[[<` ?
>>         >
>>         >
>>         > Best,
>>         >
>>         > Laurent
>>         >
>>         >
>>         >
>>         > Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier
>>         <lgautier at gmail.com <mailto:lgautier at gmail.com>> a ?crit :
>>         >
>>         >> I found the following code comment in `src/main/gram.c`:
>>         >>
>>         >> ```
>>         >>
>>         >> /* Memory leak
>>         >>
>>         >> yyparse(), as generated by bison, allocates extra space
>>         for the parser
>>         >> stack using malloc(). Unfortunately this means that there
>>         is a memory
>>         >> leak in case of an R error (long-jump). In principle, we
>>         could define
>>         >> yyoverflow() to relocate the parser stacks for bison and
>>         allocate say on
>>         >> the R heap, but yyoverflow() is undocumented and somewhat
>>         complicated
>>         >> (we would have to replicate some macros from the generated
>>         parser here).
>>         >> The same problem exists at least in the Rd and LaTeX
>>         parsers in tools.
>>         >> */
>>         >>
>>         >> ```
>>         >>
>>         >> Could this be related to be issue ?
>>         >>
>>         >> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier
>>         <lgautier at gmail.com <mailto:lgautier at gmail.com>> a
>>         >> ?crit :
>>         >>
>>         >>> Hi,
>>         >>>
>>         >>> The behavior of
>>         >>> ```
>>         >>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>>         >>> ```
>>         >>> defined in `src/include/R_ext/Parse.h` appears to be
>>         inconsistent
>>         >>> depending on the string to be parsed.
>>         >>>
>>         >>> Trying to parse a string such as `"list(''=1+"` sets the
>>         >>> `ParseStatus` to incomplete parsing error but trying to parse
>>         >>> `"list(''=123"` will result in R sending a message to the
>>         console (followed but a crash):
>>         >>>
>>         >>> ```
>>         >>> R[write to console]: Error: attempt to use zero-length
>>         variable nameR[write to console]: Fatal error: unable to
>>         initialize the JIT*** stack smashing detected ***: <unknown>
>>         terminated
>>         >>> ```
>>         >>>
>>         >>> Is there a reason for the difference in behavior, and is
>>         there a workaround ?
>>         >>>
>>         >>> Thanks,
>>         >>>
>>         >>>
>>         >>> Laurent
>>         >>>
>>         >>>
>>         >? ? ? ?[[alternative HTML version deleted]]
>>         >
>>         > ______________________________________________
>>         > R-devel at r-project.org <mailto:R-devel at r-project.org>
>>         mailing list
>>         > https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>


	[[alternative HTML version deleted]]


From w|||@|@nd@u @end|ng |rom gm@||@com  Mon Dec  9 21:50:44 2019
From: w|||@|@nd@u @end|ng |rom gm@||@com (Will L)
Date: Mon, 9 Dec 2019 15:50:44 -0500
Subject: [Rd] long vector support
In-Reply-To: <24043.35381.634233.282740@stat.math.ethz.ch>
References: <CAC-MUvsRCK1tSzhPjc_YzkOye3inNp3m8rL=mDnqZUoCOsqveg@mail.gmail.com>
 <24043.35381.634233.282740@stat.math.ethz.ch>
Message-ID: <CAC-MUvtJ-yzmLt6oExVeXduszfakb+gRVkZiu0oYgm5z8ccm7A@mail.gmail.com>

Thank you both. I really appreciate your work developing R, and it is
exciting that long vector support may be coming to writeBin(). Next time, I
will come prepared with svn revision numbers to help track things down.

On Sat, Dec 7, 2019 at 6:17 AM Martin Maechler <maechler at stat.math.ethz.ch>
wrote:

> >>>>> Will L
> >>>>>     on Fri, 6 Dec 2019 16:02:59 -0500 writes:
>
>     > All, At first glance, a recent commit to R-devel (
>     >
> https://github.com/wch/r-source/commit/2c182014ecc8c2407a89092c9162d86046bd18da
> )
>     > appears to be related to long vector support.
>
> yes, for a very limited case, with a very nice minimal
> reproducible example and proper R bug report, where the change
> was very simple indeed , PR#17665, i.e.
>     https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17665
>
>     > But as
>     > Henrik Bengtsson points out at
>     >
> https://github.com/HenrikBengtsson/Wishlist-for-R/issues/97#issuecomment-562659134
> ,
>     > writeBin() still prohibits long vectors. Are there any
>     > plans to add long vector support to R 4.0.0?
>
> well.. there *is* a lot of long vector support in R 3.x.y
> already.
>
> Where there are gaps,
> 1) we have to be told about (i.e. it should be a case where
>    people at least have stumbled about it) -- preferably with
>    form PR in R's bugzilla,  see https://www.r-project.org/bugs.html
>
> 2) sometimes a fix takes quite a bit of time, and we would close
>    the case much more quickly if people looked at the case in
>    detail and found *how* to fix it.
>
>    [For the Matrix package and the case of sparse matrices,
>     I'd be very happy if a C-savvy R developer would start
>     collaborating with me to get this (incl interface to SuiteSparse)]
>
> In the present case, it may be that a change does not take much
> effort; my first try seems to work already .. and may just a bit
> more safeguarding ..
>
> So thank you, Will, for the reminder!
>
> Martin Maechler
> ETH Zurich  and  R Core Team
>
>
>     > x <- raw(2^31)
>     > writeBin(x, con = nullfile())
>     > # Error in writeBin(x, con = nullfile()) :
>     > #  long vectors not supported yet: connections.c:4430
>
>     > x <- raw(2^31)
>     > con <- rawConnection(raw(0L), "w")
>     > writeBin(raw(2^31), con = con)
>     > # Error in writeBin(raw(2^31), con = con) :
>     > #  long vectors not supported yet: connections.c:4430
>
>
>     > Will
>
>     > [[alternative HTML version deleted]]
>
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>


-- 
wlandau.github.io
linkedin.com/in/wlandau
github.com/wlandau

	[[alternative HTML version deleted]]


From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Mon Dec  9 22:43:36 2019
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (Karolis =?utf-8?Q?Koncevi=C4=8Dius?=)
Date: Mon, 9 Dec 2019 23:43:36 +0200
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <20191207211858.dpnqeslbln5caz2v@PMW>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
 <20191207205901.4265F22877@v-lynne.math.ethz.ch>
 <20191207211858.dpnqeslbln5caz2v@PMW>
Message-ID: <20191209214336.iy66s5q4nzawdfch@PMW>

So I tried adding Infinity support for all cases.
And it is (as could be expected) more complicated than I thought.

It is easy to add Inf support for the test. The problems start with conf.int=TRUE.

Currently confidence intervals are computed via `uniroot()` and, in the 
case of infinities, we are computationally looking for roots over 
infinite interval which results in an error. I suspect this is the 
reason Inf values were removed in the first place.

Just a note, I found a few more errors/inconsistencies when requesting 
confidence intervals with paired=TRUE (due to Infinities being left in).

Current error in Inf-Inf scenario:

wilcox.test(c(1,2,Inf), c(4,8,Inf), paired=TRUE, conf.int=TRUE)
   Error in if (ZEROES) x <- x[x != 0] :
     missing value where TRUE/FALSE needed



NaN confidence intervals:

wilcox.test(c(1:9,Inf), c(21:28,Inf,30), paired=TRUE, conf.int=TRUE)

   Wilcoxon signed rank test with continuity correction

   data:  c(1:9, Inf) and c(21:28, Inf, 30)
   V = 9.5, p-value = 0.0586
   alternative hypothesis: true location shift is not equal to 0
   0 percent confidence interval:
    NaN NaN
    sample estimates:
    midrange
         NaN


The easiest "fix" for consistency would be to simply remove Infinity 
support from the paired=TRUE case.

But going with the more desirable approach of adding Infinity support 
for non-paired cases - it is currently not clear to me what confidence 
intervals and pseudomedian should be. Specially when Infinities are on 
both sides.

Regards,
Karolis Koncevi?ius.


On 2019-12-07 23:18, Karolis Koncevi?ius wrote:
>Thank you for a fast response. Nice to see this mailing list being so 
>alive.
>
>Regarding Inf issue: I agree with your assessment that Inf should not 
>be removed. The code gave me an impression that Inf values were 
>intentionally removed (since is.finite() was used everywhere, except 
>for paired case). I will try to adjust my patch according to your 
>feedback.
>
>One more thing: it seems like you assumed that issues 2:4 are all 
>related to machine precision, which is not the case - only 2nd issue 
>is.
>Just wanted to draw this to your attention, in case you might have 
>some feedback and guidelines about issues 3 and 4 as well.
>
>
>
>On 2019-12-07 21:59, Martin Maechler wrote:
>>>>>>>Karolis Koncevi?ius
>>>>>>>    on Sat, 7 Dec 2019 20:55:36 +0200 writes:
>>
>>   > Hello,
>>   > Writing to share some things I've found about wilcox.test() that seem a
>>   > a bit inconsistent.
>>
>>   > 1. Inf values are not removed if paired=TRUE
>>
>>   > # returns different results (Inf is removed):
>>   > wilcox.test(c(1,2,3,4), c(0,9,8,7))
>>   > wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
>>
>>   > # returns the same result (Inf is left as value with highest rank):
>>   > wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
>>   > wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)
>>
>>Now which of the two cases do you consider correct ?
>>
>>IHMO, the 2nd one is correct: it is exactly one property of the
>>*robustness* of the wilcoxon test and very desirable that any
>>(positive) outlier is treated the same as just "the largest
>>value" and the test statistic (and hence the p-value) should not
>>change.
>>
>>So I think the first case is wrong, notably if modified, (such
>>that the last  y  is the overall maximal value (slightly larger sample):
>>
>>>wilcox.test(1:7, 1/8+ c(9:4, 12))
>>
>>	Wilcoxon rank sum test
>>
>>data:  1:7 and 1/8 + c(9:4, 12)
>>W = 6, p-value = 0.01748
>>alternative hypothesis: true location shift is not equal to 0
>>
>>>wilcox.test(1:7, 1/8+ c(9:4, 10000))
>>
>>	Wilcoxon rank sum test
>>
>>data:  1:7 and 1/8 + c(9:4, 10000)
>>W = 6, p-value = 0.01748
>>alternative hypothesis: true location shift is not equal to 0
>>
>>>wilcox.test(1:7, 1/8+ c(9:4, Inf))
>>
>>	Wilcoxon rank sum test
>>
>>data:  1:7 and 1/8 + c(9:4, Inf)
>>W = 6, p-value = 0.03497
>>alternative hypothesis: true location shift is not equal to 0
>>
>>The  Inf  case should definitely give the same as the  10'000 case.
>>That's exactly one property of a robust statistic.
>>
>>Thank you, Karolis, this is pretty embarrassing to only be detected now after 25+ years of R in use ...
>>
>>The correct fix starts with replacing the  is.finite()  by   !is.na() and keep the 'Inf' in the rank computations...
>>(but then probably also deal with the case of more than one Inf, notably the  Inf - Inf  "exception" which is not triggered by your example...)
>>
>>
>>---
>>
>>Ben addressed the "rounding" / numerical issues unavoidable for
>>the other problems.
>>
>>   > 2. tolerance issues with paired=TRUE.
>>
>>   > wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
>>   > # ...
>>   > # Warning:  cannot compute exact p-value with ties
>>
>>   > wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
>>   > # ...
>>   > # no warning
>>
>>   > 3. Always 'x observations are missing' when paired=TRUE
>>
>>   > wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
>>   > # ...
>>   > # Error:  not enough (finite) 'x' observations
>>
>>   > 4. No indication if normal approximation was used:
>>
>>   > # different numbers, but same "method" name
>>   > wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
>>   > wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
>>
>>
>>   > From all of these I am pretty sure the 1st one is likely unintended,
>>   > so attaching a small patch to adjust it. Can also try patching others if
>>   > consensus is reached that the behavioiur has to be modified.
>>
>>   > Kind regards,
>>   > Karolis Koncevi?ius.
>>
>>   > ---
>>
>>   > Index: wilcox.test.R
>>   > ===================================================================
>>   > --- wilcox.test.R  (revision 77540)
>>   > +++ wilcox.test.R  (working copy)
>>   > @@ -42,7 +42,7 @@
>>   > if(paired) {
>>   > if(length(x) != length(y))
>>   > stop("'x' and 'y' must have the same length")
>>   > -            OK <- complete.cases(x, y)
>>   > +            OK <- is.finite(x) & is.finite(y)
>>   > x <- x[OK] - y[OK]
>>   > y <- NULL
>>   > }
>>
>>   > ______________________________________________
>>   > R-devel at r-project.org mailing list
>>   > https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec 11 17:22:28 2019
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 11 Dec 2019 11:22:28 -0500
Subject: [Rd] Windows check problems.
Message-ID: <72f873b4-0d5c-18ef-1c9b-3495b1d37d81@gmail.com>

The thread starting with this message:

https://stat.ethz.ch/pipermail/r-package-devel/2019q4/004745.html

described problems Rich Heiberger was having with package checking on 
Windows.  It appeared that during the tests of examples, an old version 
of the package was loaded but the new tests were being run, causing lots 
of confusion and trouble.

I reproduced the error, and I think I've found the cause.  I had his 
package tarball on a network drive, with a local drive being used for 
the session temporary directory.  The check code needs a copy of the 
package installed in the temporary directory, and already has one in the 
pkg.Rcheck directory where the check is taking place, so it tries to 
create a junction linking them.  (On non-Windows systems it uses a symlink.)

Apparently the junction creation silently fails:  an empty directory 
appears on the temp dir.  When R loads the package code, it doesn't find 
it in the temp dir, and goes looking in other libraries, where it found 
an older versions of the package.

A workaround for this issue is to set the environment variable

   R_WIN_NO_JUNCTIONS=yes

before doing the check.  This causes the check code to copy all the 
files into the temp dir and things are fine.

I don't know whether the junction creation should have succeeded, or 
whether it should have signalled an error when it didn't, but it might 
make sense for R to do a simple sanity check after trying to create the 
junction (e.g. test for the presence of DESCRIPTION in the newly created 
location), falling back to a copy if things didn't succeed.

Duncan Murdoch


From @osp@m m@iii@g oii @itieid-im@de  Wed Dec 11 21:42:56 2019
From: @osp@m m@iii@g oii @itieid-im@de (@osp@m m@iii@g oii @itieid-im@de)
Date: Wed, 11 Dec 2019 21:42:56 +0100
Subject: [Rd] Why does INT 3 (opcode 0xCC) SIGTRAP break to debugger (gdb)
 in Rgui.exe and Rterm.exe but NOT in R.exe on Windows (64 bit)?
In-Reply-To: <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
 <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
 <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
Message-ID: <40bc3a46d7b4984fae03e9e657ce0dc1c210db62.camel@altfeld-im.de>

I am developing a package to improve the debugging of Rcpp (C++) and SEXP based C code in gdb
by providing convenience print, subset and other functions:

https://github.com/aryoda/R_CppDebugHelper

I also want to solve the Windows-only problem that you can break into the debugger from R
only via Rgui.exe (menu "Misc > break to debugger") by supporting breakpoints for R.exe.

I want breakpoints support in R.exe because debugging in Rgui.exe has an unwanted side effect:

https://stackoverflow.com/questions/59236579/gdb-prints-output-stdout-to-rgui-console-instead-of-gdb-console-on-windows-whe

My idea is to break into the debugger from R.exe by calling a little C(++) code that contains an INT 3 (opcode 0xCC) SIGTRAP code:

// break_to_debugger.cpp
// [[Rcpp::export]]
int break_to_debugger()
{
  int a = 3;
  asm("int $3");  // this code line shall break into the debugger
  // Idea taken from "Rgui > break into debugger":
  // https://github.com/wch/r-source/blob/5a156a0865362bb8381dcd69ac335f5174a4f60c/src/gnuwin32/rui.c#L431
  a++;
  return a;
}

# breakpoint.R
#' breaks the execution into the debugger
#'
#' @return
#' @export
breakpoint <- function() {
  break_to_debugger()
}

Surprisingly this works not only on Linux but also on Windows (v10, x64 architecture = 64 bit) in Rterm.exe,
but NOT for R.exe (64 bit):

- Rgui.exe:    Works
- Rscript.exe: Works
- R.exe:       Does not work: R.exe is exited with:
               [Inferior 1 (process 20704) exited with code 020000000003]

Can you please help me to understand why it works for Rgui.exe and Rscript.exe but not for R.exe?

Why is int 3 exiting R.exe?

And: How could I make it also work with R.exe?

Thanks a lot for sharing your ideas and experiences!

J?rgen

PS 1: My sessionInfo():
        R version 3.6.1 (2019-07-05)
        Platform: x86_64-w64-mingw32/x64 (64-bit)
        Running under: Windows 10 x64 (build 17134)

PS 2: My package "CppDebugHelper" was compiled with -g -o0 -std=c++11

PS 3: Here is my captured gdb output for the three test cases:

1. Rgui.exe ------------------------------------------------------------------------

>gdb --quiet --args Rgui.exe --silent --vanilla
Reading symbols from Rgui.exe...(no debugging symbols found)...done.
(gdb) run
Starting program: C:\R\bin\x64\Rgui.exe --silent --vanilla
[New Thread 14476.0x3710]
[New Thread 14476.0x284c]
[New Thread 14476.0x50ec]
[New Thread 14476.0x2d24]
warning: Invalid parameter passed to C runtime function.
[In RGui's R console:]
library(CppDebugHelper)
breakpoint()
[in gdb again:]
Program received signal SIGTRAP, Trace/breakpoint trap.
break_to_debugger () at break_to_debugger.cpp:33
33        a++;
(gdb) b debug_example_rcpp
Breakpoint 1 at 0x66ac6846: file debug_example_rcpp.cpp, line 13.
(gdb) continue
Continuing.
[In RGui's R console:]
debug_example_rcpp()
[in gdb again:]
Breakpoint 1, debug_example_rcpp () at debug_example_rcpp.cpp:13
13          CharacterVector cv   = CharacterVector::create("foo", "bar", NA_STRING, "hello")  ;
(gdb) next
14          NumericVector nv     = NumericVector::create(0.0, 1.0, NA_REAL, 10) ;
(gdb) n
16          DateVector dv        = DateVector::create( 14974, 14975, 15123, NA_REAL); // TODO how to use real dates instead?
(gdb) n
17          DateVector dv2       = DateVector::create(Date("2010-12-31"), Date("01.01.2011", "%d.%m.%Y"), Date(2011, 05, 29),
NA_REAL);
(gdb) n
18          DatetimeVector dtv   = DatetimeVector::create(1293753600, Datetime("2011-01-01"), Datetime("2011-05-29 10:15:30")
, NA_REAL);
(gdb) n
19          DataFrame df         = DataFrame::create(Named("name1") = cv, _["value1"] = nv, _["dv2"] = dv2);  // Named and _[
] are the same
(gdb) n
20          CharacterVector col1 = df["name1"];          // get the first column
(gdb) call dbg_print(df)
(gdb) call dbg_str(df)
(gdb) continue
Continuing.

[Output for the dbg_* function calls is printed to Rgui's R console (NOT the gdb terminal!):]

  name1 value1        dv2
1   foo      0 2010-12-31
2   bar      1 2011-01-01
3  <NA>     NA 2011-05-29
4 hello     10       <NA>

'data.frame':   4 obs. of  3 variables:
$ name1 : Factor w/ 3 levels "bar","foo","hello": 2 1 NA 3
$ value1: num  0 1 NA 10
$ dv2   : Date, format: "2010-12-31" "2011-01-01" ...



2. R.exe ------------------------------------------------------------------------

>gdb --quiet --args R.exe --silent --vanilla
Reading symbols from R.exe...(no debugging symbols found)...done.
(gdb) r
Starting program: C:\R\bin\x64\R.exe --silent --vanilla
[New Thread 20704.0x2b20]
[New Thread 20704.0x4c08]
[New Thread 20704.0x425c]
[New Thread 20704.0x45f8]
> library(CppDebugHelper)
> breakpoint()
[Thread 20704.0x45f8 exited with code 2147483651]
[Thread 20704.0x425c exited with code 2147483651]
[Thread 20704.0x4c08 exited with code 2147483651]
[Inferior 1 (process 20704) exited with code 020000000003]
(gdb) bt
No stack.
(gdb)



3. Rterm.exe ------------------------------------------------------------------------

gdb --quiet --args Rterm.exe --silent --vanilla
Reading symbols from Rterm.exe...(no debugging symbols found)...done.
(gdb) run
Starting program: C:\R\bin\x64\Rterm.exe --silent --vanilla
[New Thread 8132.0x3ee8]
[New Thread 8132.0x3828]
[New Thread 8132.0x4f1c]
[New Thread 8132.0x4ff4]
warning: Invalid parameter passed to C runtime function.
[New Thread 8132.0x4dc8]
> library(CppDebugHelper)
> breakpoint()
Program received signal SIGTRAP, Trace/breakpoint trap.
break_to_debugger () at break_to_debugger.cpp:33
33        a++;
(gdb) b debug_example_rcpp
Breakpoint 1 at 0x66ac6846: file debug_example_rcpp.cpp, line 13.
(gdb) c
Continuing.
[1] 4
> debug_example_rcpp()
Breakpoint 1, debug_example_rcpp () at debug_example_rcpp.cpp:13
13          CharacterVector cv   = CharacterVector::create("foo", "bar", NA_STRING, "hello")  ;
(gdb) n
14          NumericVector nv     = NumericVector::create(0.0, 1.0, NA_REAL, 10) ;
(gdb) n
16          DateVector dv        = DateVector::create( 14974, 14975, 15123, NA_REAL); // TODO how to use real dates instead?
(gdb) call dbg_print(nv)
[1]  0  1 NA 10
(gdb) call dbg_print(dbg_subset(nv, 1, 2))
[1]  1 NA
(gdb)


From pd@me@ @end|ng |rom cb@@dk  Thu Dec 12 10:56:30 2019
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Thu, 12 Dec 2019 09:56:30 +0000
Subject: [Rd] R 3.6.2 is released
Message-ID: <7F4152E4-727E-46C0-85D9-7318EB980FAB@cbs.dk>

The build system rolled up R-3.6.2.tar.gz (codename "Dark and Stormy Night") this morning.

The list below details the changes in this release.

You can get the source code from

http://cran.r-project.org/src/base/R-3/R-3.6.2.tar.gz

or wait for it to be mirrored at a CRAN site nearer to you.

Binaries for various platforms will appear in due course.


For the R Core Team,

Peter Dalgaard

These are the checksums (md5 and SHA-256) for the freshly created files, in case you wish
to check that they are uncorrupted:

MD5 (AUTHORS) = b9c44f9f78cab3184ad9898bebc854b4
MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
MD5 (FAQ) = 28a3942a7129877e9af1d5ea16202052
MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
MD5 (NEWS) = 45437b38c75e0248b527c00e6d42ee6a
MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
MD5 (NEWS.1) = eb78c4d053ec9c32b815cf0c2ebea801
MD5 (NEWS.2) = 591dcf615162127f904e4e461f330ce9
MD5 (R-latest.tar.gz) = 90d23d138cee26d275da14b58296e521
MD5 (README) = f468f281c919665e276a1b691decbbe6
MD5 (RESOURCES) = 529223fd3ffef95731d0a87353108435
MD5 (THANKS) = bb45f89c01d509721c47fd41f147da60
MD5 (VERSION-INFO.dcf) = 9c33701e25092aefc1d16beb5858f20f
MD5 (R-3/R-3.6.2.tar.gz) = 90d23d138cee26d275da14b58296e521


2cde824a7b18958e5f06b391c801c8288be0f84fa8934b7ddefef23c67e60c09  AUTHORS
e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3  COPYING.LIB
38219d9c6221ccfbf075ef03711b420a1aa8731f890c8f2337148b602a217c2d  FAQ
f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
0ceb6fbab3e0e29bc374683fd5c2ccd0c9c62ce8eca2a394a4603775b3ef129c  NEWS
4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
12b30c724117b1b2b11484673906a6dcd48a361f69fc420b36194f9218692d01  NEWS.1
ca04f78ffe54afa326fe3ed40e7e1411aca0000ed2fa5ead97ddf51c6aa5b7bc  NEWS.2
bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954  R-latest.tar.gz
2fdd3e90f23f32692d4b3a0c0452f2c219a10882033d1774f8cadf25886c3ddc  README
408737572ecc6e1135fdb2cf7a9dbb1a6cb27967c757f1771b8c39d1fd2f1ab9  RESOURCES
2a8dca916cd92229ef9e328f3610ca204809c262823b860252b42072dac2473a  THANKS
40cc7cea5f0e67cf8f2f7b25a534ae6bc53f38eae2ab2c2649a952ed37f0654a  VERSION-INFO.dcf
bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954  R-3/R-3.6.2.tar.gz

This is the relevant part of the NEWS file

CHANGES IN R 3.6.2:

  NEW FEATURES:

    * runmed(x, *) gains a new option na.action determining _how_ to
      handle NaN or NA in x.

    * dotchart() gains new options ann, xaxt, frame.plot and log.

  INSTALLATION on a UNIX-ALIKE:

    * Detection of the C stack direction has been moved from run-time
      to configure: this is safer with LTO builds and allows the
      detection to be overridden - see file config.site.

    * Source-code changes enable installation on platforms using gcc
      -fno-common (the expected default for gcc 10.x).

  C-LEVEL FACILITIES:

    * installTrChar (which is nowadays is wrapped by installChar) is
      defined in Rinternals.h.  (Neither are part of the API.)

  PACKAGE INSTALLATION:

    * Header Rconfig.h contains the value of FC_LEN_T deduced at
      installation which is used by the prototypes in headers
      R_ext/BLAS.h and R_ext/Lapack.h but to avoid extensive breakage
      this is only exposed when USE_FC_LEN_T is defined.

      If a package's C/C++ calls to BLAS/LAPACK allow for the 'hidden'
      arguments used by most Fortran compilers to pass the lengths of
      Fortran character arguments, define USE_FC_LEN_T and include
      Rconfig.h (possibly _via_ R.h) before including R_ext/BLAS.h or
      R_ext/Lapack.h.

    * A package with Fortran source code and perhaps C (but not C++)
      sources can request for its shared object/DLL to be linked by the
      Fortran compiler by including a line USE_FC_TO_LINK= in
      src/Makevars[.win] and using $(SHLIB_OPENMP_FFLAGS) as part of
      PKG_LIBS.

      The known reason for doing so is a package which uses Fortran
      (only) OpenMP on a platform where the Fortran OpenMP runtime is
      incompatible with the C one (e.g. gfortran 9.x with clang).

  UTILITIES:

    * R CMD check has a new option to mitigate checks leaving
      files/directories in /tmp.  See the 'R Internals' manual - this
      is part of --as-cran.

  Windows:

    * The default standard for C++ in package installation is C++11 (as
      it has been on other platforms where available since R 3.6.0: the
      default toolchain on Windows was defaulting to C++98).

  DEPRECATED AND DEFUNCT:

    * Support for specifying C++98 in package installation is
      deprecated.

    * Support in R CMD config for F77, FCPIFCPLAGS, CPP, CXXCPP and
      CXX98 and similar is deprecated.  (CPP is found from the system
      make and may well not be set.)

      Use $CC -E and $CXX -E instead of CPP and CXXCPP.

  BUG FIXES:

    * runmed(x, *) when x contains missing values now works
      consistently for both algorithm="Stuetzle" and "Turlach", and no
      longer segfaults for "Turlach", as reported by Hilmar Berger.

    * apply(diag(3), 2:3, mean) now gives a helpful error message.

    * dgamma(x, shape, log=TRUE) now longer overflows to Inf for shape
      < 1 and very small x, fixing PR#17577, reported by Jonathan
      Rougier.

    * Buffer overflow in building error messages fixed. Reported by
      Benjamin Tremblay.

    * options(str = .) is correctly initialized at package utils load
      time, now.  A consequence is that str() in scripts now is more
      consistent to interactive use, e.g., when displaying function(**)
      argument lists.

    * as.numeric(<call>) now gives correct error message.

    * Printing ls.str() no longer wrongly shows "<missing>" in rare
      cases.

    * Auto-printing S4 objects no longer duplicates the object, for
      faster speed and reduced memory consumption. Reported by Aaron
      Lun.

    * pchisq(<LRG>, <LRG>, ncp=100) no longer takes practically forever
      in some cases.  Hence ditto for corresponding qchisq() calls.

    * x %% L for finite x no longer returns NaN when L is infinite, nor
      suffers from cancellation for large finite L, thanks to Long Qu's
      PR#17611.

      Analogously, x %/% L and L %/% x suffer less from cancellation
      and return values corresponding to limits for large L.

    * grepl(NA, *) now returns logical as documented.

    * options(warn=1e11) is an error now, instead of later leading to C
      stack overflow because of infinite recursion.

    * R_tryCatch no longer transfers control for all conditions.
      Reported and patch provided by Lionel Henry in PR#17617.

    * format(object.size(.), digits=NULL) now works, fixing PR#17628
      reported by Jonathan Carroll.

    * get_all_vars(f, d) now also works for cases, e.g. where d
      contains a matrix.  Reported by Simon Wood in 2009 and patch
      provided by Ben Bolker in PR#13624.

      Additionally, it now also works when some variables are data
      frames, fixing PR#14905, reported by Patrick Breheny.

    * barplot() could get spacings wrong if there were exactly two bars
      PR#15522.  Patch by Michael Chirico.

    * power.t.test() works in more cases when returning values of n
      smaller than 2.

    * dotchart(*, pch=., groups=.) now works better.  Reported by
      Robert and confirmed by Nic Rochette in PR#16953.

    * canCoerce(obj, cl) no longer assumes length(class(obj)) == 1.

    * plot.formula(*, subset = *) now also works in a boundary case
      reported by Robert Schlicht (TU Dresden).

    * readBin() and writeBin() of a rawConnection() now also work in
      large cases, thanks to a report and proposal by Taeke Harkema in
      PR#17665.

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Thu Dec 12 16:34:59 2019
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Thu, 12 Dec 2019 10:34:59 -0500
Subject: [Rd] R 3.6.2 is released
In-Reply-To: <7F4152E4-727E-46C0-85D9-7318EB980FAB@cbs.dk>
References: <7F4152E4-727E-46C0-85D9-7318EB980FAB@cbs.dk>
Message-ID: <CAL6gwnK=S-ge7=doom2LM6AdgTmXNPxsHxD1YqDJA8tp1rF-vg@mail.gmail.com>

Hi.

Under R-news there is an entry for 3.6.2 patched regarding LAPACK. However,
when uncompresding the current R-patched, it creates R-Rc directories. Is
this a naming oversight or is the patched version actually the unadjusted
release candidate?

Thank you,

Avi

On Thu, Dec 12, 2019 at 4:58 AM Peter Dalgaard via R-devel <
r-devel at r-project.org> wrote:

> The build system rolled up R-3.6.2.tar.gz (codename "Dark and Stormy
> Night") this morning.
>
> The list below details the changes in this release.
>
> You can get the source code from
>
> http://cran.r-project.org/src/base/R-3/R-3.6.2.tar.gz
>
> or wait for it to be mirrored at a CRAN site nearer to you.
>
> Binaries for various platforms will appear in due course.
>
>
> For the R Core Team,
>
> Peter Dalgaard
>
> These are the checksums (md5 and SHA-256) for the freshly created files,
> in case you wish
> to check that they are uncorrupted:
>
> MD5 (AUTHORS) = b9c44f9f78cab3184ad9898bebc854b4
> MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
> MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
> MD5 (FAQ) = 28a3942a7129877e9af1d5ea16202052
> MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
> MD5 (NEWS) = 45437b38c75e0248b527c00e6d42ee6a
> MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
> MD5 (NEWS.1) = eb78c4d053ec9c32b815cf0c2ebea801
> MD5 (NEWS.2) = 591dcf615162127f904e4e461f330ce9
> MD5 (R-latest.tar.gz) = 90d23d138cee26d275da14b58296e521
> MD5 (README) = f468f281c919665e276a1b691decbbe6
> MD5 (RESOURCES) = 529223fd3ffef95731d0a87353108435
> MD5 (THANKS) = bb45f89c01d509721c47fd41f147da60
> MD5 (VERSION-INFO.dcf) = 9c33701e25092aefc1d16beb5858f20f
> MD5 (R-3/R-3.6.2.tar.gz) = 90d23d138cee26d275da14b58296e521
>
>
> 2cde824a7b18958e5f06b391c801c8288be0f84fa8934b7ddefef23c67e60c09  AUTHORS
> e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
> 6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3
> COPYING.LIB
> 38219d9c6221ccfbf075ef03711b420a1aa8731f890c8f2337148b602a217c2d  FAQ
> f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
> 0ceb6fbab3e0e29bc374683fd5c2ccd0c9c62ce8eca2a394a4603775b3ef129c  NEWS
> 4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
> 12b30c724117b1b2b11484673906a6dcd48a361f69fc420b36194f9218692d01  NEWS.1
> ca04f78ffe54afa326fe3ed40e7e1411aca0000ed2fa5ead97ddf51c6aa5b7bc  NEWS.2
> bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954
> R-latest.tar.gz
> 2fdd3e90f23f32692d4b3a0c0452f2c219a10882033d1774f8cadf25886c3ddc  README
> 408737572ecc6e1135fdb2cf7a9dbb1a6cb27967c757f1771b8c39d1fd2f1ab9  RESOURCES
> 2a8dca916cd92229ef9e328f3610ca204809c262823b860252b42072dac2473a  THANKS
> 40cc7cea5f0e67cf8f2f7b25a534ae6bc53f38eae2ab2c2649a952ed37f0654a
> VERSION-INFO.dcf
> bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954
> R-3/R-3.6.2.tar.gz
>
> This is the relevant part of the NEWS file
>
> CHANGES IN R 3.6.2:
>
>   NEW FEATURES:
>
>     * runmed(x, *) gains a new option na.action determining _how_ to
>       handle NaN or NA in x.
>
>     * dotchart() gains new options ann, xaxt, frame.plot and log.
>
>   INSTALLATION on a UNIX-ALIKE:
>
>     * Detection of the C stack direction has been moved from run-time
>       to configure: this is safer with LTO builds and allows the
>       detection to be overridden - see file config.site.
>
>     * Source-code changes enable installation on platforms using gcc
>       -fno-common (the expected default for gcc 10.x).
>
>   C-LEVEL FACILITIES:
>
>     * installTrChar (which is nowadays is wrapped by installChar) is
>       defined in Rinternals.h.  (Neither are part of the API.)
>
>   PACKAGE INSTALLATION:
>
>     * Header Rconfig.h contains the value of FC_LEN_T deduced at
>       installation which is used by the prototypes in headers
>       R_ext/BLAS.h and R_ext/Lapack.h but to avoid extensive breakage
>       this is only exposed when USE_FC_LEN_T is defined.
>
>       If a package's C/C++ calls to BLAS/LAPACK allow for the 'hidden'
>       arguments used by most Fortran compilers to pass the lengths of
>       Fortran character arguments, define USE_FC_LEN_T and include
>       Rconfig.h (possibly _via_ R.h) before including R_ext/BLAS.h or
>       R_ext/Lapack.h.
>
>     * A package with Fortran source code and perhaps C (but not C++)
>       sources can request for its shared object/DLL to be linked by the
>       Fortran compiler by including a line USE_FC_TO_LINK= in
>       src/Makevars[.win] and using $(SHLIB_OPENMP_FFLAGS) as part of
>       PKG_LIBS.
>
>       The known reason for doing so is a package which uses Fortran
>       (only) OpenMP on a platform where the Fortran OpenMP runtime is
>       incompatible with the C one (e.g. gfortran 9.x with clang).
>
>   UTILITIES:
>
>     * R CMD check has a new option to mitigate checks leaving
>       files/directories in /tmp.  See the 'R Internals' manual - this
>       is part of --as-cran.
>
>   Windows:
>
>     * The default standard for C++ in package installation is C++11 (as
>       it has been on other platforms where available since R 3.6.0: the
>       default toolchain on Windows was defaulting to C++98).
>
>   DEPRECATED AND DEFUNCT:
>
>     * Support for specifying C++98 in package installation is
>       deprecated.
>
>     * Support in R CMD config for F77, FCPIFCPLAGS, CPP, CXXCPP and
>       CXX98 and similar is deprecated.  (CPP is found from the system
>       make and may well not be set.)
>
>       Use $CC -E and $CXX -E instead of CPP and CXXCPP.
>
>   BUG FIXES:
>
>     * runmed(x, *) when x contains missing values now works
>       consistently for both algorithm="Stuetzle" and "Turlach", and no
>       longer segfaults for "Turlach", as reported by Hilmar Berger.
>
>     * apply(diag(3), 2:3, mean) now gives a helpful error message.
>
>     * dgamma(x, shape, log=TRUE) now longer overflows to Inf for shape
>       < 1 and very small x, fixing PR#17577, reported by Jonathan
>       Rougier.
>
>     * Buffer overflow in building error messages fixed. Reported by
>       Benjamin Tremblay.
>
>     * options(str = .) is correctly initialized at package utils load
>       time, now.  A consequence is that str() in scripts now is more
>       consistent to interactive use, e.g., when displaying function(**)
>       argument lists.
>
>     * as.numeric(<call>) now gives correct error message.
>
>     * Printing ls.str() no longer wrongly shows "<missing>" in rare
>       cases.
>
>     * Auto-printing S4 objects no longer duplicates the object, for
>       faster speed and reduced memory consumption. Reported by Aaron
>       Lun.
>
>     * pchisq(<LRG>, <LRG>, ncp=100) no longer takes practically forever
>       in some cases.  Hence ditto for corresponding qchisq() calls.
>
>     * x %% L for finite x no longer returns NaN when L is infinite, nor
>       suffers from cancellation for large finite L, thanks to Long Qu's
>       PR#17611.
>
>       Analogously, x %/% L and L %/% x suffer less from cancellation
>       and return values corresponding to limits for large L.
>
>     * grepl(NA, *) now returns logical as documented.
>
>     * options(warn=1e11) is an error now, instead of later leading to C
>       stack overflow because of infinite recursion.
>
>     * R_tryCatch no longer transfers control for all conditions.
>       Reported and patch provided by Lionel Henry in PR#17617.
>
>     * format(object.size(.), digits=NULL) now works, fixing PR#17628
>       reported by Jonathan Carroll.
>
>     * get_all_vars(f, d) now also works for cases, e.g. where d
>       contains a matrix.  Reported by Simon Wood in 2009 and patch
>       provided by Ben Bolker in PR#13624.
>
>       Additionally, it now also works when some variables are data
>       frames, fixing PR#14905, reported by Patrick Breheny.
>
>     * barplot() could get spacings wrong if there were exactly two bars
>       PR#15522.  Patch by Michael Chirico.
>
>     * power.t.test() works in more cases when returning values of n
>       smaller than 2.
>
>     * dotchart(*, pch=., groups=.) now works better.  Reported by
>       Robert and confirmed by Nic Rochette in PR#16953.
>
>     * canCoerce(obj, cl) no longer assumes length(class(obj)) == 1.
>
>     * plot.formula(*, subset = *) now also works in a boundary case
>       reported by Robert Schlicht (TU Dresden).
>
>     * readBin() and writeBin() of a rawConnection() now also work in
>       large cases, thanks to a report and proposal by Taeke Harkema in
>       PR#17665.
>
> --
> Peter Dalgaard, Professor,
> Center for Statistics, Copenhagen Business School
> Solbjerg Plads 3, 2000 Frederiksberg, Denmark
> <https://www.google.com/maps/search/Solbjerg+Plads+3,+2000+Frederiksberg,+Denmark?entry=gmail&source=g>
> Phone: (+45)38153501
> Office: A 4.23
> Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


From pd@me@ @end|ng |rom cb@@dk  Thu Dec 12 17:10:44 2019
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Thu, 12 Dec 2019 16:10:44 +0000
Subject: [Rd] R 3.6.2 is released
In-Reply-To: <CAL6gwnK=S-ge7=doom2LM6AdgTmXNPxsHxD1YqDJA8tp1rF-vg@mail.gmail.com>
References: <7F4152E4-727E-46C0-85D9-7318EB980FAB@cbs.dk>
 <CAL6gwnK=S-ge7=doom2LM6AdgTmXNPxsHxD1YqDJA8tp1rF-vg@mail.gmail.com>
Message-ID: <6CDCF807-577F-4ED8-80F7-7894A82BC821@cbs.dk>

It is not obvious what it is that you are calling "R-patched", nor where there could be an entry for "3.6.2 patched".

The prerelease/patched versions are snapshots of R-3-6-branch made at 00:20 so the current one will have been made before the release version run started at 09:00 this morning, and hence the nightly tarball will be of the release candidate. However it will not be called R-patched:

lrwxr-xr-x  1 pd  staff        29 Dec 12 00:20 R-latest.tar.gz -> R-rc_2019-12-06_r77555.tar.gz

The current version in SVN differs only by the VERSION file. Its NEWS.Rd starts

Peters-MacBook-Air:R pd$ more VERSION
3.6.2 Patched
Peters-MacBook-Air:R pd$ more doc/NEWS.Rd
% -*- coding: utf-8 -*-
\newcommand{\Rlogo}{\if{html}{\figure{../../html/Rlogo.svg}{options: class="toplogo" alt="[R logo]"}}\if{latex}{\figure{Rlogo.pdf}{options: width=0.5in}}}

\name{NEWS}
\title{R News}
\encoding{UTF-8}

\section{\Rlogo CHANGES IN R 3.6.2}{

  \subsection{NEW FEATURES}{
    \itemize{
  ....

and any changes for 3.6.2 patched should go above the entries for 3.6.2.

- pd


> On 12 Dec 2019, at 16:34 , Avraham Adler <avraham.adler at gmail.com> wrote:
> 
> Hi. 
> 
> Under R-news there is an entry for 3.6.2 patched regarding LAPACK. However, when uncompresding the current R-patched, it creates R-Rc directories. Is this a naming oversight or is the patched version actually the unadjusted release candidate?
> 
> Thank you,
> 
> Avi
> 
> On Thu, Dec 12, 2019 at 4:58 AM Peter Dalgaard via R-devel <r-devel at r-project.org> wrote:
> The build system rolled up R-3.6.2.tar.gz (codename "Dark and Stormy Night") this morning.
> 
> The list below details the changes in this release.
> 
> You can get the source code from
> 
> http://cran.r-project.org/src/base/R-3/R-3.6.2.tar.gz
> 
> or wait for it to be mirrored at a CRAN site nearer to you.
> 
> Binaries for various platforms will appear in due course.
> 
> 
> For the R Core Team,
> 
> Peter Dalgaard
> 
> These are the checksums (md5 and SHA-256) for the freshly created files, in case you wish
> to check that they are uncorrupted:
> 
> MD5 (AUTHORS) = b9c44f9f78cab3184ad9898bebc854b4
> MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
> MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
> MD5 (FAQ) = 28a3942a7129877e9af1d5ea16202052
> MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
> MD5 (NEWS) = 45437b38c75e0248b527c00e6d42ee6a
> MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
> MD5 (NEWS.1) = eb78c4d053ec9c32b815cf0c2ebea801
> MD5 (NEWS.2) = 591dcf615162127f904e4e461f330ce9
> MD5 (R-latest.tar.gz) = 90d23d138cee26d275da14b58296e521
> MD5 (README) = f468f281c919665e276a1b691decbbe6
> MD5 (RESOURCES) = 529223fd3ffef95731d0a87353108435
> MD5 (THANKS) = bb45f89c01d509721c47fd41f147da60
> MD5 (VERSION-INFO.dcf) = 9c33701e25092aefc1d16beb5858f20f
> MD5 (R-3/R-3.6.2.tar.gz) = 90d23d138cee26d275da14b58296e521
> 
> 
> 2cde824a7b18958e5f06b391c801c8288be0f84fa8934b7ddefef23c67e60c09  AUTHORS
> e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
> 6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3  COPYING.LIB
> 38219d9c6221ccfbf075ef03711b420a1aa8731f890c8f2337148b602a217c2d  FAQ
> f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
> 0ceb6fbab3e0e29bc374683fd5c2ccd0c9c62ce8eca2a394a4603775b3ef129c  NEWS
> 4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
> 12b30c724117b1b2b11484673906a6dcd48a361f69fc420b36194f9218692d01  NEWS.1
> ca04f78ffe54afa326fe3ed40e7e1411aca0000ed2fa5ead97ddf51c6aa5b7bc  NEWS.2
> bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954  R-latest.tar.gz
> 2fdd3e90f23f32692d4b3a0c0452f2c219a10882033d1774f8cadf25886c3ddc  README
> 408737572ecc6e1135fdb2cf7a9dbb1a6cb27967c757f1771b8c39d1fd2f1ab9  RESOURCES
> 2a8dca916cd92229ef9e328f3610ca204809c262823b860252b42072dac2473a  THANKS
> 40cc7cea5f0e67cf8f2f7b25a534ae6bc53f38eae2ab2c2649a952ed37f0654a  VERSION-INFO.dcf
> bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954  R-3/R-3.6.2.tar.gz
> 
> This is the relevant part of the NEWS file
> 
> CHANGES IN R 3.6.2:
> 
>   NEW FEATURES:
> 
>     * runmed(x, *) gains a new option na.action determining _how_ to
>       handle NaN or NA in x.
> 
>     * dotchart() gains new options ann, xaxt, frame.plot and log.
> 
>   INSTALLATION on a UNIX-ALIKE:
> 
>     * Detection of the C stack direction has been moved from run-time
>       to configure: this is safer with LTO builds and allows the
>       detection to be overridden - see file config.site.
> 
>     * Source-code changes enable installation on platforms using gcc
>       -fno-common (the expected default for gcc 10.x).
> 
>   C-LEVEL FACILITIES:
> 
>     * installTrChar (which is nowadays is wrapped by installChar) is
>       defined in Rinternals.h.  (Neither are part of the API.)
> 
>   PACKAGE INSTALLATION:
> 
>     * Header Rconfig.h contains the value of FC_LEN_T deduced at
>       installation which is used by the prototypes in headers
>       R_ext/BLAS.h and R_ext/Lapack.h but to avoid extensive breakage
>       this is only exposed when USE_FC_LEN_T is defined.
> 
>       If a package's C/C++ calls to BLAS/LAPACK allow for the 'hidden'
>       arguments used by most Fortran compilers to pass the lengths of
>       Fortran character arguments, define USE_FC_LEN_T and include
>       Rconfig.h (possibly _via_ R.h) before including R_ext/BLAS.h or
>       R_ext/Lapack.h.
> 
>     * A package with Fortran source code and perhaps C (but not C++)
>       sources can request for its shared object/DLL to be linked by the
>       Fortran compiler by including a line USE_FC_TO_LINK= in
>       src/Makevars[.win] and using $(SHLIB_OPENMP_FFLAGS) as part of
>       PKG_LIBS.
> 
>       The known reason for doing so is a package which uses Fortran
>       (only) OpenMP on a platform where the Fortran OpenMP runtime is
>       incompatible with the C one (e.g. gfortran 9.x with clang).
> 
>   UTILITIES:
> 
>     * R CMD check has a new option to mitigate checks leaving
>       files/directories in /tmp.  See the 'R Internals' manual - this
>       is part of --as-cran.
> 
>   Windows:
> 
>     * The default standard for C++ in package installation is C++11 (as
>       it has been on other platforms where available since R 3.6.0: the
>       default toolchain on Windows was defaulting to C++98).
> 
>   DEPRECATED AND DEFUNCT:
> 
>     * Support for specifying C++98 in package installation is
>       deprecated.
> 
>     * Support in R CMD config for F77, FCPIFCPLAGS, CPP, CXXCPP and
>       CXX98 and similar is deprecated.  (CPP is found from the system
>       make and may well not be set.)
> 
>       Use $CC -E and $CXX -E instead of CPP and CXXCPP.
> 
>   BUG FIXES:
> 
>     * runmed(x, *) when x contains missing values now works
>       consistently for both algorithm="Stuetzle" and "Turlach", and no
>       longer segfaults for "Turlach", as reported by Hilmar Berger.
> 
>     * apply(diag(3), 2:3, mean) now gives a helpful error message.
> 
>     * dgamma(x, shape, log=TRUE) now longer overflows to Inf for shape
>       < 1 and very small x, fixing PR#17577, reported by Jonathan
>       Rougier.
> 
>     * Buffer overflow in building error messages fixed. Reported by
>       Benjamin Tremblay.
> 
>     * options(str = .) is correctly initialized at package utils load
>       time, now.  A consequence is that str() in scripts now is more
>       consistent to interactive use, e.g., when displaying function(**)
>       argument lists.
> 
>     * as.numeric(<call>) now gives correct error message.
> 
>     * Printing ls.str() no longer wrongly shows "<missing>" in rare
>       cases.
> 
>     * Auto-printing S4 objects no longer duplicates the object, for
>       faster speed and reduced memory consumption. Reported by Aaron
>       Lun.
> 
>     * pchisq(<LRG>, <LRG>, ncp=100) no longer takes practically forever
>       in some cases.  Hence ditto for corresponding qchisq() calls.
> 
>     * x %% L for finite x no longer returns NaN when L is infinite, nor
>       suffers from cancellation for large finite L, thanks to Long Qu's
>       PR#17611.
> 
>       Analogously, x %/% L and L %/% x suffer less from cancellation
>       and return values corresponding to limits for large L.
> 
>     * grepl(NA, *) now returns logical as documented.
> 
>     * options(warn=1e11) is an error now, instead of later leading to C
>       stack overflow because of infinite recursion.
> 
>     * R_tryCatch no longer transfers control for all conditions.
>       Reported and patch provided by Lionel Henry in PR#17617.
> 
>     * format(object.size(.), digits=NULL) now works, fixing PR#17628
>       reported by Jonathan Carroll.
> 
>     * get_all_vars(f, d) now also works for cases, e.g. where d
>       contains a matrix.  Reported by Simon Wood in 2009 and patch
>       provided by Ben Bolker in PR#13624.
> 
>       Additionally, it now also works when some variables are data
>       frames, fixing PR#14905, reported by Patrick Breheny.
> 
>     * barplot() could get spacings wrong if there were exactly two bars
>       PR#15522.  Patch by Michael Chirico.
> 
>     * power.t.test() works in more cases when returning values of n
>       smaller than 2.
> 
>     * dotchart(*, pch=., groups=.) now works better.  Reported by
>       Robert and confirmed by Nic Rochette in PR#16953.
> 
>     * canCoerce(obj, cl) no longer assumes length(class(obj)) == 1.
> 
>     * plot.formula(*, subset = *) now also works in a boundary case
>       reported by Robert Schlicht (TU Dresden).
> 
>     * readBin() and writeBin() of a rawConnection() now also work in
>       large cases, thanks to a report and proposal by Taeke Harkema in
>       PR#17665.
> 
> -- 
> Peter Dalgaard, Professor,
> Center for Statistics, Copenhagen Business School
> Solbjerg Plads 3, 2000 Frederiksberg, Denmark
> Phone: (+45)38153501
> Office: A 4.23
> Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> -- 
> Sent from Gmail Mobile

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec 12 17:20:47 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 12 Dec 2019 17:20:47 +0100
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <20191209214336.iy66s5q4nzawdfch@PMW>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
 <20191207205901.4265F22877@v-lynne.math.ethz.ch>
 <20191207211858.dpnqeslbln5caz2v@PMW>
 <20191209214336.iy66s5q4nzawdfch@PMW>
Message-ID: <24050.26847.78668.28633@stat.math.ethz.ch>

>>>>> Karolis Koncevi?ius 
>>>>>     on Mon, 9 Dec 2019 23:43:36 +0200 writes:

    > So I tried adding Infinity support for all cases.
    > And it is (as could be expected) more complicated than I thought.

"Of course !"   Thank you, Karolis, in any case!

    > It is easy to add Inf support for the test. The problems start with conf.int=TRUE.

    > Currently confidence intervals are computed via `uniroot()` and, in the 
    > case of infinities, we are computationally looking for roots over 
    > infinite interval which results in an error. I suspect this is the 
    > reason Inf values were removed in the first place.

Maybe. It's still wrong to be done "up front".
I'm sure 98% (or so ;-) of all calls to wilcox.test() do *not*
use  conf.int = TRUE


    > Just a note, I found a few more errors/inconsistencies when requesting 
    > confidence intervals with paired=TRUE (due to Infinities being left in).

    > Current error in Inf-Inf scenario:

    > wilcox.test(c(1,2,Inf), c(4,8,Inf), paired=TRUE, conf.int=TRUE)
    > Error in if (ZEROES) x <- x[x != 0] :
    > missing value where TRUE/FALSE needed

Good catch .. notably as it also happens when conf.int=FALSE as
by default.
My version of wilcox.test() now does give the same as when the
to 'Inf' are left away.

    > NaN confidence intervals:

    > wilcox.test(c(1:9,Inf), c(21:28,Inf,30), paired=TRUE, conf.int=TRUE)

    > Wilcoxon signed rank test with continuity correction

    > data:  c(1:9, Inf) and c(21:28, Inf, 30)
    > V = 9.5, p-value = 0.0586
    > alternative hypothesis: true location shift is not equal to 0
    > 0 percent confidence interval:
    > NaN NaN
    > sample estimates:
    > midrange
    > NaN

I don't see a big problem here. The NaN's in some sense show the
best that can be computed with this data.  Statistic and
P-value, but no conf.int.


    > The easiest "fix" for consistency would be to simply remove Infinity 
    > support from the paired=TRUE case.

I strongly disagree.  We are not pruning good functionality just
for some definition of consistency.

    > But going with the more desirable approach of adding Infinity support 
    > for non-paired cases - it is currently not clear to me what confidence 
    > intervals and pseudomedian should be. Specially when Infinities are on 
    > both sides.

I deem that not to be a big deal.  They are not defined given
the default formulas and that is reflected by NA / NaN  in those
parts of the result.

    > Regards,
    > Karolis Koncevi?ius.

But I have also spent a few hours now on wilcox.test.default() behavior
notably also looking at the "rounding" / "machine precision"
situation, and also on your remark that the 'method: ...' does
not indicate well enough what was computed.

In my (not yet committed) but hereby proposed  enhancement of wilcox.test(),
I have a new argument,  'digits.rank = Inf'  (the default 'Inf'
corresponding to the current behavior)
with help page documentation:

digits.rank: a number; if finite, ?rank(signif(r, digits.rank))? will
          be used to compute ranks for the test statistic instead of
          (the default) ?rank(r)?.

and then in 'Details :'

     For stability reasons, it may be advisable to use rounded data or
     to set ?digits.rank = 7?, say, such that determination of ties
     does not depend on very small numeric differences (see the
     example).

and then in 'Examples: '

     ## accuracy in ties determination via 'digits.rank':
     wilcox.test( 4:2,      3:1,     paired=TRUE) # Warning:  cannot compute exact p-value with ties
     wilcox.test((4:2)/10, (3:1)/10, paired=TRUE) # no ties => *no* warning
     wilcox.test((4:2)/10, (3:1)/10, paired=TRUE, digits.rank = 9) # same ties as (4:2, 3:1)
     
----------------------

Lastly, I propose to replace  "test" by "exact test" in the
'method' component (and print out) in case exact computations
were used.  This information should be part of the returned
"htest" object, and not only visible from the arguments and warnings that are
printed during the computations.
This last change is in some sense the  "most back-incompatible"
change of these,  because many  wilcox.test()  printouts would
slightly change, e.g., 

  > w0 <- wilcox.test( 1:5, 4*(0:4), paired=TRUE)

	  Wilcoxon signed rank exact test

  data:  1:5 and 4 * (0:4)
  V = 1, p-value = 0.125
  alternative hypothesis: true location shift is not equal to 0

where before (in R <= 3.6.x)  it is just

	  Wilcoxon signed rank test

  data: .........
  ...............
  ...............

but I think R 4.0.0 is a good occasion for such a change.

Constructive feedback on all this is very welcome!
Martin




    > On 2019-12-07 23:18, Karolis Koncevi?ius wrote:
    >> Thank you for a fast response. Nice to see this mailing list being so 
    >> alive.
    >> 
    >> Regarding Inf issue: I agree with your assessment that Inf should not 
    >> be removed. The code gave me an impression that Inf values were 
    >> intentionally removed (since is.finite() was used everywhere, except 
    >> for paired case). I will try to adjust my patch according to your 
    >> feedback.
    >> 
    >> One more thing: it seems like you assumed that issues 2:4 are all 
    >> related to machine precision, which is not the case - only 2nd issue 
    >> is.
    >> Just wanted to draw this to your attention, in case you might have 
    >> some feedback and guidelines about issues 3 and 4 as well.
    >> 
    >> 
    >> 
    >> On 2019-12-07 21:59, Martin Maechler wrote:
    >>>>>>>> Karolis Koncevi?ius
    >>>>>>>> on Sat, 7 Dec 2019 20:55:36 +0200 writes:
    >>> 
    >>> > Hello,
    >>> > Writing to share some things I've found about wilcox.test() that seem a
    >>> > a bit inconsistent.
    >>> 
    >>> > 1. Inf values are not removed if paired=TRUE
    >>> 
    >>> > # returns different results (Inf is removed):
    >>> > wilcox.test(c(1,2,3,4), c(0,9,8,7))
    >>> > wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
    >>> 
    >>> > # returns the same result (Inf is left as value with highest rank):
    >>> > wilcox.test(c(1,2,3,4), c(0,9,8,7), paired=TRUE)
    >>> > wilcox.test(c(1,2,3,4), c(0,9,8,Inf), paired=TRUE)
    >>> 
    >>> Now which of the two cases do you consider correct ?
    >>> 
    >>> IHMO, the 2nd one is correct: it is exactly one property of the
    >>> *robustness* of the wilcoxon test and very desirable that any
    >>> (positive) outlier is treated the same as just "the largest
    >>> value" and the test statistic (and hence the p-value) should not
    >>> change.
    >>> 
    >>> So I think the first case is wrong, notably if modified, (such
    >>> that the last  y  is the overall maximal value (slightly larger sample):
    >>> 
    >>>> wilcox.test(1:7, 1/8+ c(9:4, 12))
    >>> 
    >>> Wilcoxon rank sum test
    >>> 
    >>> data:  1:7 and 1/8 + c(9:4, 12)
    >>> W = 6, p-value = 0.01748
    >>> alternative hypothesis: true location shift is not equal to 0
    >>> 
    >>>> wilcox.test(1:7, 1/8+ c(9:4, 10000))
    >>> 
    >>> Wilcoxon rank sum test
    >>> 
    >>> data:  1:7 and 1/8 + c(9:4, 10000)
    >>> W = 6, p-value = 0.01748
    >>> alternative hypothesis: true location shift is not equal to 0
    >>> 
    >>>> wilcox.test(1:7, 1/8+ c(9:4, Inf))
    >>> 
    >>> Wilcoxon rank sum test
    >>> 
    >>> data:  1:7 and 1/8 + c(9:4, Inf)
    >>> W = 6, p-value = 0.03497
    >>> alternative hypothesis: true location shift is not equal to 0
    >>> 
    >>> The  Inf  case should definitely give the same as the  10'000 case.
    >>> That's exactly one property of a robust statistic.
    >>> 
    >>> Thank you, Karolis, this is pretty embarrassing to only be detected now after 25+ years of R in use ...
    >>> 
    >>> The correct fix starts with replacing the  is.finite()  by   !is.na() and keep the 'Inf' in the rank computations...
    >>> (but then probably also deal with the case of more than one Inf, notably the  Inf - Inf  "exception" which is not triggered by your example...)
    >>> 
    >>> 
    >>> ---
    >>> 
    >>> Ben addressed the "rounding" / numerical issues unavoidable for
    >>> the other problems.
    >>> 
    >>> > 2. tolerance issues with paired=TRUE.
    >>> 
    >>> > wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE)
    >>> > # ...
    >>> > # Warning:  cannot compute exact p-value with ties
    >>> 
    >>> > wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1), paired=TRUE)
    >>> > # ...
    >>> > # no warning
    >>> 
    >>> > 3. Always 'x observations are missing' when paired=TRUE
    >>> 
    >>> > wilcox.test(c(1,2), c(NA_integer_,NA_integer_), paired=TRUE)
    >>> > # ...
    >>> > # Error:  not enough (finite) 'x' observations
    >>> 
    >>> > 4. No indication if normal approximation was used:
    >>> 
    >>> > # different numbers, but same "method" name
    >>> > wilcox.test(rnorm(10), exact=FALSE, correct=FALSE)
    >>> > wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
    >>> 
    >>> 
    >>> > From all of these I am pretty sure the 1st one is likely unintended,
    >>> > so attaching a small patch to adjust it. Can also try patching others if
    >>> > consensus is reached that the behavioiur has to be modified.
    >>> 
    >>> > Kind regards,
    >>> > Karolis Koncevi?ius.
    >>> 
    >>> > ---
    >>> 
    >>> > Index: wilcox.test.R
    >>> > ===================================================================
    >>> > --- wilcox.test.R  (revision 77540)
    >>> > +++ wilcox.test.R  (working copy)
    >>> > @@ -42,7 +42,7 @@
    >>> > if(paired) {
    >>> > if(length(x) != length(y))
    >>> > stop("'x' and 'y' must have the same length")
    >>> > -            OK <- complete.cases(x, y)
    >>> > +            OK <- is.finite(x) & is.finite(y)
    >>> > x <- x[OK] - y[OK]
    >>> > y <- NULL
    >>> > }
    >>> 
    >>> > ______________________________________________
    >>> > R-devel at r-project.org mailing list
    >>> > https://stat.ethz.ch/mailman/listinfo/r-devel


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Thu Dec 12 18:05:06 2019
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Thu, 12 Dec 2019 12:05:06 -0500
Subject: [Rd] R 3.6.2 is released
In-Reply-To: <6CDCF807-577F-4ED8-80F7-7894A82BC821@cbs.dk>
References: <7F4152E4-727E-46C0-85D9-7318EB980FAB@cbs.dk>
 <CAL6gwnK=S-ge7=doom2LM6AdgTmXNPxsHxD1YqDJA8tp1rF-vg@mail.gmail.com>
 <6CDCF807-577F-4ED8-80F7-7894A82BC821@cbs.dk>
Message-ID: <CAL6gwn+Rm_m5pK9bNJZah-n0zS4JDDmga9R2A5Qe5c_jkzZ4Ag@mail.gmail.com>

Thank you.

I apologize for not providing the link. [1] Under the news for R-revel
there is a single entry for R 3.6.2-patched.

The file I downloaded was [2] with a date of 2019-12-12 01:50.

Is it safe to say that 3.6.2 has the LAPACK upgrades and fixes?

Apologies in advance if iOS links the URL below. I cannot access gmail
desktop from behind my corporate firewall.

Thank you again,

Avi

[1]
https://cran.r-project.org/doc/manuals/r-devel/NEWS.html
[2]
https://stat.ethz.ch/R/daily/R-patched.tar.gz

On Thu, Dec 12, 2019 at 11:10 AM Peter Dalgaard <pd.mes at cbs.dk> wrote:

> It is not obvious what it is that you are calling "R-patched", nor where
> there could be an entry for "3.6.2 patched".
>
> The prerelease/patched versions are snapshots of R-3-6-branch made at
> 00:20 so the current one will have been made before the release version run
> started at 09:00 this morning, and hence the nightly tarball will be of the
> release candidate. However it will not be called R-patched:
>
> lrwxr-xr-x  1 pd  staff        29 Dec 12 00:20 R-latest.tar.gz ->
> R-rc_2019-12-06_r77555.tar.gz
>
> The current version in SVN differs only by the VERSION file. Its NEWS.Rd
> starts
>
> Peters-MacBook-Air:R pd$ more VERSION
> 3.6.2 Patched
> Peters-MacBook-Air:R pd$ more doc/NEWS.Rd
> % -*- coding: utf-8 -*-
> \newcommand{\Rlogo}{\if{html}{\figure{../../html/Rlogo.svg}{options:
> class="toplogo" alt="[R logo]"}}\if{latex}{\figure{Rlogo.pdf}{options:
> width=0.5in}}}
>
> \name{NEWS}
> \title{R News}
> \encoding{UTF-8}
>
> \section{\Rlogo CHANGES IN R 3.6.2}{
>
>   \subsection{NEW FEATURES}{
>     \itemize{
>   ....
>
> and any changes for 3.6.2 patched should go above the entries for 3.6.2.
>
> - pd
>
>
> > On 12 Dec 2019, at 16:34 , Avraham Adler <avraham.adler at gmail.com>
> wrote:
> >
> > Hi.
> >
> > Under R-news there is an entry for 3.6.2 patched regarding LAPACK.
> However, when uncompresding the current R-patched, it creates R-Rc
> directories. Is this a naming oversight or is the patched version actually
> the unadjusted release candidate?
> >
> > Thank you,
> >
> > Avi
> >
> > On Thu, Dec 12, 2019 at 4:58 AM Peter Dalgaard via R-devel <
> r-devel at r-project.org> wrote:
> > The build system rolled up R-3.6.2.tar.gz (codename "Dark and Stormy
> Night") this morning.
> >
> > The list below details the changes in this release.
> >
> > You can get the source code from
> >
> > http://cran.r-project.org/src/base/R-3/R-3.6.2.tar.gz
> >
> > or wait for it to be mirrored at a CRAN site nearer to you.
> >
> > Binaries for various platforms will appear in due course.
> >
> >
> > For the R Core Team,
> >
> > Peter Dalgaard
> >
> > These are the checksums (md5 and SHA-256) for the freshly created files,
> in case you wish
> > to check that they are uncorrupted:
> >
> > MD5 (AUTHORS) = b9c44f9f78cab3184ad9898bebc854b4
> > MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
> > MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
> > MD5 (FAQ) = 28a3942a7129877e9af1d5ea16202052
> > MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
> > MD5 (NEWS) = 45437b38c75e0248b527c00e6d42ee6a
> > MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
> > MD5 (NEWS.1) = eb78c4d053ec9c32b815cf0c2ebea801
> > MD5 (NEWS.2) = 591dcf615162127f904e4e461f330ce9
> > MD5 (R-latest.tar.gz) = 90d23d138cee26d275da14b58296e521
> > MD5 (README) = f468f281c919665e276a1b691decbbe6
> > MD5 (RESOURCES) = 529223fd3ffef95731d0a87353108435
> > MD5 (THANKS) = bb45f89c01d509721c47fd41f147da60
> > MD5 (VERSION-INFO.dcf) = 9c33701e25092aefc1d16beb5858f20f
> > MD5 (R-3/R-3.6.2.tar.gz) = 90d23d138cee26d275da14b58296e521
> >
> >
> > 2cde824a7b18958e5f06b391c801c8288be0f84fa8934b7ddefef23c67e60c09  AUTHORS
> > e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
> > 6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3
> COPYING.LIB
> > 38219d9c6221ccfbf075ef03711b420a1aa8731f890c8f2337148b602a217c2d  FAQ
> > f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
> > 0ceb6fbab3e0e29bc374683fd5c2ccd0c9c62ce8eca2a394a4603775b3ef129c  NEWS
> > 4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
> > 12b30c724117b1b2b11484673906a6dcd48a361f69fc420b36194f9218692d01  NEWS.1
> > ca04f78ffe54afa326fe3ed40e7e1411aca0000ed2fa5ead97ddf51c6aa5b7bc  NEWS.2
> > bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954
> R-latest.tar.gz
> > 2fdd3e90f23f32692d4b3a0c0452f2c219a10882033d1774f8cadf25886c3ddc  README
> > 408737572ecc6e1135fdb2cf7a9dbb1a6cb27967c757f1771b8c39d1fd2f1ab9
> RESOURCES
> > 2a8dca916cd92229ef9e328f3610ca204809c262823b860252b42072dac2473a  THANKS
> > 40cc7cea5f0e67cf8f2f7b25a534ae6bc53f38eae2ab2c2649a952ed37f0654a
> VERSION-INFO.dcf
> > bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954
> R-3/R-3.6.2.tar.gz
> >
> > This is the relevant part of the NEWS file
> >
> > CHANGES IN R 3.6.2:
> >
> >   NEW FEATURES:
> >
> >     * runmed(x, *) gains a new option na.action determining _how_ to
> >       handle NaN or NA in x.
> >
> >     * dotchart() gains new options ann, xaxt, frame.plot and log.
> >
> >   INSTALLATION on a UNIX-ALIKE:
> >
> >     * Detection of the C stack direction has been moved from run-time
> >       to configure: this is safer with LTO builds and allows the
> >       detection to be overridden - see file config.site.
> >
> >     * Source-code changes enable installation on platforms using gcc
> >       -fno-common (the expected default for gcc 10.x).
> >
> >   C-LEVEL FACILITIES:
> >
> >     * installTrChar (which is nowadays is wrapped by installChar) is
> >       defined in Rinternals.h.  (Neither are part of the API.)
> >
> >   PACKAGE INSTALLATION:
> >
> >     * Header Rconfig.h contains the value of FC_LEN_T deduced at
> >       installation which is used by the prototypes in headers
> >       R_ext/BLAS.h and R_ext/Lapack.h but to avoid extensive breakage
> >       this is only exposed when USE_FC_LEN_T is defined.
> >
> >       If a package's C/C++ calls to BLAS/LAPACK allow for the 'hidden'
> >       arguments used by most Fortran compilers to pass the lengths of
> >       Fortran character arguments, define USE_FC_LEN_T and include
> >       Rconfig.h (possibly _via_ R.h) before including R_ext/BLAS.h or
> >       R_ext/Lapack.h.
> >
> >     * A package with Fortran source code and perhaps C (but not C++)
> >       sources can request for its shared object/DLL to be linked by the
> >       Fortran compiler by including a line USE_FC_TO_LINK= in
> >       src/Makevars[.win] and using $(SHLIB_OPENMP_FFLAGS) as part of
> >       PKG_LIBS.
> >
> >       The known reason for doing so is a package which uses Fortran
> >       (only) OpenMP on a platform where the Fortran OpenMP runtime is
> >       incompatible with the C one (e.g. gfortran 9.x with clang).
> >
> >   UTILITIES:
> >
> >     * R CMD check has a new option to mitigate checks leaving
> >       files/directories in /tmp.  See the 'R Internals' manual - this
> >       is part of --as-cran.
> >
> >   Windows:
> >
> >     * The default standard for C++ in package installation is C++11 (as
> >       it has been on other platforms where available since R 3.6.0: the
> >       default toolchain on Windows was defaulting to C++98).
> >
> >   DEPRECATED AND DEFUNCT:
> >
> >     * Support for specifying C++98 in package installation is
> >       deprecated.
> >
> >     * Support in R CMD config for F77, FCPIFCPLAGS, CPP, CXXCPP and
> >       CXX98 and similar is deprecated.  (CPP is found from the system
> >       make and may well not be set.)
> >
> >       Use $CC -E and $CXX -E instead of CPP and CXXCPP.
> >
> >   BUG FIXES:
> >
> >     * runmed(x, *) when x contains missing values now works
> >       consistently for both algorithm="Stuetzle" and "Turlach", and no
> >       longer segfaults for "Turlach", as reported by Hilmar Berger.
> >
> >     * apply(diag(3), 2:3, mean) now gives a helpful error message.
> >
> >     * dgamma(x, shape, log=TRUE) now longer overflows to Inf for shape
> >       < 1 and very small x, fixing PR#17577, reported by Jonathan
> >       Rougier.
> >
> >     * Buffer overflow in building error messages fixed. Reported by
> >       Benjamin Tremblay.
> >
> >     * options(str = .) is correctly initialized at package utils load
> >       time, now.  A consequence is that str() in scripts now is more
> >       consistent to interactive use, e.g., when displaying function(**)
> >       argument lists.
> >
> >     * as.numeric(<call>) now gives correct error message.
> >
> >     * Printing ls.str() no longer wrongly shows "<missing>" in rare
> >       cases.
> >
> >     * Auto-printing S4 objects no longer duplicates the object, for
> >       faster speed and reduced memory consumption. Reported by Aaron
> >       Lun.
> >
> >     * pchisq(<LRG>, <LRG>, ncp=100) no longer takes practically forever
> >       in some cases.  Hence ditto for corresponding qchisq() calls.
> >
> >     * x %% L for finite x no longer returns NaN when L is infinite, nor
> >       suffers from cancellation for large finite L, thanks to Long Qu's
> >       PR#17611.
> >
> >       Analogously, x %/% L and L %/% x suffer less from cancellation
> >       and return values corresponding to limits for large L.
> >
> >     * grepl(NA, *) now returns logical as documented.
> >
> >     * options(warn=1e11) is an error now, instead of later leading to C
> >       stack overflow because of infinite recursion.
> >
> >     * R_tryCatch no longer transfers control for all conditions.
> >       Reported and patch provided by Lionel Henry in PR#17617.
> >
> >     * format(object.size(.), digits=NULL) now works, fixing PR#17628
> >       reported by Jonathan Carroll.
> >
> >     * get_all_vars(f, d) now also works for cases, e.g. where d
> >       contains a matrix.  Reported by Simon Wood in 2009 and patch
> >       provided by Ben Bolker in PR#13624.
> >
> >       Additionally, it now also works when some variables are data
> >       frames, fixing PR#14905, reported by Patrick Breheny.
> >
> >     * barplot() could get spacings wrong if there were exactly two bars
> >       PR#15522.  Patch by Michael Chirico.
> >
> >     * power.t.test() works in more cases when returning values of n
> >       smaller than 2.
> >
> >     * dotchart(*, pch=., groups=.) now works better.  Reported by
> >       Robert and confirmed by Nic Rochette in PR#16953.
> >
> >     * canCoerce(obj, cl) no longer assumes length(class(obj)) == 1.
> >
> >     * plot.formula(*, subset = *) now also works in a boundary case
> >       reported by Robert Schlicht (TU Dresden).
> >
> >     * readBin() and writeBin() of a rawConnection() now also work in
> >       large cases, thanks to a report and proposal by Taeke Harkema in
> >       PR#17665.
> >
> > --
> > Peter Dalgaard, Professor,
> > Center for Statistics, Copenhagen Business School
> > Solbjerg Plads 3, 2000 Frederiksberg, Denmark
> > Phone: (+45)38153501
> > Office: A 4.23
> > Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> > --
> > Sent from Gmail Mobile
>
> --
> Peter Dalgaard, Professor,
> Center for Statistics, Copenhagen Business School
> Solbjerg Plads 3, 2000 Frederiksberg, Denmark
> Phone: (+45)38153501
> Office: A 4.23
> Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com
>
>
>
>
>
>
>
>
>
> --
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


From ncrook@ton@|@ @end|ng |rom gm@||@com  Thu Dec 12 18:41:16 2019
From: ncrook@ton@|@ @end|ng |rom gm@||@com (Nicholas Crookston)
Date: Thu, 12 Dec 2019 09:41:16 -0800
Subject: [Rd] Dynamic load library problem using R 4.0.0
In-Reply-To: <CAAk+MXz+XSXaFcogbRPBPPyWzUzM8-Mg=1DfU6WOUXuDrEfK0A@mail.gmail.com>
References: <CAAk+MXz+XSXaFcogbRPBPPyWzUzM8-Mg=1DfU6WOUXuDrEfK0A@mail.gmail.com>
Message-ID: <CAAk+MXxic6pJrf1tVyUpd12Hr_4k+phSvGDAyajEC2Lk=KnEBg@mail.gmail.com>

Case closed.  My error was that I had not included an "export" option to
the linker and the symbols were not being exported (I was out of practice
building Window's dlls). The nm command output didn't help me. Thanks to
Tomas Kalibera and Jeroen Ooms for some helpful correspondence.


On Tue, Dec 3, 2019 at 1:41 PM Nicholas Crookston <ncrookston.fs at gmail.com>
wrote:

> I'm having problems getting code that runs under 3.6.1 on MacOSX (and
> Ubuntu)
> to run the R version 4.0.0 on Windows. I have not tested R 4.0.0 on mac
> (yet).
>
> Key question: Has anything changed in R 4.0.0/Windows regarding how
> dynamically loaded
> libraries are accessed?  Can someone please point me in the right
> direction?
>
> WORKS On MacOSX Under:
> R version 3.6.1 (2019-07-05) -- "Action of the Toes"
> after dynamically loading ../../bin/qFVSie.so:
>
> > getLoadedDLLs()$qFVSie
> DLL name: qFVSie
> Filename:
>
> /Users/ncrookston/open-fvs/branches/NickDev/tests/APIviaR/../../bin/qFVSie.so
> Dynamic lookup: TRUE
>
> # expected output is correct:
> > i=1
> > .C("CfvsSpeciesCode",fvs_code="",fia_code="",plant_code="",
> indx=as.integer(i))
> $fvs_code
> [1] "WP"
> $fia_code
> [1] "119"
> $plant_code
> [1] "PIMO3"
> $indx
> [1] 1
>
> ----- from the nm command:
> $ nm ../../bin/qFVSie.so | grep -i cfvsspeciescode
> 00000000000a7980 T _CfvsSpeciesCode
>
> ------------------------------------
>
> Fails On Win10 Under:
> R version 4.0.0 Under development (Rtools 4.0) (2019-11-23 r77455) --
> "Blame Jeroen"
> NOTE: The .dll is built using the most recent Rtools as advised by Jeroen.
>
> > getLoadedDLLs()$qFVSie
> DLL name: qFVSie
> Filename:
>
> C:/Users/nickc/open-fvs/branches/NickDev/tests/APIviaR/../../bin/qFVSie.dll
> Dynamic lookup: TRUE
>
> > i=1
> > .C("CfvsSpeciesCode",fvs_code="",fia_code="",plant_code="",
> indx=as.integer(i))
> Error in .C("CfvsSpeciesCode", fvs_code = "", fia_code = "", plant_code =
> "",  :
>   C symbol name "CfvsSpeciesCode" not in load table
>
> ----- from the nm command on Win10:
> nm ../../bin/qFVSie.dll | grep -i cfvsspeciescode
> 00000000707a21f0 T CfvsSpeciesCode
>
> -----------------------------------
>
> If advised to do so, I'll create a simple and fully reproducible example,
> but perhaps
> I missing something simple (like compiler switch needed to create my .dll
> that has not
> been necessary until now).
>
> Thanks, Nick
>
> --
> Nicholas L. Crookston
> Forestry Research Consultant
> Moscow Idaho USA
>


-- 
Nicholas L. Crookston
Forestry Research Consultant
Moscow Idaho USA

	[[alternative HTML version deleted]]


From tc@||@w@ @end|ng |rom redh@t@com  Thu Dec 12 20:21:10 2019
From: tc@||@w@ @end|ng |rom redh@t@com (Tom Callaway)
Date: Thu, 12 Dec 2019 14:21:10 -0500
Subject: [Rd] Build failure on powerpc64
Message-ID: <CANA0HMYoYiHApzRfswTioi352ELYS4bJwvrW+=su6Mtanq84RQ@mail.gmail.com>

Hi R folks,

Went to build R 3.6.2 for Fedora/EPEL and got failures across the board.

Disabling the test suite for all non-intel architectures resolves most of
the failures, but powerpc64 dies in the compiler, specifically here:

gcc -m64  -I../../src/extra/xdr -I. -I../../src/include -I../../src/include
 -I/usr/local/include -I../../src/nmath -DHAVE_CONFIG_H   -fopenmp -fPIC
 -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2
-Wp,-D_GLIBCXX_ASSERTIONS -fexceptions -fstack-protector-strong
-grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1
-specs=/usr/lib/rpm/redhat/redhat-annobin-cc1 -m64 -mcpu=power8
-mtune=power8 -fasynchronous-unwind-tables -fstack-clash-protection  -c
arithmetic.c -o arithmetic.o
arithmetic.c:180:26: error: initializer element is not constant
  180 | static LDOUBLE q_1_eps = (1 / LDBL_EPSILON);
      |                          ^
make[3]: *** [../../Makeconf:124: arithmetic.o] Error 1

Took me a bit to figure out why, but this is happening because on
powerpc64, gcc is compiled with -mlong-double-128, and the long double
format used on PPC is IBM's 128bit long double which is two doubles added
together. As a result, gcc can't safely do const assignments to long
doubles on ppc64, so it dies there.

The fix is easy enough, do not try to assign a value to a static long
double on ppc64.
--- ./src/main/arithmetic.c.orig        2019-12-12 18:30:12.416334062 +0000
+++ ./src/main/arithmetic.c     2019-12-12 18:30:44.966334062 +0000
@@ -179,7 +179,10 @@ void attribute_hidden InitArithmetic()
 #endif
 }

-#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE > SIZEOF_DOUBLE)
+/* PowerPC 64 (when gcc has -mlong-double-128) breaks here because
+ * of issues constant folding 128bit IBM long doubles.
+ */
+#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE > SIZEOF_DOUBLE) && !__PPC64__
 static LDOUBLE q_1_eps = 1 / LDBL_EPSILON;
 #else
 static double  q_1_eps = 1 / DBL_EPSILON;

Hope that helps someone else.

Tom

	[[alternative HTML version deleted]]


From pd@me@ @end|ng |rom cb@@dk  Thu Dec 12 20:23:22 2019
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Thu, 12 Dec 2019 19:23:22 +0000
Subject: [Rd] R 3.6.2 is released
In-Reply-To: <CAL6gwn+Rm_m5pK9bNJZah-n0zS4JDDmga9R2A5Qe5c_jkzZ4Ag@mail.gmail.com>
References: <7F4152E4-727E-46C0-85D9-7318EB980FAB@cbs.dk>
 <CAL6gwnK=S-ge7=doom2LM6AdgTmXNPxsHxD1YqDJA8tp1rF-vg@mail.gmail.com>
 <6CDCF807-577F-4ED8-80F7-7894A82BC821@cbs.dk>
 <CAL6gwn+Rm_m5pK9bNJZah-n0zS4JDDmga9R2A5Qe5c_jkzZ4Ag@mail.gmail.com>
Message-ID: <CB5527BC-D144-454A-A152-C654D61CD3DF@cbs.dk>

It is possible that this means that it is the intention to port the changes from R-devel to 3.6.2 patched once 3.6.2 is out. In that case, you can be pretty sure that the changes are NOT in 3.6.2 (and actually not in 3.6.2 patched either -- yet). 

If so, you have provided a nice illustration of why I keep telling people not to do that...

-pd 

> On 12 Dec 2019, at 18:05 , Avraham Adler <avraham.adler at gmail.com> wrote:
> 
> Thank you. 
> 
> I apologize for not providing the link. [1] Under the news for R-revel there is a single entry for R 3.6.2-patched. 
> 
> The file I downloaded was [2] with a date of 2019-12-12 01:50. 
> 
> Is it safe to say that 3.6.2 has the LAPACK upgrades and fixes?
> 
> Apologies in advance if iOS links the URL below. I cannot access gmail desktop from behind my corporate firewall. 
> 
> Thank you again,
> 
> Avi
> 
> [1] 
> https://cran.r-project.org/doc/manuals/r-devel/NEWS.html
> [2] 
> https://stat.ethz.ch/R/daily/R-patched.tar.gz
> 
> On Thu, Dec 12, 2019 at 11:10 AM Peter Dalgaard <pd.mes at cbs.dk> wrote:
> It is not obvious what it is that you are calling "R-patched", nor where there could be an entry for "3.6.2 patched".
> 
> The prerelease/patched versions are snapshots of R-3-6-branch made at 00:20 so the current one will have been made before the release version run started at 09:00 this morning, and hence the nightly tarball will be of the release candidate. However it will not be called R-patched:
> 
> lrwxr-xr-x  1 pd  staff        29 Dec 12 00:20 R-latest.tar.gz -> R-rc_2019-12-06_r77555.tar.gz
> 
> The current version in SVN differs only by the VERSION file. Its NEWS.Rd starts
> 
> Peters-MacBook-Air:R pd$ more VERSION
> 3.6.2 Patched
> Peters-MacBook-Air:R pd$ more doc/NEWS.Rd
> % -*- coding: utf-8 -*-
> \newcommand{\Rlogo}{\if{html}{\figure{../../html/Rlogo.svg}{options: class="toplogo" alt="[R logo]"}}\if{latex}{\figure{Rlogo.pdf}{options: width=0.5in}}}
> 
> \name{NEWS}
> \title{R News}
> \encoding{UTF-8}
> 
> \section{\Rlogo CHANGES IN R 3.6.2}{
> 
>   \subsection{NEW FEATURES}{
>     \itemize{
>   ....
> 
> and any changes for 3.6.2 patched should go above the entries for 3.6.2.
> 
> - pd
> 
> 
> > On 12 Dec 2019, at 16:34 , Avraham Adler <avraham.adler at gmail.com> wrote:
> > 
> > Hi. 
> > 
> > Under R-news there is an entry for 3.6.2 patched regarding LAPACK. However, when uncompresding the current R-patched, it creates R-Rc directories. Is this a naming oversight or is the patched version actually the unadjusted release candidate?
> > 
> > Thank you,
> > 
> > Avi
> > 
> > On Thu, Dec 12, 2019 at 4:58 AM Peter Dalgaard via R-devel <r-devel at r-project.org> wrote:
> > The build system rolled up R-3.6.2.tar.gz (codename "Dark and Stormy Night") this morning.
> > 
> > The list below details the changes in this release.
> > 
> > You can get the source code from
> > 
> > http://cran.r-project.org/src/base/R-3/R-3.6.2.tar.gz
> > 
> > or wait for it to be mirrored at a CRAN site nearer to you.
> > 
> > Binaries for various platforms will appear in due course.
> > 
> > 
> > For the R Core Team,
> > 
> > Peter Dalgaard
> > 
> > These are the checksums (md5 and SHA-256) for the freshly created files, in case you wish
> > to check that they are uncorrupted:
> > 
> > MD5 (AUTHORS) = b9c44f9f78cab3184ad9898bebc854b4
> > MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
> > MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
> > MD5 (FAQ) = 28a3942a7129877e9af1d5ea16202052
> > MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
> > MD5 (NEWS) = 45437b38c75e0248b527c00e6d42ee6a
> > MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
> > MD5 (NEWS.1) = eb78c4d053ec9c32b815cf0c2ebea801
> > MD5 (NEWS.2) = 591dcf615162127f904e4e461f330ce9
> > MD5 (R-latest.tar.gz) = 90d23d138cee26d275da14b58296e521
> > MD5 (README) = f468f281c919665e276a1b691decbbe6
> > MD5 (RESOURCES) = 529223fd3ffef95731d0a87353108435
> > MD5 (THANKS) = bb45f89c01d509721c47fd41f147da60
> > MD5 (VERSION-INFO.dcf) = 9c33701e25092aefc1d16beb5858f20f
> > MD5 (R-3/R-3.6.2.tar.gz) = 90d23d138cee26d275da14b58296e521
> > 
> > 
> > 2cde824a7b18958e5f06b391c801c8288be0f84fa8934b7ddefef23c67e60c09  AUTHORS
> > e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
> > 6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3  COPYING.LIB
> > 38219d9c6221ccfbf075ef03711b420a1aa8731f890c8f2337148b602a217c2d  FAQ
> > f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
> > 0ceb6fbab3e0e29bc374683fd5c2ccd0c9c62ce8eca2a394a4603775b3ef129c  NEWS
> > 4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
> > 12b30c724117b1b2b11484673906a6dcd48a361f69fc420b36194f9218692d01  NEWS.1
> > ca04f78ffe54afa326fe3ed40e7e1411aca0000ed2fa5ead97ddf51c6aa5b7bc  NEWS.2
> > bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954  R-latest.tar.gz
> > 2fdd3e90f23f32692d4b3a0c0452f2c219a10882033d1774f8cadf25886c3ddc  README
> > 408737572ecc6e1135fdb2cf7a9dbb1a6cb27967c757f1771b8c39d1fd2f1ab9  RESOURCES
> > 2a8dca916cd92229ef9e328f3610ca204809c262823b860252b42072dac2473a  THANKS
> > 40cc7cea5f0e67cf8f2f7b25a534ae6bc53f38eae2ab2c2649a952ed37f0654a  VERSION-INFO.dcf
> > bd65a45cddfb88f37370fbcee4ac8dd3f1aebeebe47c2f968fd9770ba2bbc954  R-3/R-3.6.2.tar.gz
> > 
> > This is the relevant part of the NEWS file
> > 
> > CHANGES IN R 3.6.2:
> > 
> >   NEW FEATURES:
> > 
> >     * runmed(x, *) gains a new option na.action determining _how_ to
> >       handle NaN or NA in x.
> > 
> >     * dotchart() gains new options ann, xaxt, frame.plot and log.
> > 
> >   INSTALLATION on a UNIX-ALIKE:
> > 
> >     * Detection of the C stack direction has been moved from run-time
> >       to configure: this is safer with LTO builds and allows the
> >       detection to be overridden - see file config.site.
> > 
> >     * Source-code changes enable installation on platforms using gcc
> >       -fno-common (the expected default for gcc 10.x).
> > 
> >   C-LEVEL FACILITIES:
> > 
> >     * installTrChar (which is nowadays is wrapped by installChar) is
> >       defined in Rinternals.h.  (Neither are part of the API.)
> > 
> >   PACKAGE INSTALLATION:
> > 
> >     * Header Rconfig.h contains the value of FC_LEN_T deduced at
> >       installation which is used by the prototypes in headers
> >       R_ext/BLAS.h and R_ext/Lapack.h but to avoid extensive breakage
> >       this is only exposed when USE_FC_LEN_T is defined.
> > 
> >       If a package's C/C++ calls to BLAS/LAPACK allow for the 'hidden'
> >       arguments used by most Fortran compilers to pass the lengths of
> >       Fortran character arguments, define USE_FC_LEN_T and include
> >       Rconfig.h (possibly _via_ R.h) before including R_ext/BLAS.h or
> >       R_ext/Lapack.h.
> > 
> >     * A package with Fortran source code and perhaps C (but not C++)
> >       sources can request for its shared object/DLL to be linked by the
> >       Fortran compiler by including a line USE_FC_TO_LINK= in
> >       src/Makevars[.win] and using $(SHLIB_OPENMP_FFLAGS) as part of
> >       PKG_LIBS.
> > 
> >       The known reason for doing so is a package which uses Fortran
> >       (only) OpenMP on a platform where the Fortran OpenMP runtime is
> >       incompatible with the C one (e.g. gfortran 9.x with clang).
> > 
> >   UTILITIES:
> > 
> >     * R CMD check has a new option to mitigate checks leaving
> >       files/directories in /tmp.  See the 'R Internals' manual - this
> >       is part of --as-cran.
> > 
> >   Windows:
> > 
> >     * The default standard for C++ in package installation is C++11 (as
> >       it has been on other platforms where available since R 3.6.0: the
> >       default toolchain on Windows was defaulting to C++98).
> > 
> >   DEPRECATED AND DEFUNCT:
> > 
> >     * Support for specifying C++98 in package installation is
> >       deprecated.
> > 
> >     * Support in R CMD config for F77, FCPIFCPLAGS, CPP, CXXCPP and
> >       CXX98 and similar is deprecated.  (CPP is found from the system
> >       make and may well not be set.)
> > 
> >       Use $CC -E and $CXX -E instead of CPP and CXXCPP.
> > 
> >   BUG FIXES:
> > 
> >     * runmed(x, *) when x contains missing values now works
> >       consistently for both algorithm="Stuetzle" and "Turlach", and no
> >       longer segfaults for "Turlach", as reported by Hilmar Berger.
> > 
> >     * apply(diag(3), 2:3, mean) now gives a helpful error message.
> > 
> >     * dgamma(x, shape, log=TRUE) now longer overflows to Inf for shape
> >       < 1 and very small x, fixing PR#17577, reported by Jonathan
> >       Rougier.
> > 
> >     * Buffer overflow in building error messages fixed. Reported by
> >       Benjamin Tremblay.
> > 
> >     * options(str = .) is correctly initialized at package utils load
> >       time, now.  A consequence is that str() in scripts now is more
> >       consistent to interactive use, e.g., when displaying function(**)
> >       argument lists.
> > 
> >     * as.numeric(<call>) now gives correct error message.
> > 
> >     * Printing ls.str() no longer wrongly shows "<missing>" in rare
> >       cases.
> > 
> >     * Auto-printing S4 objects no longer duplicates the object, for
> >       faster speed and reduced memory consumption. Reported by Aaron
> >       Lun.
> > 
> >     * pchisq(<LRG>, <LRG>, ncp=100) no longer takes practically forever
> >       in some cases.  Hence ditto for corresponding qchisq() calls.
> > 
> >     * x %% L for finite x no longer returns NaN when L is infinite, nor
> >       suffers from cancellation for large finite L, thanks to Long Qu's
> >       PR#17611.
> > 
> >       Analogously, x %/% L and L %/% x suffer less from cancellation
> >       and return values corresponding to limits for large L.
> > 
> >     * grepl(NA, *) now returns logical as documented.
> > 
> >     * options(warn=1e11) is an error now, instead of later leading to C
> >       stack overflow because of infinite recursion.
> > 
> >     * R_tryCatch no longer transfers control for all conditions.
> >       Reported and patch provided by Lionel Henry in PR#17617.
> > 
> >     * format(object.size(.), digits=NULL) now works, fixing PR#17628
> >       reported by Jonathan Carroll.
> > 
> >     * get_all_vars(f, d) now also works for cases, e.g. where d
> >       contains a matrix.  Reported by Simon Wood in 2009 and patch
> >       provided by Ben Bolker in PR#13624.
> > 
> >       Additionally, it now also works when some variables are data
> >       frames, fixing PR#14905, reported by Patrick Breheny.
> > 
> >     * barplot() could get spacings wrong if there were exactly two bars
> >       PR#15522.  Patch by Michael Chirico.
> > 
> >     * power.t.test() works in more cases when returning values of n
> >       smaller than 2.
> > 
> >     * dotchart(*, pch=., groups=.) now works better.  Reported by
> >       Robert and confirmed by Nic Rochette in PR#16953.
> > 
> >     * canCoerce(obj, cl) no longer assumes length(class(obj)) == 1.
> > 
> >     * plot.formula(*, subset = *) now also works in a boundary case
> >       reported by Robert Schlicht (TU Dresden).
> > 
> >     * readBin() and writeBin() of a rawConnection() now also work in
> >       large cases, thanks to a report and proposal by Taeke Harkema in
> >       PR#17665.
> > 
> > -- 
> > Peter Dalgaard, Professor,
> > Center for Statistics, Copenhagen Business School
> > Solbjerg Plads 3, 2000 Frederiksberg, Denmark
> > Phone: (+45)38153501
> > Office: A 4.23
> > Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com
> > 
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> > -- 
> > Sent from Gmail Mobile
> 
> -- 
> Peter Dalgaard, Professor,
> Center for Statistics, Copenhagen Business School
> Solbjerg Plads 3, 2000 Frederiksberg, Denmark
> Phone: (+45)38153501
> Office: A 4.23
> Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com
> 
> 
> 
> 
> 
> 
> 
> 
> 
> -- 
> Sent from Gmail Mobile

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Dec 13 11:40:56 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 13 Dec 2019 11:40:56 +0100
Subject: [Rd] Build failure on powerpc64
In-Reply-To: <CANA0HMYoYiHApzRfswTioi352ELYS4bJwvrW+=su6Mtanq84RQ-6733@mail.gmail.com>
References: <CANA0HMYoYiHApzRfswTioi352ELYS4bJwvrW+=su6Mtanq84RQ-6733@mail.gmail.com>
Message-ID: <24051.27320.342490.48043@stat.math.ethz.ch>

>>>>> Tom Callaway 
>>>>>     on Thu, 12 Dec 2019 14:21:10 -0500 writes:

    > Hi R folks,

    > Went to build R 3.6.2 for Fedora/EPEL and got failures across the board.

    > Disabling the test suite for all non-intel architectures resolves most of
    > the failures, but powerpc64 dies in the compiler, specifically here:

    > gcc -m64  -I../../src/extra/xdr -I. -I../../src/include -I../../src/include
    > -I/usr/local/include -I../../src/nmath -DHAVE_CONFIG_H   -fopenmp -fPIC
    > -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2
    > -Wp,-D_GLIBCXX_ASSERTIONS -fexceptions -fstack-protector-strong
    > -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1
    > -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1 -m64 -mcpu=power8
    > -mtune=power8 -fasynchronous-unwind-tables -fstack-clash-protection  -c
    > arithmetic.c -o arithmetic.o
    > arithmetic.c:180:26: error: initializer element is not constant
    > 180 | static LDOUBLE q_1_eps = (1 / LDBL_EPSILON);
    > |                          ^
    > make[3]: *** [../../Makeconf:124: arithmetic.o] Error 1

    > Took me a bit to figure out why, but this is happening because on
    > powerpc64, gcc is compiled with -mlong-double-128, and the long double
    > format used on PPC is IBM's 128bit long double which is two doubles added
    > together. As a result, gcc can't safely do const assignments to long
    > doubles on ppc64, so it dies there.

    > The fix is easy enough, do not try to assign a value to a static long
    > double on ppc64.
    > --- ./src/main/arithmetic.c.orig        2019-12-12 18:30:12.416334062 +0000
    > +++ ./src/main/arithmetic.c     2019-12-12 18:30:44.966334062 +0000
    > @@ -179,7 +179,10 @@ void attribute_hidden InitArithmetic()
    > #endif
    > }

    > -#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE > SIZEOF_DOUBLE)
    > +/* PowerPC 64 (when gcc has -mlong-double-128) breaks here because
    > + * of issues constant folding 128bit IBM long doubles.
    > + */
    > +#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE > SIZEOF_DOUBLE) && !__PPC64__
    > static LDOUBLE q_1_eps = 1 / LDBL_EPSILON;
    > #else
    > static double  q_1_eps = 1 / DBL_EPSILON;


    > Hope that helps someone else.
    > Tom

Thank you, Tom.  That is "interesting"  ...

The piece in question had been added by me,
------------------------------------------------------------------------
r77193 | maechler | 2019-09-18 13:21:49 +0200 (Wed, 18 Sep 2019) | 1 line

 x %% +/- Inf  now typically return non-NaN; fix the "FIXME" in C
------------------------------------------------------------------------
in order to use double precision in order to deal with finite cases
close to Inf, etc.

IIUC, your proposed patch is really a workaround a bug on PPC64 ?

But note the check on LONG_DOUBLE is not the only one in R's
sources: Via 'grep' in src/main/*.?  I also see

connections.c
connections.c
connections.c
connections.c
connections.c
format.c
format.c
format.c

Do they also need protection against this PPC64 bug ?

Best,

Martin Maechler
ETH Zurich and R Core Team

From tc@||@w@ @end|ng |rom redh@t@com  Fri Dec 13 17:06:25 2019
From: tc@||@w@ @end|ng |rom redh@t@com (Tom Callaway)
Date: Fri, 13 Dec 2019 11:06:25 -0500
Subject: [Rd] Build failure on powerpc64
In-Reply-To: <24051.27320.342490.48043@stat.math.ethz.ch>
References: <CANA0HMYoYiHApzRfswTioi352ELYS4bJwvrW+=su6Mtanq84RQ-6733@mail.gmail.com>
 <24051.27320.342490.48043@stat.math.ethz.ch>
Message-ID: <CANA0HMansuv519fGMJy-Z+rEAgenAs1hr09eYGeV7HFNfZHTHw@mail.gmail.com>

An excellent question. It is important to remember two key facts:

1. With gcc on ppc64, long doubles exist, they can be used, just not safely
as constants (and maybe they still can be used safely under specific
conditions?).
2. I am not an expert in either PowerPC64 or gcc. :)

Looking at connections.c, we have (in order):
  * handling long double as a valid case in a switch statement checking size
  * adding long double as a field in the u union define
  * handling long double as a valid case in a switch statement checking size
  * handling long double as a valid case in a switch statement checking size
  * memcpy from the address of a long double

In format.c, we have (in order):
  * conditionally creating private_nearbyintl for R_nearbyintl
  * defining a static const long double tbl[]
  * use exact scaling factor in long double precision

For most of these, it seems safe to leave them as is for ppc64. I would
have thought that the gcc compiler might have had issue with:

connections.c:
              static long double ld1;
                for (i = 0, j = 0; i < len; i++, j += size) {
                    ld1 = (long double) REAL(object)[i];

format.c:
   static const long double tbl[] =

... but it doesn't. Perhaps the original code at issue:

arithmetic.c:
   static LDOUBLE q_1_eps = 1 / LDBL_EPSILON;

only makes gcc unhappy because of the very large value trying to be stored
in the static long double, which would make it span the "folded double" on
that architecture.

*****

It seems that the options are:

A) Patch the one place where the compiler determines it is not safe to use
a static long double on ppc64.
B) Treat PPC64 as a platform where it is never safe to use a static long
double

FWIW, I did run the test suite after applying my patch and all of the tests
pass on ppc64.

Tom


On Fri, Dec 13, 2019 at 5:44 AM Martin Maechler <maechler at stat.math.ethz.ch>
wrote:

> >>>>> Tom Callaway
> >>>>>     on Thu, 12 Dec 2019 14:21:10 -0500 writes:
>
>     > Hi R folks,
>
>     > Went to build R 3.6.2 for Fedora/EPEL and got failures across the
> board.
>
>     > Disabling the test suite for all non-intel architectures resolves
> most of
>     > the failures, but powerpc64 dies in the compiler, specifically here:
>
>     > gcc -m64  -I../../src/extra/xdr -I. -I../../src/include
> -I../../src/include
>     > -I/usr/local/include -I../../src/nmath -DHAVE_CONFIG_H   -fopenmp
> -fPIC
>     > -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2
>     > -Wp,-D_GLIBCXX_ASSERTIONS -fexceptions -fstack-protector-strong
>     > -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1
>     > -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1 -m64 -mcpu=power8
>     > -mtune=power8 -fasynchronous-unwind-tables -fstack-clash-protection
> -c
>     > arithmetic.c -o arithmetic.o
>     > arithmetic.c:180:26: error: initializer element is not constant
>     > 180 | static LDOUBLE q_1_eps = (1 / LDBL_EPSILON);
>     > |                          ^
>     > make[3]: *** [../../Makeconf:124: arithmetic.o] Error 1
>
>     > Took me a bit to figure out why, but this is happening because on
>     > powerpc64, gcc is compiled with -mlong-double-128, and the long
> double
>     > format used on PPC is IBM's 128bit long double which is two doubles
> added
>     > together. As a result, gcc can't safely do const assignments to long
>     > doubles on ppc64, so it dies there.
>
>     > The fix is easy enough, do not try to assign a value to a static long
>     > double on ppc64.
>     > --- ./src/main/arithmetic.c.orig        2019-12-12
> 18:30:12.416334062 +0000
>     > +++ ./src/main/arithmetic.c     2019-12-12 18:30:44.966334062 +0000
>     > @@ -179,7 +179,10 @@ void attribute_hidden InitArithmetic()
>     > #endif
>     > }
>
>     > -#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE > SIZEOF_DOUBLE)
>     > +/* PowerPC 64 (when gcc has -mlong-double-128) breaks here because
>     > + * of issues constant folding 128bit IBM long doubles.
>     > + */
>     > +#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE > SIZEOF_DOUBLE) &&
> !__PPC64__
>     > static LDOUBLE q_1_eps = 1 / LDBL_EPSILON;
>     > #else
>     > static double  q_1_eps = 1 / DBL_EPSILON;
>
>
>     > Hope that helps someone else.
>     > Tom
>
> Thank you, Tom.  That is "interesting"  ...
>
> The piece in question had been added by me,
> ------------------------------------------------------------------------
> r77193 | maechler | 2019-09-18 13:21:49 +0200 (Wed, 18 Sep 2019) | 1 line
>
>  x %% +/- Inf  now typically return non-NaN; fix the "FIXME" in C
> ------------------------------------------------------------------------
> in order to use double precision in order to deal with finite cases
> close to Inf, etc.
>
> IIUC, your proposed patch is really a workaround a bug on PPC64 ?
>
> But note the check on LONG_DOUBLE is not the only one in R's
> sources: Via 'grep' in src/main/*.?  I also see
>
> connections.c 4285:#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
> connections.c 4329:#if HAVE_LONG_DOUBLE
> connections.c 4379:#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
> connections.c 4514:#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
> connections.c 4592:#if HAVE_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
> format.c 250:#if defined(HAVE_LONG_DOUBLE) && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
> format.c 285:#if defined(HAVE_LONG_DOUBLE) && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
> format.c 339:#if defined(HAVE_LONG_DOUBLE) && (SIZEOF_LONG_DOUBLE >
> SIZEOF_DOUBLE)
>
> Do they also need protection against this PPC64 bug ?
>
> Best,
>
> Martin Maechler
> ETH Zurich and R Core Team
>

	[[alternative HTML version deleted]]


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Fri Dec 13 17:35:54 2019
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Serguei Sokol)
Date: Fri, 13 Dec 2019 17:35:54 +0100
Subject: [Rd] Build failure on powerpc64
In-Reply-To: <CANA0HMansuv519fGMJy-Z+rEAgenAs1hr09eYGeV7HFNfZHTHw@mail.gmail.com>
References: <CANA0HMYoYiHApzRfswTioi352ELYS4bJwvrW+=su6Mtanq84RQ-6733@mail.gmail.com>
 <24051.27320.342490.48043@stat.math.ethz.ch>
 <CANA0HMansuv519fGMJy-Z+rEAgenAs1hr09eYGeV7HFNfZHTHw@mail.gmail.com>
Message-ID: <7a28ecfa-7f2a-167f-ce83-f817f3991d78@insa-toulouse.fr>

Le 13/12/2019 ? 17:06, Tom Callaway a ?crit?:
> arithmetic.c:
>     static LDOUBLE q_1_eps = 1 / LDBL_EPSILON;
Just a thought: can it be that it's "1" which is at the origin of 
compiler complaint?
In this case, would the syntax "1.L" be sufficient to keep it calm?

Serguei.


From kry|ov@r00t @end|ng |rom gm@||@com  Fri Dec 13 16:39:25 2019
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Fri, 13 Dec 2019 18:39:25 +0300
Subject: [Rd] tempdir() containing spaces breaks installing source packages
Message-ID: <20191213183925.1aa3bce2@trisector>

Hello everyone!

Temp paths are used in system2() calls without shQuote() because
they are assumed not to contain spaces. On Windows,
GetShortPathName() is used to try to ensure that.

Unfortunately, sometimes GetShortPathName() silently fails to return a
8.3 file path and gives a full path instead (8.3 file names might be
disabled on newer Windows 10 installations, or there may be another
reason). This has been spotted in the wild [*]. When %USERPROFILE%
contains spaces, this results in tempdir() also containing spaces and
prevents the user from being able to install source packages.

As of <https://svn.r-project.org/R/trunk at 77563>,

 - src/library/utils/R/packages2.R line 839 contains an unquoted
   temporary file path (fil) passed to system2(), which results in it
   being split and R CMD INSTALL not being able to find the package
   file. In other invocations of R CMD INSTALL in the same file, the
   path is properly quoted.

 - src/library/tools/R/check.R line 125 contains an unquoted temporary
   file path passed to system2, which results in Rterm.exe -f not being
   able to find the RtmpXXXXXX\RinXXXXXXXX file, causing the attempt to
   run tools:::makeLazyLoading(...) to fail.

I can report these two problems (thanks to Martin Maechler for the
Bugzilla account and the advice) and attach the patches required to fix
them, but there might be more. The bug report [**] is somewhat relevant
here (though changing the default behaviour of system2() is obviously
not the right solution as it would break existing code).

Is there anything I should consider before creating the PR as
described above?

-- 
Best regards,
Ivan

[*] https://stat.ethz.ch/pipermail/r-help/2019-December/465075.html

[**] https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16127


From wdun|@p @end|ng |rom t|bco@com  Fri Dec 13 18:31:01 2019
From: wdun|@p @end|ng |rom t|bco@com (William Dunlap)
Date: Fri, 13 Dec 2019 09:31:01 -0800
Subject: [Rd] 
 tempdir() containing spaces breaks installing source packages
In-Reply-To: <20191213183925.1aa3bce2@trisector>
References: <20191213183925.1aa3bce2@trisector>
Message-ID: <CAF8bMcZJVadOLaOXBuqz6sxOQGNVQMPX-=4SUuTQXP+0UHLURg@mail.gmail.com>

You might expand the scope of this a bit to include Windows usernames with
non-ASCII characters in them.  If I recall correctly, if you are logged
under a Cyrillic UTF-8 name then R will not even start.  We have seen this
in the wild.

Bill Dunlap
TIBCO Software
wdunlap tibco.com


On Fri, Dec 13, 2019 at 8:47 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:

> Hello everyone!
>
> Temp paths are used in system2() calls without shQuote() because
> they are assumed not to contain spaces. On Windows,
> GetShortPathName() is used to try to ensure that.
>
> Unfortunately, sometimes GetShortPathName() silently fails to return a
> 8.3 file path and gives a full path instead (8.3 file names might be
> disabled on newer Windows 10 installations, or there may be another
> reason). This has been spotted in the wild [*]. When %USERPROFILE%
> contains spaces, this results in tempdir() also containing spaces and
> prevents the user from being able to install source packages.
>
> As of <https://svn.r-project.org/R/trunk at 77563>,
>
>  - src/library/utils/R/packages2.R line 839 contains an unquoted
>    temporary file path (fil) passed to system2(), which results in it
>    being split and R CMD INSTALL not being able to find the package
>    file. In other invocations of R CMD INSTALL in the same file, the
>    path is properly quoted.
>
>  - src/library/tools/R/check.R line 125 contains an unquoted temporary
>    file path passed to system2, which results in Rterm.exe -f not being
>    able to find the RtmpXXXXXX\RinXXXXXXXX file, causing the attempt to
>    run tools:::makeLazyLoading(...) to fail.
>
> I can report these two problems (thanks to Martin Maechler for the
> Bugzilla account and the advice) and attach the patches required to fix
> them, but there might be more. The bug report [**] is somewhat relevant
> here (though changing the default behaviour of system2() is obviously
> not the right solution as it would break existing code).
>
> Is there anything I should consider before creating the PR as
> described above?
>
> --
> Best regards,
> Ivan
>
> [*] https://stat.ethz.ch/pipermail/r-help/2019-December/465075.html
>
> [**] https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16127
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From pe|j@@z @end|ng |rom y@hoo@co@uk  Fri Dec 13 19:36:37 2019
From: pe|j@@z @end|ng |rom y@hoo@co@uk (lejeczek)
Date: Fri, 13 Dec 2019 18:36:37 +0000
Subject: [Rd] running R with users home dirs on a shared filesystems
References: <2d57ba6d-5124-a4c4-a743-c46f9cf3152d.ref@yahoo.co.uk>
Message-ID: <2d57ba6d-5124-a4c4-a743-c46f9cf3152d@yahoo.co.uk>

Hi guys,

I want to ask devel for who knows better - having multiple
nodes serving users home dirs off the same shared network
filesystem : are there any precautions or must-dos &
must-donts in order to assure healthy and efficient parallel
Rs running simultaneously - and I don't mean obvious stuff,
I'm rather asking about R's internals & environment.

simple example: three nodes mount a NFS share and users on
all three nodes run R simultaneously.

many thanks, L.


From tc@||@w@ @end|ng |rom redh@t@com  Fri Dec 13 19:39:10 2019
From: tc@||@w@ @end|ng |rom redh@t@com (Tom Callaway)
Date: Fri, 13 Dec 2019 13:39:10 -0500
Subject: [Rd] Build failure on powerpc64
In-Reply-To: <7a28ecfa-7f2a-167f-ce83-f817f3991d78@insa-toulouse.fr>
References: <CANA0HMYoYiHApzRfswTioi352ELYS4bJwvrW+=su6Mtanq84RQ-6733@mail.gmail.com>
 <24051.27320.342490.48043@stat.math.ethz.ch>
 <CANA0HMansuv519fGMJy-Z+rEAgenAs1hr09eYGeV7HFNfZHTHw@mail.gmail.com>
 <7a28ecfa-7f2a-167f-ce83-f817f3991d78@insa-toulouse.fr>
Message-ID: <CANA0HMbkUbS29vaDwX8xhtaRB6qLvN00AF39wZdtDY28D-uPkA@mail.gmail.com>

No, that does not change the issue:

arithmetic.c:180:26: error: initializer element is not constant
  180 | static LDOUBLE q_1_eps = 1.L / LDBL_EPSILON;

Tom

On Fri, Dec 13, 2019 at 11:56 AM Serguei Sokol <sokol at insa-toulouse.fr>
wrote:

> Le 13/12/2019 ? 17:06, Tom Callaway a ?crit :
> > arithmetic.c:
> >     static LDOUBLE q_1_eps = 1 / LDBL_EPSILON;
> Just a thought: can it be that it's "1" which is at the origin of
> compiler complaint?
> In this case, would the syntax "1.L" be sufficient to keep it calm?
>
> Serguei.
>
>

	[[alternative HTML version deleted]]


From @|mon@urb@nek @end|ng |rom R-project@org  Fri Dec 13 19:52:00 2019
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Fri, 13 Dec 2019 13:52:00 -0500
Subject: [Rd] running R with users home dirs on a shared filesystems
In-Reply-To: <2d57ba6d-5124-a4c4-a743-c46f9cf3152d@yahoo.co.uk>
References: <2d57ba6d-5124-a4c4-a743-c46f9cf3152d.ref@yahoo.co.uk>
 <2d57ba6d-5124-a4c4-a743-c46f9cf3152d@yahoo.co.uk>
Message-ID: <E3A27352-4794-4BA0-8EE6-1308EB1CD9E2@R-project.org>

User home is not used by R directly, so it is really up to whatever package/code may be using user home. In our setup we have all machines using NFS mounted homes for years. From experience the only thing to watch for are packages that use their own cache directories in $HOME instead of tempdir() - it is technically against CRAN policies but we have seen it in the wild.

Cheers,
Simon



> On Dec 13, 2019, at 1:36 PM, lejeczek via R-devel <r-devel at r-project.org> wrote:
> 
> Hi guys,
> 
> I want to ask devel for who knows better - having multiple
> nodes serving users home dirs off the same shared network
> filesystem : are there any precautions or must-dos &
> must-donts in order to assure healthy and efficient parallel
> Rs running simultaneously - and I don't mean obvious stuff,
> I'm rather asking about R's internals & environment.
> 
> simple example: three nodes mount a NFS share and users on
> all three nodes run R simultaneously.
> 
> many thanks, L.
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From MEC @end|ng |rom @tower@@org  Fri Dec 13 23:35:27 2019
From: MEC @end|ng |rom @tower@@org (Cook, Malcolm)
Date: Fri, 13 Dec 2019 22:35:27 +0000
Subject: [Rd] running R with users home dirs on a shared filesystems
In-Reply-To: <E3A27352-4794-4BA0-8EE6-1308EB1CD9E2@R-project.org>
References: <2d57ba6d-5124-a4c4-a743-c46f9cf3152d.ref@yahoo.co.uk>
 <2d57ba6d-5124-a4c4-a743-c46f9cf3152d@yahoo.co.uk>
 <E3A27352-4794-4BA0-8EE6-1308EB1CD9E2@R-project.org>
Message-ID: <BN6PR20MB1282A4CE2FC56296FC6FD9B8BE540@BN6PR20MB1282.namprd20.prod.outlook.com>

Another thing to avoid are having multiple processes simultaneously access single sqlite3 database stored on NFS mount.

From sqlite manual: ?Your best defense is to not use SQLite for files on a network filesystem<https://www.sqlite.org/lockingv3.html>?

So, if you configuring RStudio Server, make sure to follow advice about RStudio Package Manager<https://docs.rstudio.com/rspm/admin/database.html>: ?This location must exist on local storage?

And any package that uses sqlite ?under the hood? will similarly want the db on local storage to avoid such issues stemming from multi-process access.

Cheers,
Malcolm

From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Simon Urbanek
Sent: Friday, December 13, 2019 12:52 PM
To: lejeczek <peljasz at yahoo.co.uk>
Cc: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] running R with users home dirs on a shared filesystems

CAUTION: This email was received from an External Source


User home is not used by R directly, so it is really up to whatever package/code may be using user home. In our setup we have all machines using NFS mounted homes for years. From experience the only thing to watch for are packages that use their own cache directories in $HOME instead of tempdir() - it is technically against CRAN policies but we have seen it in the wild.

Cheers,
Simon



> On Dec 13, 2019, at 1:36 PM, lejeczek via R-devel <r-devel at r-project.org<mailto:r-devel at r-project.org>> wrote:
>
> Hi guys,
>
> I want to ask devel for who knows better - having multiple
> nodes serving users home dirs off the same shared network
> filesystem : are there any precautions or must-dos &
> must-donts in order to assure healthy and efficient parallel
> Rs running simultaneously - and I don't mean obvious stuff,
> I'm rather asking about R's internals & environment.
>
> simple example: three nodes mount a NFS share and users on
> all three nodes run R simultaneously.
>
> many thanks, L.
>
> ______________________________________________
> R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel

	[[alternative HTML version deleted]]


From |g@ut|er @end|ng |rom gm@||@com  Sat Dec 14 17:25:07 2019
From: |g@ut|er @end|ng |rom gm@||@com (Laurent Gautier)
Date: Sat, 14 Dec 2019 11:25:07 -0500
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
 <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
 <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
Message-ID: <CA+JCgN1HjZY37k=2Rz885FEPp67YkHRf_Pc8TLQ-Pc=08ZREGw@mail.gmail.com>

Le lun. 9 d?c. 2019 ? 09:57, Tomas Kalibera <tomas.kalibera at gmail.com> a
?crit :

> On 12/9/19 2:54 PM, Laurent Gautier wrote:
>
>
>
> Le lun. 9 d?c. 2019 ? 05:43, Tomas Kalibera <tomas.kalibera at gmail.com> a
> ?crit :
>
>> On 12/7/19 10:32 PM, Laurent Gautier wrote:
>>
>> Thanks for the quick response Tomas.
>>
>> The same error is indeed happening when trying to have a zero-length
>> variable name in an environment. The surprising bit is then "why is this
>> happening during parsing" (that is why are variables assigned to an
>> environment) ?
>>
>> The emitted R error (in the R console) is not a parse (syntax) error, but
>> an error emitted during parsing when the parser tries to intern a name -
>> look it up in a symbol table. Empty string is not allowed as a symbol name,
>> and hence the error. In the call "list(''=1)" , the empty name is what
>> could eventually become a name of a local variable inside list(), even
>> though not yet during parsing.
>>
>
> Thanks Tomas.
>
> I guess this has do with R expressions being lazily evaluated, and names
> of arguments in a call are also part of the expression. Now the puzzling
> part is why is that at all part of the parsing: I would have expected
> R_ParseVector() to be restricted to parsing... Now it feels like
> R_ParseVector() is performing parsing, and a first level of evalution for
> expressions that "should never work" (the empty name).
>
> Think of it as an exception in say Python. Some failures during parsing
> result in an exception (called error in R and implemented using a long
> jump). Any time you are calling into R you can get an error; out of memory
> is also signalled as R error.
>


The surprising bit for me was that I had expected the function to solely
perform parsing. I did expect an exception (and a jmp smashing the stack)
when the function concerned is in the C-API, is parsing a string, and is
using a parameter (pointer) to store whether parsing was a failure or a
success.

Since you are making a comparison with Python, the distinction I am making
between parsing and evaluation seem to apply there. For example:

```
>>> import parser
>>> parser.expr('1+')
  Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1
    1+
     ^
SyntaxError: unexpected EOF while parsing
>>> p = parser.expr('list(""=1)')
>>> p
<parser.st at 0x7f360e5329f0>
>>> eval(p)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: eval() arg 1 must be a string, bytes or code object

>>> list(""=1)
  File "<stdin>", line 1
SyntaxError: keyword can't be an expression
```


> There is probably some error in how the external code is handling R
>> errors  (Fatal error: unable to initialize the JIT, stack smashing, etc)
>> and possibly also how R is initialized before calling ParseVector. Probably
>> you would get the same problem when running say "stop('myerror')". Please
>> note R errors are implemented as long-jumps, so care has to be taken when
>> calling into R, Writing R Extensions has more details (and section 8
>> specifically about embedding R). This is unlike parse (syntax) errors
>> signaled via return value to ParseVector()
>>
>
> The issue is that the segfault (because of stack smashing, therefore
> because of what also suspected to be an incontrolled jump) is happening
> within the execution of R_ParseVector(). I would think that an issue with
> the initialization of R is less likely because the project is otherwise
> used a fair bit and is well covered by automated continuous tests.
>
> After looking more into R's gram.c I suspect that an execution context is
> required for R_ParseVector() to know to properly work (know where to jump
> in case of error) when the parsing code decides to fail outside what it
> thinks is a syntax error. If the case, this would make R_ParseVector()
> function well when called from say, a C-extension to an R package, but fail
> the way I am seeing it fail when called from an embedded R.
>
> Yes, contexts are used internally to handle errors. For external use
> please see Writing R Extensions, section 6.12.
>

I have wrapped my call to R_ParseVector() in a R_tryCatchError(), and this
is seems to help me overcome the issue. Thanks for the pointer.

Best,


Laurent


> Best
> Tomas
>
>
> Best,
>
> Laurent
>
>> Best,
>> Tomas
>>
>>
>> We are otherwise aware that the error is not occurring in the R console,
>> but can be traced to a call to R_ParseVector() in R's C API:(
>> https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509
>> ).
>>
>> Our specific setup is calling an embedded R from Python, using the cffi
>> library. An error on end was the first possibility considered, but the
>> puzzling specificity of the error (as shown below other parsing errors are
>> handled properly) and the difficulty tracing what is in happening in
>> R_ParseVector() made me ask whether someone on this list had a suggestion
>> about the possible issue"
>>
>> ```
>>
>> >>> import rpy2.rinterface as ri>>> ri.initr()>>> e = ri.parse("list(''=1+") ---------------------------------------------------------------------------RParsingError                             Traceback (most recent call last)>>> e = ri.parse("list(''=123") R[write to console]: Error: attempt to use zero-length variable name
>> R[write to console]: Fatal error: unable to initialize the JIT
>>
>> *** stack smashing detected ***: <unknown> terminated
>> ```
>>
>>
>> Le lun. 2 d?c. 2019 ? 06:37, Tomas Kalibera <tomas.kalibera at gmail.com> a
>> ?crit :
>>
>>> Dear Laurent,
>>>
>>> could you please provide a complete reproducible example where parsing
>>> results in a crash of R? Calling parse(text="list(''=123") from R works
>>> fine for me (gives Error: attempt to use zero-length variable name).
>>>
>>> I don't think the problem you observed could be related to the memory
>>> leak. The leak is on the heap, not stack.
>>>
>>> Zero-length names of elements in a list are allowed. They are not the
>>> same thing as zero-length variables in an environment. If you try to
>>> convert "lst" from your example to an environment, you would get the
>>> error (attempt to use zero-length variable name).
>>>
>>> Best
>>> Tomas
>>>
>>>
>>> On 11/30/19 11:55 PM, Laurent Gautier wrote:
>>> > Hi again,
>>> >
>>> > Beside R_ParseVector()'s possible inconsistent behavior, R's handling
>>> of
>>> > zero-length named elements does not seem consistent either:
>>> >
>>> > ```
>>> >> lst <- list()
>>> >> lst[[""]] <- 1
>>> >> names(lst)
>>> > [1] ""
>>> >> list("" = 1)
>>> > Error: attempt to use zero-length variable name
>>> > ```
>>> >
>>> > Should the parser be made to accept as valid what is otherwise possible
>>> > when using `[[<` ?
>>> >
>>> >
>>> > Best,
>>> >
>>> > Laurent
>>> >
>>> >
>>> >
>>> > Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a
>>> ?crit :
>>> >
>>> >> I found the following code comment in `src/main/gram.c`:
>>> >>
>>> >> ```
>>> >>
>>> >> /* Memory leak
>>> >>
>>> >> yyparse(), as generated by bison, allocates extra space for the parser
>>> >> stack using malloc(). Unfortunately this means that there is a memory
>>> >> leak in case of an R error (long-jump). In principle, we could define
>>> >> yyoverflow() to relocate the parser stacks for bison and allocate say
>>> on
>>> >> the R heap, but yyoverflow() is undocumented and somewhat complicated
>>> >> (we would have to replicate some macros from the generated parser
>>> here).
>>> >> The same problem exists at least in the Rd and LaTeX parsers in tools.
>>> >> */
>>> >>
>>> >> ```
>>> >>
>>> >> Could this be related to be issue ?
>>> >>
>>> >> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com> a
>>> >> ?crit :
>>> >>
>>> >>> Hi,
>>> >>>
>>> >>> The behavior of
>>> >>> ```
>>> >>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>>> >>> ```
>>> >>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
>>> >>> depending on the string to be parsed.
>>> >>>
>>> >>> Trying to parse a string such as `"list(''=1+"` sets the
>>> >>> `ParseStatus` to incomplete parsing error but trying to parse
>>> >>> `"list(''=123"` will result in R sending a message to the console
>>> (followed but a crash):
>>> >>>
>>> >>> ```
>>> >>> R[write to console]: Error: attempt to use zero-length variable
>>> nameR[write to console]: Fatal error: unable to initialize the JIT*** stack
>>> smashing detected ***: <unknown> terminated
>>> >>> ```
>>> >>>
>>> >>> Is there a reason for the difference in behavior, and is there a
>>> workaround ?
>>> >>>
>>> >>> Thanks,
>>> >>>
>>> >>>
>>> >>> Laurent
>>> >>>
>>> >>>
>>> >       [[alternative HTML version deleted]]
>>> >
>>> > ______________________________________________
>>> > R-devel at r-project.org mailing list
>>> > https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>>
>>>
>>
>

	[[alternative HTML version deleted]]


From @|mon@urb@nek @end|ng |rom R-project@org  Sat Dec 14 18:04:20 2019
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Sat, 14 Dec 2019 12:04:20 -0500
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <CA+JCgN1HjZY37k=2Rz885FEPp67YkHRf_Pc8TLQ-Pc=08ZREGw@mail.gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
 <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
 <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
 <CA+JCgN1HjZY37k=2Rz885FEPp67YkHRf_Pc8TLQ-Pc=08ZREGw@mail.gmail.com>
Message-ID: <D785C6B8-2096-45BA-83BC-0CA037BF7718@R-project.org>

Laurent,

the main point here is that ParseVector() just like any other R API has to be called in a correct context since it can raise errors so the issue was that your C code has a bug of not setting R correctly (my guess would be your'e not creating the initial context necessary in embedded R). There are many different errors, your is just one of many that can occur - any R API call that does allocation (and parsing obviously does) can cause errors. Note that this is true for pretty much all R API functions.

Cheers,
Simon



> On Dec 14, 2019, at 11:25 AM, Laurent Gautier <lgautier at gmail.com> wrote:
> 
> Le lun. 9 d?c. 2019 ? 09:57, Tomas Kalibera <tomas.kalibera at gmail.com> a
> ?crit :
> 
>> On 12/9/19 2:54 PM, Laurent Gautier wrote:
>> 
>> 
>> 
>> Le lun. 9 d?c. 2019 ? 05:43, Tomas Kalibera <tomas.kalibera at gmail.com> a
>> ?crit :
>> 
>>> On 12/7/19 10:32 PM, Laurent Gautier wrote:
>>> 
>>> Thanks for the quick response Tomas.
>>> 
>>> The same error is indeed happening when trying to have a zero-length
>>> variable name in an environment. The surprising bit is then "why is this
>>> happening during parsing" (that is why are variables assigned to an
>>> environment) ?
>>> 
>>> The emitted R error (in the R console) is not a parse (syntax) error, but
>>> an error emitted during parsing when the parser tries to intern a name -
>>> look it up in a symbol table. Empty string is not allowed as a symbol name,
>>> and hence the error. In the call "list(''=1)" , the empty name is what
>>> could eventually become a name of a local variable inside list(), even
>>> though not yet during parsing.
>>> 
>> 
>> Thanks Tomas.
>> 
>> I guess this has do with R expressions being lazily evaluated, and names
>> of arguments in a call are also part of the expression. Now the puzzling
>> part is why is that at all part of the parsing: I would have expected
>> R_ParseVector() to be restricted to parsing... Now it feels like
>> R_ParseVector() is performing parsing, and a first level of evalution for
>> expressions that "should never work" (the empty name).
>> 
>> Think of it as an exception in say Python. Some failures during parsing
>> result in an exception (called error in R and implemented using a long
>> jump). Any time you are calling into R you can get an error; out of memory
>> is also signalled as R error.
>> 
> 
> 
> The surprising bit for me was that I had expected the function to solely
> perform parsing. I did expect an exception (and a jmp smashing the stack)
> when the function concerned is in the C-API, is parsing a string, and is
> using a parameter (pointer) to store whether parsing was a failure or a
> success.
> 
> Since you are making a comparison with Python, the distinction I am making
> between parsing and evaluation seem to apply there. For example:
> 
> ```
>>>> import parser
>>>> parser.expr('1+')
>  Traceback (most recent call last):
>  File "<stdin>", line 1, in <module>
>  File "<string>", line 1
>    1+
>     ^
> SyntaxError: unexpected EOF while parsing
>>>> p = parser.expr('list(""=1)')
>>>> p
> <parser.st at 0x7f360e5329f0>
>>>> eval(p)
> Traceback (most recent call last):
>  File "<stdin>", line 1, in <module>
> TypeError: eval() arg 1 must be a string, bytes or code object
> 
>>>> list(""=1)
>  File "<stdin>", line 1
> SyntaxError: keyword can't be an expression
> ```
> 
> 
>> There is probably some error in how the external code is handling R
>>> errors  (Fatal error: unable to initialize the JIT, stack smashing, etc)
>>> and possibly also how R is initialized before calling ParseVector. Probably
>>> you would get the same problem when running say "stop('myerror')". Please
>>> note R errors are implemented as long-jumps, so care has to be taken when
>>> calling into R, Writing R Extensions has more details (and section 8
>>> specifically about embedding R). This is unlike parse (syntax) errors
>>> signaled via return value to ParseVector()
>>> 
>> 
>> The issue is that the segfault (because of stack smashing, therefore
>> because of what also suspected to be an incontrolled jump) is happening
>> within the execution of R_ParseVector(). I would think that an issue with
>> the initialization of R is less likely because the project is otherwise
>> used a fair bit and is well covered by automated continuous tests.
>> 
>> After looking more into R's gram.c I suspect that an execution context is
>> required for R_ParseVector() to know to properly work (know where to jump
>> in case of error) when the parsing code decides to fail outside what it
>> thinks is a syntax error. If the case, this would make R_ParseVector()
>> function well when called from say, a C-extension to an R package, but fail
>> the way I am seeing it fail when called from an embedded R.
>> 
>> Yes, contexts are used internally to handle errors. For external use
>> please see Writing R Extensions, section 6.12.
>> 
> 
> I have wrapped my call to R_ParseVector() in a R_tryCatchError(), and this
> is seems to help me overcome the issue. Thanks for the pointer.
> 
> Best,
> 
> 
> Laurent
> 
> 
>> Best
>> Tomas
>> 
>> 
>> Best,
>> 
>> Laurent
>> 
>>> Best,
>>> Tomas
>>> 
>>> 
>>> We are otherwise aware that the error is not occurring in the R console,
>>> but can be traced to a call to R_ParseVector() in R's C API:(
>>> https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509
>>> ).
>>> 
>>> Our specific setup is calling an embedded R from Python, using the cffi
>>> library. An error on end was the first possibility considered, but the
>>> puzzling specificity of the error (as shown below other parsing errors are
>>> handled properly) and the difficulty tracing what is in happening in
>>> R_ParseVector() made me ask whether someone on this list had a suggestion
>>> about the possible issue"
>>> 
>>> ```
>>> 
>>>>>> import rpy2.rinterface as ri>>> ri.initr()>>> e = ri.parse("list(''=1+") ---------------------------------------------------------------------------RParsingError                             Traceback (most recent call last)>>> e = ri.parse("list(''=123") R[write to console]: Error: attempt to use zero-length variable name
>>> R[write to console]: Fatal error: unable to initialize the JIT
>>> 
>>> *** stack smashing detected ***: <unknown> terminated
>>> ```
>>> 
>>> 
>>> Le lun. 2 d?c. 2019 ? 06:37, Tomas Kalibera <tomas.kalibera at gmail.com> a
>>> ?crit :
>>> 
>>>> Dear Laurent,
>>>> 
>>>> could you please provide a complete reproducible example where parsing
>>>> results in a crash of R? Calling parse(text="list(''=123") from R works
>>>> fine for me (gives Error: attempt to use zero-length variable name).
>>>> 
>>>> I don't think the problem you observed could be related to the memory
>>>> leak. The leak is on the heap, not stack.
>>>> 
>>>> Zero-length names of elements in a list are allowed. They are not the
>>>> same thing as zero-length variables in an environment. If you try to
>>>> convert "lst" from your example to an environment, you would get the
>>>> error (attempt to use zero-length variable name).
>>>> 
>>>> Best
>>>> Tomas
>>>> 
>>>> 
>>>> On 11/30/19 11:55 PM, Laurent Gautier wrote:
>>>>> Hi again,
>>>>> 
>>>>> Beside R_ParseVector()'s possible inconsistent behavior, R's handling
>>>> of
>>>>> zero-length named elements does not seem consistent either:
>>>>> 
>>>>> ```
>>>>>> lst <- list()
>>>>>> lst[[""]] <- 1
>>>>>> names(lst)
>>>>> [1] ""
>>>>>> list("" = 1)
>>>>> Error: attempt to use zero-length variable name
>>>>> ```
>>>>> 
>>>>> Should the parser be made to accept as valid what is otherwise possible
>>>>> when using `[[<` ?
>>>>> 
>>>>> 
>>>>> Best,
>>>>> 
>>>>> Laurent
>>>>> 
>>>>> 
>>>>> 
>>>>> Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a
>>>> ?crit :
>>>>> 
>>>>>> I found the following code comment in `src/main/gram.c`:
>>>>>> 
>>>>>> ```
>>>>>> 
>>>>>> /* Memory leak
>>>>>> 
>>>>>> yyparse(), as generated by bison, allocates extra space for the parser
>>>>>> stack using malloc(). Unfortunately this means that there is a memory
>>>>>> leak in case of an R error (long-jump). In principle, we could define
>>>>>> yyoverflow() to relocate the parser stacks for bison and allocate say
>>>> on
>>>>>> the R heap, but yyoverflow() is undocumented and somewhat complicated
>>>>>> (we would have to replicate some macros from the generated parser
>>>> here).
>>>>>> The same problem exists at least in the Rd and LaTeX parsers in tools.
>>>>>> */
>>>>>> 
>>>>>> ```
>>>>>> 
>>>>>> Could this be related to be issue ?
>>>>>> 
>>>>>> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com> a
>>>>>> ?crit :
>>>>>> 
>>>>>>> Hi,
>>>>>>> 
>>>>>>> The behavior of
>>>>>>> ```
>>>>>>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>>>>>>> ```
>>>>>>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
>>>>>>> depending on the string to be parsed.
>>>>>>> 
>>>>>>> Trying to parse a string such as `"list(''=1+"` sets the
>>>>>>> `ParseStatus` to incomplete parsing error but trying to parse
>>>>>>> `"list(''=123"` will result in R sending a message to the console
>>>> (followed but a crash):
>>>>>>> 
>>>>>>> ```
>>>>>>> R[write to console]: Error: attempt to use zero-length variable
>>>> nameR[write to console]: Fatal error: unable to initialize the JIT*** stack
>>>> smashing detected ***: <unknown> terminated
>>>>>>> ```
>>>>>>> 
>>>>>>> Is there a reason for the difference in behavior, and is there a
>>>> workaround ?
>>>>>>> 
>>>>>>> Thanks,
>>>>>>> 
>>>>>>> 
>>>>>>> Laurent
>>>>>>> 
>>>>>>> 
>>>>>      [[alternative HTML version deleted]]
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>>> 
>>>> 
>>> 
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Sat Dec 14 22:50:07 2019
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Sat, 14 Dec 2019 22:50:07 +0100
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <24050.26847.78668.28633@stat.math.ethz.ch>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
 <20191207205901.4265F22877@v-lynne.math.ethz.ch>
 <20191207211858.dpnqeslbln5caz2v@PMW>
 <20191209214336.iy66s5q4nzawdfch@PMW>
 <24050.26847.78668.28633@stat.math.ethz.ch>
Message-ID: <24053.22799.647150.274364@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Thu, 12 Dec 2019 17:20:47 +0100 writes:

>>>>> Karolis Koncevi?ius 
>>>>>     on Mon, 9 Dec 2019 23:43:36 +0200 writes:

    >> So I tried adding Infinity support for all cases.  And it
    >> is (as could be expected) more complicated than I
    >> thought.

    > "Of course !"  Thank you, Karolis, in any case!

    >> It is easy to add Inf support for the test. The problems
    >> start with conf.int=TRUE.

    >> Currently confidence intervals are computed via
    >> `uniroot()` and, in the case of infinities, we are
    >> computationally looking for roots over infinite interval
    >> which results in an error. I suspect this is the reason
    >> Inf values were removed in the first place.

    > Maybe. It's still wrong to be done "up front".  I'm sure
    > 98% (or so ;-) of all calls to wilcox.test() do *not* use
    > conf.int = TRUE


    >> Just a note, I found a few more errors/inconsistencies
    >> when requesting confidence intervals with paired=TRUE
    >> (due to Infinities being left in).

    >> Current error in Inf-Inf scenario:

    >> wilcox.test(c(1,2,Inf), c(4,8,Inf), paired=TRUE,
    >> conf.int=TRUE) Error in if (ZEROES) x <- x[x != 0] :
    >> missing value where TRUE/FALSE needed

    > Good catch .. notably as it also happens when
    > conf.int=FALSE as by default.  My version of wilcox.test()
    > now does give the same as when the to 'Inf' are left away.

    >> NaN confidence intervals:

    >> wilcox.test(c(1:9,Inf), c(21:28,Inf,30), paired=TRUE,
    >> conf.int=TRUE)

    >> Wilcoxon signed rank test with continuity correction

    >> data: c(1:9, Inf) and c(21:28, Inf, 30) V = 9.5, p-value
    >> = 0.0586 alternative hypothesis: true location shift is
    >> not equal to 0 0 percent confidence interval: NaN NaN
    >> sample estimates: midrange NaN

    > I don't see a big problem here. The NaN's in some sense
    > show the best that can be computed with this data.
    > Statistic and P-value, but no conf.int.


    >> The easiest "fix" for consistency would be to simply
    >> remove Infinity support from the paired=TRUE case.

    > I strongly disagree.  We are not pruning good
    > functionality just for some definition of consistency.

    >> But going with the more desirable approach of adding
    >> Infinity support for non-paired cases - it is currently
    >> not clear to me what confidence intervals and
    >> pseudomedian should be. Specially when Infinities are on
    >> both sides.

    > I deem that not to be a big deal.  They are not defined
    > given the default formulas and that is reflected by NA /
    > NaN in those parts of the result.

    >> Regards, Karolis Koncevi?ius.

    > But I have also spent a few hours now on
    > wilcox.test.default() behavior notably also looking at the
    > "rounding" / "machine precision" situation, and also on
    > your remark that the 'method: ...' does not indicate well
    > enough what was computed.

    > In my (not yet committed) but hereby proposed enhancement
    > of wilcox.test(), I have a new argument, 'digits.rank =
    > Inf' (the default 'Inf' corresponding to the current
    > behavior) with help page documentation:

    > digits.rank: a number; if finite, ?rank(signif(r,
    > digits.rank))? will be used to compute ranks for the test
    > statistic instead of (the default) ?rank(r)?.

    > and then in 'Details :'

    >      For stability reasons, it may be advisable to use
    > rounded data or to set ?digits.rank = 7?, say, such that
    > determination of ties does not depend on very small
    > numeric differences (see the example).

    > and then in 'Examples: '

    >      ## accuracy in ties determination via 'digits.rank':
    > wilcox.test( 4:2, 3:1, paired=TRUE) # Warning: cannot
    > compute exact p-value with ties wilcox.test((4:2)/10,
    > (3:1)/10, paired=TRUE) # no ties => *no* warning
    > wilcox.test((4:2)/10, (3:1)/10, paired=TRUE, digits.rank =
    > 9) # same ties as (4:2, 3:1)
     
    > ----------------------

    > Lastly, I propose to replace "test" by "exact test" in the
    > 'method' component (and print out) in case exact
    > computations were used.  This information should be part
    > of the returned "htest" object, and not only visible from
    > the arguments and warnings that are printed during the
    > computations.  This last change is in some sense the "most
    > back-incompatible" change of these, because many
    > wilcox.test() printouts would slightly change, e.g.,

    >> w0 <- wilcox.test( 1:5, 4*(0:4), paired=TRUE)

    > 	  Wilcoxon signed rank exact test

    >   data: 1:5 and 4 * (0:4) V = 1, p-value = 0.125
    > alternative hypothesis: true location shift is not equal
    > to 0

    > where before (in R <= 3.6.x) it is just

    > 	  Wilcoxon signed rank test

    >   data: .........  ...............  ...............

    > but I think R 4.0.0 is a good occasion for such a change.

    > Constructive feedback on all this is very welcome!  Martin

... none  ...  I "assume" this means everybody likes the idea ;-)

Anyway, now comitted to R-devel (for R 4.0.0), svn rev 77569
(in 'NEW FEATURES').

Martin 



    >> On 2019-12-07 23:18, Karolis Koncevi?ius wrote:
    >>> Thank you for a fast response. Nice to see this mailing
    >>> list being so alive.
    >>> 
    >>> Regarding Inf issue: I agree with your assessment that
    >>> Inf should not be removed. The code gave me an
    >>> impression that Inf values were intentionally removed
    >>> (since is.finite() was used everywhere, except for
    >>> paired case). I will try to adjust my patch according to
    >>> your feedback.
    >>> 
    >>> One more thing: it seems like you assumed that issues
    >>> 2:4 are all related to machine precision, which is not
    >>> the case - only 2nd issue is.  Just wanted to draw this
    >>> to your attention, in case you might have some feedback
    >>> and guidelines about issues 3 and 4 as well.
    >>> 
    >>> 
    >>> 
    >>> On 2019-12-07 21:59, Martin Maechler wrote:
    >>>>>>>>> Karolis Koncevi?ius on Sat, 7 Dec 2019 20:55:36
    >>>>>>>>> +0200 writes:
    >>>> 
    >>>> > Hello, > Writing to share some things I've found
    >>>> about wilcox.test() that seem a > a bit inconsistent.
    >>>> 
    >>>> > 1. Inf values are not removed if paired=TRUE
    >>>> 
    >>>> > # returns different results (Inf is removed): >
    >>>> wilcox.test(c(1,2,3,4), c(0,9,8,7)) >
    >>>> wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
    >>>> 
    >>>> > # returns the same result (Inf is left as value with
    >>>> highest rank): > wilcox.test(c(1,2,3,4), c(0,9,8,7),
    >>>> paired=TRUE) > wilcox.test(c(1,2,3,4), c(0,9,8,Inf),
    >>>> paired=TRUE)
    >>>> 
    >>>> Now which of the two cases do you consider correct ?
    >>>> 
    >>>> IHMO, the 2nd one is correct: it is exactly one
    >>>> property of the *robustness* of the wilcoxon test and
    >>>> very desirable that any (positive) outlier is treated
    >>>> the same as just "the largest value" and the test
    >>>> statistic (and hence the p-value) should not change.
    >>>> 
    >>>> So I think the first case is wrong, notably if
    >>>> modified, (such that the last y is the overall maximal
    >>>> value (slightly larger sample):
    >>>> 
    >>>>> wilcox.test(1:7, 1/8+ c(9:4, 12))
    >>>> 
    >>>> Wilcoxon rank sum test
    >>>> 
    >>>> data: 1:7 and 1/8 + c(9:4, 12) W = 6, p-value = 0.01748
    >>>> alternative hypothesis: true location shift is not
    >>>> equal to 0
    >>>> 
    >>>>> wilcox.test(1:7, 1/8+ c(9:4, 10000))
    >>>> 
    >>>> Wilcoxon rank sum test
    >>>> 
    >>>> data: 1:7 and 1/8 + c(9:4, 10000) W = 6, p-value =
    >>>> 0.01748 alternative hypothesis: true location shift is
    >>>> not equal to 0
    >>>> 
    >>>>> wilcox.test(1:7, 1/8+ c(9:4, Inf))
    >>>> 
    >>>> Wilcoxon rank sum test
    >>>> 
    >>>> data: 1:7 and 1/8 + c(9:4, Inf) W = 6, p-value =
    >>>> 0.03497 alternative hypothesis: true location shift is
    >>>> not equal to 0
    >>>> 
    >>>> The Inf case should definitely give the same as the
    >>>> 10'000 case.  That's exactly one property of a robust
    >>>> statistic.
    >>>> 
    >>>> Thank you, Karolis, this is pretty embarrassing to only
    >>>> be detected now after 25+ years of R in use ...
    >>>> 
    >>>> The correct fix starts with replacing the is.finite()
    >>>> by !is.na() and keep the 'Inf' in the rank
    >>>> computations...  (but then probably also deal with the
    >>>> case of more than one Inf, notably the Inf - Inf
    >>>> "exception" which is not triggered by your example...)
    >>>> 
    >>>> 
    >>>> ---
    >>>> 
    >>>> Ben addressed the "rounding" / numerical issues
    >>>> unavoidable for the other problems.
    >>>> 
    >>>> > 2. tolerance issues with paired=TRUE.
    >>>> 
    >>>> > wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE) > #
    >>>> ...  > # Warning: cannot compute exact p-value with
    >>>> ties
    >>>> 
    >>>> > wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1),
    >>>> paired=TRUE) > # ...  > # no warning
    >>>> 
    >>>> > 3. Always 'x observations are missing' when
    >>>> paired=TRUE
    >>>> 
    >>>> > wilcox.test(c(1,2), c(NA_integer_,NA_integer_),
    >>>> paired=TRUE) > # ...  > # Error: not enough (finite)
    >>>> 'x' observations
    >>>> 
    >>>> > 4. No indication if normal approximation was used:
    >>>> 
    >>>> > # different numbers, but same "method" name >
    >>>> wilcox.test(rnorm(10), exact=FALSE, correct=FALSE) >
    >>>> wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
    >>>> 
    >>>> 
    >>>> > From all of these I am pretty sure the 1st one is
    >>>> likely unintended, > so attaching a small patch to
    >>>> adjust it. Can also try patching others if > consensus
    >>>> is reached that the behavioiur has to be modified.
    >>>> 
    >>>> > Kind regards, > Karolis Koncevi?ius.
    >>>>


From |g@ut|er @end|ng |rom gm@||@com  Sat Dec 14 23:29:50 2019
From: |g@ut|er @end|ng |rom gm@||@com (Laurent Gautier)
Date: Sat, 14 Dec 2019 17:29:50 -0500
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <D785C6B8-2096-45BA-83BC-0CA037BF7718@R-project.org>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
 <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
 <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
 <CA+JCgN1HjZY37k=2Rz885FEPp67YkHRf_Pc8TLQ-Pc=08ZREGw@mail.gmail.com>
 <D785C6B8-2096-45BA-83BC-0CA037BF7718@R-project.org>
Message-ID: <CA+JCgN1GD1+7uRnurO_5XgDuTKbBe6V5ABi0DTaP48MDuTbmTw@mail.gmail.com>

Hi Simon,

Widespread errors would have caught my earlier as the way that code is
using only one initialization of the embedded R, is used quite a bit, and
is covered by quite a few unit tests. This is the only situation I am aware
of in which an error occurs.

What is a "correct context", or initial context, the code should from ?
Searching for "context" in the R-exts manual does not return much.

Best,

Laurent


Le sam. 14 d?c. 2019 ? 12:20, Simon Urbanek <simon.urbanek at r-project.org> a
?crit :

> Laurent,
>
> the main point here is that ParseVector() just like any other R API has to
> be called in a correct context since it can raise errors so the issue was
> that your C code has a bug of not setting R correctly (my guess would be
> your'e not creating the initial context necessary in embedded R). There are
> many different errors, your is just one of many that can occur - any R API
> call that does allocation (and parsing obviously does) can cause errors.
> Note that this is true for pretty much all R API functions.
>
> Cheers,
> Simon
>
>
>
> > On Dec 14, 2019, at 11:25 AM, Laurent Gautier <lgautier at gmail.com>
> wrote:
> >
> > Le lun. 9 d?c. 2019 ? 09:57, Tomas Kalibera <tomas.kalibera at gmail.com> a
> > ?crit :
> >
> >> On 12/9/19 2:54 PM, Laurent Gautier wrote:
> >>
> >>
> >>
> >> Le lun. 9 d?c. 2019 ? 05:43, Tomas Kalibera <tomas.kalibera at gmail.com>
> a
> >> ?crit :
> >>
> >>> On 12/7/19 10:32 PM, Laurent Gautier wrote:
> >>>
> >>> Thanks for the quick response Tomas.
> >>>
> >>> The same error is indeed happening when trying to have a zero-length
> >>> variable name in an environment. The surprising bit is then "why is
> this
> >>> happening during parsing" (that is why are variables assigned to an
> >>> environment) ?
> >>>
> >>> The emitted R error (in the R console) is not a parse (syntax) error,
> but
> >>> an error emitted during parsing when the parser tries to intern a name
> -
> >>> look it up in a symbol table. Empty string is not allowed as a symbol
> name,
> >>> and hence the error. In the call "list(''=1)" , the empty name is what
> >>> could eventually become a name of a local variable inside list(), even
> >>> though not yet during parsing.
> >>>
> >>
> >> Thanks Tomas.
> >>
> >> I guess this has do with R expressions being lazily evaluated, and names
> >> of arguments in a call are also part of the expression. Now the puzzling
> >> part is why is that at all part of the parsing: I would have expected
> >> R_ParseVector() to be restricted to parsing... Now it feels like
> >> R_ParseVector() is performing parsing, and a first level of evalution
> for
> >> expressions that "should never work" (the empty name).
> >>
> >> Think of it as an exception in say Python. Some failures during parsing
> >> result in an exception (called error in R and implemented using a long
> >> jump). Any time you are calling into R you can get an error; out of
> memory
> >> is also signalled as R error.
> >>
> >
> >
> > The surprising bit for me was that I had expected the function to solely
> > perform parsing. I did expect an exception (and a jmp smashing the stack)
> > when the function concerned is in the C-API, is parsing a string, and is
> > using a parameter (pointer) to store whether parsing was a failure or a
> > success.
> >
> > Since you are making a comparison with Python, the distinction I am
> making
> > between parsing and evaluation seem to apply there. For example:
> >
> > ```
> >>>> import parser
> >>>> parser.expr('1+')
> >  Traceback (most recent call last):
> >  File "<stdin>", line 1, in <module>
> >  File "<string>", line 1
> >    1+
> >     ^
> > SyntaxError: unexpected EOF while parsing
> >>>> p = parser.expr('list(""=1)')
> >>>> p
> > <parser.st at 0x7f360e5329f0>
> >>>> eval(p)
> > Traceback (most recent call last):
> >  File "<stdin>", line 1, in <module>
> > TypeError: eval() arg 1 must be a string, bytes or code object
> >
> >>>> list(""=1)
> >  File "<stdin>", line 1
> > SyntaxError: keyword can't be an expression
> > ```
> >
> >
> >> There is probably some error in how the external code is handling R
> >>> errors  (Fatal error: unable to initialize the JIT, stack smashing,
> etc)
> >>> and possibly also how R is initialized before calling ParseVector.
> Probably
> >>> you would get the same problem when running say "stop('myerror')".
> Please
> >>> note R errors are implemented as long-jumps, so care has to be taken
> when
> >>> calling into R, Writing R Extensions has more details (and section 8
> >>> specifically about embedding R). This is unlike parse (syntax) errors
> >>> signaled via return value to ParseVector()
> >>>
> >>
> >> The issue is that the segfault (because of stack smashing, therefore
> >> because of what also suspected to be an incontrolled jump) is happening
> >> within the execution of R_ParseVector(). I would think that an issue
> with
> >> the initialization of R is less likely because the project is otherwise
> >> used a fair bit and is well covered by automated continuous tests.
> >>
> >> After looking more into R's gram.c I suspect that an execution context
> is
> >> required for R_ParseVector() to know to properly work (know where to
> jump
> >> in case of error) when the parsing code decides to fail outside what it
> >> thinks is a syntax error. If the case, this would make R_ParseVector()
> >> function well when called from say, a C-extension to an R package, but
> fail
> >> the way I am seeing it fail when called from an embedded R.
> >>
> >> Yes, contexts are used internally to handle errors. For external use
> >> please see Writing R Extensions, section 6.12.
> >>
> >
> > I have wrapped my call to R_ParseVector() in a R_tryCatchError(), and
> this
> > is seems to help me overcome the issue. Thanks for the pointer.
> >
> > Best,
> >
> >
> > Laurent
> >
> >
> >> Best
> >> Tomas
> >>
> >>
> >> Best,
> >>
> >> Laurent
> >>
> >>> Best,
> >>> Tomas
> >>>
> >>>
> >>> We are otherwise aware that the error is not occurring in the R
> console,
> >>> but can be traced to a call to R_ParseVector() in R's C API:(
> >>>
> https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509
> >>> ).
> >>>
> >>> Our specific setup is calling an embedded R from Python, using the cffi
> >>> library. An error on end was the first possibility considered, but the
> >>> puzzling specificity of the error (as shown below other parsing errors
> are
> >>> handled properly) and the difficulty tracing what is in happening in
> >>> R_ParseVector() made me ask whether someone on this list had a
> suggestion
> >>> about the possible issue"
> >>>
> >>> ```
> >>>
> >>>>>> import rpy2.rinterface as ri>>> ri.initr()>>> e =
> ri.parse("list(''=1+")
> ---------------------------------------------------------------------------RParsingError
>                            Traceback (most recent call last)>>> e =
> ri.parse("list(''=123") R[write to console]: Error: attempt to use
> zero-length variable name
> >>> R[write to console]: Fatal error: unable to initialize the JIT
> >>>
> >>> *** stack smashing detected ***: <unknown> terminated
> >>> ```
> >>>
> >>>
> >>> Le lun. 2 d?c. 2019 ? 06:37, Tomas Kalibera <tomas.kalibera at gmail.com>
> a
> >>> ?crit :
> >>>
> >>>> Dear Laurent,
> >>>>
> >>>> could you please provide a complete reproducible example where parsing
> >>>> results in a crash of R? Calling parse(text="list(''=123") from R
> works
> >>>> fine for me (gives Error: attempt to use zero-length variable name).
> >>>>
> >>>> I don't think the problem you observed could be related to the memory
> >>>> leak. The leak is on the heap, not stack.
> >>>>
> >>>> Zero-length names of elements in a list are allowed. They are not the
> >>>> same thing as zero-length variables in an environment. If you try to
> >>>> convert "lst" from your example to an environment, you would get the
> >>>> error (attempt to use zero-length variable name).
> >>>>
> >>>> Best
> >>>> Tomas
> >>>>
> >>>>
> >>>> On 11/30/19 11:55 PM, Laurent Gautier wrote:
> >>>>> Hi again,
> >>>>>
> >>>>> Beside R_ParseVector()'s possible inconsistent behavior, R's handling
> >>>> of
> >>>>> zero-length named elements does not seem consistent either:
> >>>>>
> >>>>> ```
> >>>>>> lst <- list()
> >>>>>> lst[[""]] <- 1
> >>>>>> names(lst)
> >>>>> [1] ""
> >>>>>> list("" = 1)
> >>>>> Error: attempt to use zero-length variable name
> >>>>> ```
> >>>>>
> >>>>> Should the parser be made to accept as valid what is otherwise
> possible
> >>>>> when using `[[<` ?
> >>>>>
> >>>>>
> >>>>> Best,
> >>>>>
> >>>>> Laurent
> >>>>>
> >>>>>
> >>>>>
> >>>>> Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a
> >>>> ?crit :
> >>>>>
> >>>>>> I found the following code comment in `src/main/gram.c`:
> >>>>>>
> >>>>>> ```
> >>>>>>
> >>>>>> /* Memory leak
> >>>>>>
> >>>>>> yyparse(), as generated by bison, allocates extra space for the
> parser
> >>>>>> stack using malloc(). Unfortunately this means that there is a
> memory
> >>>>>> leak in case of an R error (long-jump). In principle, we could
> define
> >>>>>> yyoverflow() to relocate the parser stacks for bison and allocate
> say
> >>>> on
> >>>>>> the R heap, but yyoverflow() is undocumented and somewhat
> complicated
> >>>>>> (we would have to replicate some macros from the generated parser
> >>>> here).
> >>>>>> The same problem exists at least in the Rd and LaTeX parsers in
> tools.
> >>>>>> */
> >>>>>>
> >>>>>> ```
> >>>>>>
> >>>>>> Could this be related to be issue ?
> >>>>>>
> >>>>>> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com>
> a
> >>>>>> ?crit :
> >>>>>>
> >>>>>>> Hi,
> >>>>>>>
> >>>>>>> The behavior of
> >>>>>>> ```
> >>>>>>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
> >>>>>>> ```
> >>>>>>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
> >>>>>>> depending on the string to be parsed.
> >>>>>>>
> >>>>>>> Trying to parse a string such as `"list(''=1+"` sets the
> >>>>>>> `ParseStatus` to incomplete parsing error but trying to parse
> >>>>>>> `"list(''=123"` will result in R sending a message to the console
> >>>> (followed but a crash):
> >>>>>>>
> >>>>>>> ```
> >>>>>>> R[write to console]: Error: attempt to use zero-length variable
> >>>> nameR[write to console]: Fatal error: unable to initialize the JIT***
> stack
> >>>> smashing detected ***: <unknown> terminated
> >>>>>>> ```
> >>>>>>>
> >>>>>>> Is there a reason for the difference in behavior, and is there a
> >>>> workaround ?
> >>>>>>>
> >>>>>>> Thanks,
> >>>>>>>
> >>>>>>>
> >>>>>>> Laurent
> >>>>>>>
> >>>>>>>
> >>>>>      [[alternative HTML version deleted]]
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>>
> >>>>
> >>>
> >>
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>

	[[alternative HTML version deleted]]


From @|mon@urb@nek @end|ng |rom R-project@org  Sun Dec 15 01:56:53 2019
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Sat, 14 Dec 2019 19:56:53 -0500
Subject: [Rd] Inconsistent behavior for the C AP's R_ParseVector() ?
In-Reply-To: <CA+JCgN1GD1+7uRnurO_5XgDuTKbBe6V5ABi0DTaP48MDuTbmTw@mail.gmail.com>
References: <CA+JCgN0vZ8O1ekweEgPqcH202PKU2dfMW959eF=Q2S8K1OSKeQ@mail.gmail.com>
 <CA+JCgN05ZRAuWwMEKX77jcfOw7s3g=Sf+vxRjVrVQbUfEutmoA@mail.gmail.com>
 <CA+JCgN3iocdn8xVxVuYcsqNSeQ3KQHg3P3FHBf=VV7=zDzxQaQ@mail.gmail.com>
 <8b6673c4-c7a2-d186-61a6-2a92e7d0e0f5@gmail.com>
 <CA+JCgN0Eu9gzwBipwR5XnWrboZXLGbjroPjuxjtHKiRETim6eA@mail.gmail.com>
 <9c301815-c18f-38b9-d841-b7d35dc76ba6@gmail.com>
 <CA+JCgN2Ckchvh3tbXEVk+EKt3d3enkD=MZPKYAJSd9G+oo1FrA@mail.gmail.com>
 <a9e51e1e-feb2-4f56-3627-120d9c413f31@gmail.com>
 <CA+JCgN1HjZY37k=2Rz885FEPp67YkHRf_Pc8TLQ-Pc=08ZREGw@mail.gmail.com>
 <D785C6B8-2096-45BA-83BC-0CA037BF7718@R-project.org>
 <CA+JCgN1GD1+7uRnurO_5XgDuTKbBe6V5ABi0DTaP48MDuTbmTw@mail.gmail.com>
Message-ID: <E325C266-3ACB-4DDC-AAD5-C528BD1A506E@R-project.org>

Laurent,


> On Dec 14, 2019, at 5:29 PM, Laurent Gautier <lgautier at gmail.com> wrote:
> 
> Hi Simon,
> 
> Widespread errors would have caught my earlier as the way that code is
> using only one initialization of the embedded R, is used quite a bit, and
> is covered by quite a few unit tests. This is the only situation I am aware
> of in which an error occurs.
> 

It may or may not be "widespread" - almost all R API functions can raise errors (e.g., unable to allocate). You'll only find out once they do and that's too late ;).


> What is a "correct context", or initial context, the code should from ?
> Searching for "context" in the R-exts manual does not return much.
> 

It depends which embedded API use - see R-ext 8.1 the two options are run_Rmainloop() and R_ReplDLLinit() which both setup the top-level context with SETJMP. If you don't use either then you have to use one of the advanced R APIs that do it such as R_ToplevelExec() or R_UnwindProtect(), otherwise your point to abort to on error doesn't exist. Embedding R is much more complex than many think ...

Cheers,
Simon



> Best,
> 
> Laurent
> 
> 
> Le sam. 14 d?c. 2019 ? 12:20, Simon Urbanek <simon.urbanek at r-project.org> a
> ?crit :
> 
>> Laurent,
>> 
>> the main point here is that ParseVector() just like any other R API has to
>> be called in a correct context since it can raise errors so the issue was
>> that your C code has a bug of not setting R correctly (my guess would be
>> your'e not creating the initial context necessary in embedded R). There are
>> many different errors, your is just one of many that can occur - any R API
>> call that does allocation (and parsing obviously does) can cause errors.
>> Note that this is true for pretty much all R API functions.
>> 
>> Cheers,
>> Simon
>> 
>> 
>> 
>>> On Dec 14, 2019, at 11:25 AM, Laurent Gautier <lgautier at gmail.com>
>> wrote:
>>> 
>>> Le lun. 9 d?c. 2019 ? 09:57, Tomas Kalibera <tomas.kalibera at gmail.com> a
>>> ?crit :
>>> 
>>>> On 12/9/19 2:54 PM, Laurent Gautier wrote:
>>>> 
>>>> 
>>>> 
>>>> Le lun. 9 d?c. 2019 ? 05:43, Tomas Kalibera <tomas.kalibera at gmail.com>
>> a
>>>> ?crit :
>>>> 
>>>>> On 12/7/19 10:32 PM, Laurent Gautier wrote:
>>>>> 
>>>>> Thanks for the quick response Tomas.
>>>>> 
>>>>> The same error is indeed happening when trying to have a zero-length
>>>>> variable name in an environment. The surprising bit is then "why is
>> this
>>>>> happening during parsing" (that is why are variables assigned to an
>>>>> environment) ?
>>>>> 
>>>>> The emitted R error (in the R console) is not a parse (syntax) error,
>> but
>>>>> an error emitted during parsing when the parser tries to intern a name
>> -
>>>>> look it up in a symbol table. Empty string is not allowed as a symbol
>> name,
>>>>> and hence the error. In the call "list(''=1)" , the empty name is what
>>>>> could eventually become a name of a local variable inside list(), even
>>>>> though not yet during parsing.
>>>>> 
>>>> 
>>>> Thanks Tomas.
>>>> 
>>>> I guess this has do with R expressions being lazily evaluated, and names
>>>> of arguments in a call are also part of the expression. Now the puzzling
>>>> part is why is that at all part of the parsing: I would have expected
>>>> R_ParseVector() to be restricted to parsing... Now it feels like
>>>> R_ParseVector() is performing parsing, and a first level of evalution
>> for
>>>> expressions that "should never work" (the empty name).
>>>> 
>>>> Think of it as an exception in say Python. Some failures during parsing
>>>> result in an exception (called error in R and implemented using a long
>>>> jump). Any time you are calling into R you can get an error; out of
>> memory
>>>> is also signalled as R error.
>>>> 
>>> 
>>> 
>>> The surprising bit for me was that I had expected the function to solely
>>> perform parsing. I did expect an exception (and a jmp smashing the stack)
>>> when the function concerned is in the C-API, is parsing a string, and is
>>> using a parameter (pointer) to store whether parsing was a failure or a
>>> success.
>>> 
>>> Since you are making a comparison with Python, the distinction I am
>> making
>>> between parsing and evaluation seem to apply there. For example:
>>> 
>>> ```
>>>>>> import parser
>>>>>> parser.expr('1+')
>>> Traceback (most recent call last):
>>> File "<stdin>", line 1, in <module>
>>> File "<string>", line 1
>>>   1+
>>>    ^
>>> SyntaxError: unexpected EOF while parsing
>>>>>> p = parser.expr('list(""=1)')
>>>>>> p
>>> <parser.st at 0x7f360e5329f0>
>>>>>> eval(p)
>>> Traceback (most recent call last):
>>> File "<stdin>", line 1, in <module>
>>> TypeError: eval() arg 1 must be a string, bytes or code object
>>> 
>>>>>> list(""=1)
>>> File "<stdin>", line 1
>>> SyntaxError: keyword can't be an expression
>>> ```
>>> 
>>> 
>>>> There is probably some error in how the external code is handling R
>>>>> errors  (Fatal error: unable to initialize the JIT, stack smashing,
>> etc)
>>>>> and possibly also how R is initialized before calling ParseVector.
>> Probably
>>>>> you would get the same problem when running say "stop('myerror')".
>> Please
>>>>> note R errors are implemented as long-jumps, so care has to be taken
>> when
>>>>> calling into R, Writing R Extensions has more details (and section 8
>>>>> specifically about embedding R). This is unlike parse (syntax) errors
>>>>> signaled via return value to ParseVector()
>>>>> 
>>>> 
>>>> The issue is that the segfault (because of stack smashing, therefore
>>>> because of what also suspected to be an incontrolled jump) is happening
>>>> within the execution of R_ParseVector(). I would think that an issue
>> with
>>>> the initialization of R is less likely because the project is otherwise
>>>> used a fair bit and is well covered by automated continuous tests.
>>>> 
>>>> After looking more into R's gram.c I suspect that an execution context
>> is
>>>> required for R_ParseVector() to know to properly work (know where to
>> jump
>>>> in case of error) when the parsing code decides to fail outside what it
>>>> thinks is a syntax error. If the case, this would make R_ParseVector()
>>>> function well when called from say, a C-extension to an R package, but
>> fail
>>>> the way I am seeing it fail when called from an embedded R.
>>>> 
>>>> Yes, contexts are used internally to handle errors. For external use
>>>> please see Writing R Extensions, section 6.12.
>>>> 
>>> 
>>> I have wrapped my call to R_ParseVector() in a R_tryCatchError(), and
>> this
>>> is seems to help me overcome the issue. Thanks for the pointer.
>>> 
>>> Best,
>>> 
>>> 
>>> Laurent
>>> 
>>> 
>>>> Best
>>>> Tomas
>>>> 
>>>> 
>>>> Best,
>>>> 
>>>> Laurent
>>>> 
>>>>> Best,
>>>>> Tomas
>>>>> 
>>>>> 
>>>>> We are otherwise aware that the error is not occurring in the R
>> console,
>>>>> but can be traced to a call to R_ParseVector() in R's C API:(
>>>>> 
>> https://github.com/rpy2/rpy2/blob/master/rpy2/rinterface_lib/_rinterface_capi.py#L509
>>>>> ).
>>>>> 
>>>>> Our specific setup is calling an embedded R from Python, using the cffi
>>>>> library. An error on end was the first possibility considered, but the
>>>>> puzzling specificity of the error (as shown below other parsing errors
>> are
>>>>> handled properly) and the difficulty tracing what is in happening in
>>>>> R_ParseVector() made me ask whether someone on this list had a
>> suggestion
>>>>> about the possible issue"
>>>>> 
>>>>> ```
>>>>> 
>>>>>>>> import rpy2.rinterface as ri>>> ri.initr()>>> e =
>> ri.parse("list(''=1+")
>> ---------------------------------------------------------------------------RParsingError
>>                           Traceback (most recent call last)>>> e =
>> ri.parse("list(''=123") R[write to console]: Error: attempt to use
>> zero-length variable name
>>>>> R[write to console]: Fatal error: unable to initialize the JIT
>>>>> 
>>>>> *** stack smashing detected ***: <unknown> terminated
>>>>> ```
>>>>> 
>>>>> 
>>>>> Le lun. 2 d?c. 2019 ? 06:37, Tomas Kalibera <tomas.kalibera at gmail.com>
>> a
>>>>> ?crit :
>>>>> 
>>>>>> Dear Laurent,
>>>>>> 
>>>>>> could you please provide a complete reproducible example where parsing
>>>>>> results in a crash of R? Calling parse(text="list(''=123") from R
>> works
>>>>>> fine for me (gives Error: attempt to use zero-length variable name).
>>>>>> 
>>>>>> I don't think the problem you observed could be related to the memory
>>>>>> leak. The leak is on the heap, not stack.
>>>>>> 
>>>>>> Zero-length names of elements in a list are allowed. They are not the
>>>>>> same thing as zero-length variables in an environment. If you try to
>>>>>> convert "lst" from your example to an environment, you would get the
>>>>>> error (attempt to use zero-length variable name).
>>>>>> 
>>>>>> Best
>>>>>> Tomas
>>>>>> 
>>>>>> 
>>>>>> On 11/30/19 11:55 PM, Laurent Gautier wrote:
>>>>>>> Hi again,
>>>>>>> 
>>>>>>> Beside R_ParseVector()'s possible inconsistent behavior, R's handling
>>>>>> of
>>>>>>> zero-length named elements does not seem consistent either:
>>>>>>> 
>>>>>>> ```
>>>>>>>> lst <- list()
>>>>>>>> lst[[""]] <- 1
>>>>>>>> names(lst)
>>>>>>> [1] ""
>>>>>>>> list("" = 1)
>>>>>>> Error: attempt to use zero-length variable name
>>>>>>> ```
>>>>>>> 
>>>>>>> Should the parser be made to accept as valid what is otherwise
>> possible
>>>>>>> when using `[[<` ?
>>>>>>> 
>>>>>>> 
>>>>>>> Best,
>>>>>>> 
>>>>>>> Laurent
>>>>>>> 
>>>>>>> 
>>>>>>> 
>>>>>>> Le sam. 30 nov. 2019 ? 17:33, Laurent Gautier <lgautier at gmail.com> a
>>>>>> ?crit :
>>>>>>> 
>>>>>>>> I found the following code comment in `src/main/gram.c`:
>>>>>>>> 
>>>>>>>> ```
>>>>>>>> 
>>>>>>>> /* Memory leak
>>>>>>>> 
>>>>>>>> yyparse(), as generated by bison, allocates extra space for the
>> parser
>>>>>>>> stack using malloc(). Unfortunately this means that there is a
>> memory
>>>>>>>> leak in case of an R error (long-jump). In principle, we could
>> define
>>>>>>>> yyoverflow() to relocate the parser stacks for bison and allocate
>> say
>>>>>> on
>>>>>>>> the R heap, but yyoverflow() is undocumented and somewhat
>> complicated
>>>>>>>> (we would have to replicate some macros from the generated parser
>>>>>> here).
>>>>>>>> The same problem exists at least in the Rd and LaTeX parsers in
>> tools.
>>>>>>>> */
>>>>>>>> 
>>>>>>>> ```
>>>>>>>> 
>>>>>>>> Could this be related to be issue ?
>>>>>>>> 
>>>>>>>> Le sam. 30 nov. 2019 ? 14:04, Laurent Gautier <lgautier at gmail.com>
>> a
>>>>>>>> ?crit :
>>>>>>>> 
>>>>>>>>> Hi,
>>>>>>>>> 
>>>>>>>>> The behavior of
>>>>>>>>> ```
>>>>>>>>> SEXP R_ParseVector(SEXP, int, ParseStatus *, SEXP);
>>>>>>>>> ```
>>>>>>>>> defined in `src/include/R_ext/Parse.h` appears to be inconsistent
>>>>>>>>> depending on the string to be parsed.
>>>>>>>>> 
>>>>>>>>> Trying to parse a string such as `"list(''=1+"` sets the
>>>>>>>>> `ParseStatus` to incomplete parsing error but trying to parse
>>>>>>>>> `"list(''=123"` will result in R sending a message to the console
>>>>>> (followed but a crash):
>>>>>>>>> 
>>>>>>>>> ```
>>>>>>>>> R[write to console]: Error: attempt to use zero-length variable
>>>>>> nameR[write to console]: Fatal error: unable to initialize the JIT***
>> stack
>>>>>> smashing detected ***: <unknown> terminated
>>>>>>>>> ```
>>>>>>>>> 
>>>>>>>>> Is there a reason for the difference in behavior, and is there a
>>>>>> workaround ?
>>>>>>>>> 
>>>>>>>>> Thanks,
>>>>>>>>> 
>>>>>>>>> 
>>>>>>>>> Laurent
>>>>>>>>> 
>>>>>>>>> 
>>>>>>>     [[alternative HTML version deleted]]
>>>>>>> 
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>>> 
>>>>>> 
>>>>> 
>>>> 
>>> 
>>>      [[alternative HTML version deleted]]
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Sun Dec 15 13:57:39 2019
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (Karolis =?utf-8?Q?Koncevi=C4=8Dius?=)
Date: Sun, 15 Dec 2019 14:57:39 +0200
Subject: [Rd] Inconsistencies in wilcox.test
In-Reply-To: <24053.22799.647150.274364@stat.math.ethz.ch>
References: <20191207185536.b6cmmkzywwyuateq@PMW>
 <20191207205901.4265F22877@v-lynne.math.ethz.ch>
 <20191207211858.dpnqeslbln5caz2v@PMW>
 <20191209214336.iy66s5q4nzawdfch@PMW>
 <24050.26847.78668.28633@stat.math.ethz.ch>
 <24053.22799.647150.274364@stat.math.ethz.ch>
Message-ID: <20191215125739.kg7rscy33ugwdage@PMW>

I see I am too late to comment :)

But commenting after the fact, just wish to say that I like the changes. 
Specially the mentioning of "exact" in the test name.

Floating point prevision is very nicely implemented too.
My only worry is that it will not serve new/lay users that may be in the 
biggest need for protections like these.

Do you think it would make sense to do it a bit differently? i.e.
setting digits.rank=7 by default, and including a message in the warning 
i.e. "ties present, if you are working with small digits consider 
adjusting digits.rank".

But, on the other hand, I understand that this would be a breaking 
change. A non breaking change might be to leave digits.rank as NA or 
NULL by default, which would act as infinity but also would do a test 
within wilcox.test() that checks for ties with digits.rank=7. Then a 
warning will say "possibly missed ties due to machine precision, if you 
are sure these are not ties - set digits.rank to Inf to get rid of this 
warning". This would be a non-breaking change, except for a warning. 
Would be interesting to hear your thoughts about this.

I will pull your changes and try to play with the code a bit later 
today. Thanks a lot for, Martin!

Also I have an unrelated question - I mainly find these discrepancies in 
"stats" because I am working on my little package related to hypothesis 
tests. And I have found a few more of them in other tests. One that I 
reported long time ago, regarding flinger.test(), which is also related 
to machine precision.

In terms of the etiquette of this list - should I mention them in this 
same thread or is it better to create a new one?

Kind regards,
Karolis K.

On 2019-12-14 22:50, Martin Maechler wrote:
>>>>>> Martin Maechler
>>>>>>     on Thu, 12 Dec 2019 17:20:47 +0100 writes:
>
>>>>>> Karolis Koncevi?ius
>>>>>>     on Mon, 9 Dec 2019 23:43:36 +0200 writes:
>
>    >> So I tried adding Infinity support for all cases.  And it
>    >> is (as could be expected) more complicated than I
>    >> thought.
>
>    > "Of course !"  Thank you, Karolis, in any case!
>
>    >> It is easy to add Inf support for the test. The problems
>    >> start with conf.int=TRUE.
>
>    >> Currently confidence intervals are computed via
>    >> `uniroot()` and, in the case of infinities, we are
>    >> computationally looking for roots over infinite interval
>    >> which results in an error. I suspect this is the reason
>    >> Inf values were removed in the first place.
>
>    > Maybe. It's still wrong to be done "up front".  I'm sure
>    > 98% (or so ;-) of all calls to wilcox.test() do *not* use
>    > conf.int = TRUE
>
>
>    >> Just a note, I found a few more errors/inconsistencies
>    >> when requesting confidence intervals with paired=TRUE
>    >> (due to Infinities being left in).
>
>    >> Current error in Inf-Inf scenario:
>
>    >> wilcox.test(c(1,2,Inf), c(4,8,Inf), paired=TRUE,
>    >> conf.int=TRUE) Error in if (ZEROES) x <- x[x != 0] :
>    >> missing value where TRUE/FALSE needed
>
>    > Good catch .. notably as it also happens when
>    > conf.int=FALSE as by default.  My version of wilcox.test()
>    > now does give the same as when the to 'Inf' are left away.
>
>    >> NaN confidence intervals:
>
>    >> wilcox.test(c(1:9,Inf), c(21:28,Inf,30), paired=TRUE,
>    >> conf.int=TRUE)
>
>    >> Wilcoxon signed rank test with continuity correction
>
>    >> data: c(1:9, Inf) and c(21:28, Inf, 30) V = 9.5, p-value
>    >> = 0.0586 alternative hypothesis: true location shift is
>    >> not equal to 0 0 percent confidence interval: NaN NaN
>    >> sample estimates: midrange NaN
>
>    > I don't see a big problem here. The NaN's in some sense
>    > show the best that can be computed with this data.
>    > Statistic and P-value, but no conf.int.
>
>
>    >> The easiest "fix" for consistency would be to simply
>    >> remove Infinity support from the paired=TRUE case.
>
>    > I strongly disagree.  We are not pruning good
>    > functionality just for some definition of consistency.
>
>    >> But going with the more desirable approach of adding
>    >> Infinity support for non-paired cases - it is currently
>    >> not clear to me what confidence intervals and
>    >> pseudomedian should be. Specially when Infinities are on
>    >> both sides.
>
>    > I deem that not to be a big deal.  They are not defined
>    > given the default formulas and that is reflected by NA /
>    > NaN in those parts of the result.
>
>    >> Regards, Karolis Koncevi?ius.
>
>    > But I have also spent a few hours now on
>    > wilcox.test.default() behavior notably also looking at the
>    > "rounding" / "machine precision" situation, and also on
>    > your remark that the 'method: ...' does not indicate well
>    > enough what was computed.
>
>    > In my (not yet committed) but hereby proposed enhancement
>    > of wilcox.test(), I have a new argument, 'digits.rank =
>    > Inf' (the default 'Inf' corresponding to the current
>    > behavior) with help page documentation:
>
>    > digits.rank: a number; if finite, ?rank(signif(r,
>    > digits.rank))? will be used to compute ranks for the test
>    > statistic instead of (the default) ?rank(r)?.
>
>    > and then in 'Details :'
>
>    >      For stability reasons, it may be advisable to use
>    > rounded data or to set ?digits.rank = 7?, say, such that
>    > determination of ties does not depend on very small
>    > numeric differences (see the example).
>
>    > and then in 'Examples: '
>
>    >      ## accuracy in ties determination via 'digits.rank':
>    > wilcox.test( 4:2, 3:1, paired=TRUE) # Warning: cannot
>    > compute exact p-value with ties wilcox.test((4:2)/10,
>    > (3:1)/10, paired=TRUE) # no ties => *no* warning
>    > wilcox.test((4:2)/10, (3:1)/10, paired=TRUE, digits.rank =
>    > 9) # same ties as (4:2, 3:1)
>
>    > ----------------------
>
>    > Lastly, I propose to replace "test" by "exact test" in the
>    > 'method' component (and print out) in case exact
>    > computations were used.  This information should be part
>    > of the returned "htest" object, and not only visible from
>    > the arguments and warnings that are printed during the
>    > computations.  This last change is in some sense the "most
>    > back-incompatible" change of these, because many
>    > wilcox.test() printouts would slightly change, e.g.,
>
>    >> w0 <- wilcox.test( 1:5, 4*(0:4), paired=TRUE)
>
>    > 	  Wilcoxon signed rank exact test
>
>    >   data: 1:5 and 4 * (0:4) V = 1, p-value = 0.125
>    > alternative hypothesis: true location shift is not equal
>    > to 0
>
>    > where before (in R <= 3.6.x) it is just
>
>    > 	  Wilcoxon signed rank test
>
>    >   data: .........  ...............  ...............
>
>    > but I think R 4.0.0 is a good occasion for such a change.
>
>    > Constructive feedback on all this is very welcome!  Martin
>
>... none  ...  I "assume" this means everybody likes the idea ;-)
>
>Anyway, now comitted to R-devel (for R 4.0.0), svn rev 77569
>(in 'NEW FEATURES').
>
>Martin
>
>
>
>    >> On 2019-12-07 23:18, Karolis Koncevi?ius wrote:
>    >>> Thank you for a fast response. Nice to see this mailing
>    >>> list being so alive.
>    >>>
>    >>> Regarding Inf issue: I agree with your assessment that
>    >>> Inf should not be removed. The code gave me an
>    >>> impression that Inf values were intentionally removed
>    >>> (since is.finite() was used everywhere, except for
>    >>> paired case). I will try to adjust my patch according to
>    >>> your feedback.
>    >>>
>    >>> One more thing: it seems like you assumed that issues
>    >>> 2:4 are all related to machine precision, which is not
>    >>> the case - only 2nd issue is.  Just wanted to draw this
>    >>> to your attention, in case you might have some feedback
>    >>> and guidelines about issues 3 and 4 as well.
>    >>>
>    >>>
>    >>>
>    >>> On 2019-12-07 21:59, Martin Maechler wrote:
>    >>>>>>>>> Karolis Koncevi?ius on Sat, 7 Dec 2019 20:55:36
>    >>>>>>>>> +0200 writes:
>    >>>>
>    >>>> > Hello, > Writing to share some things I've found
>    >>>> about wilcox.test() that seem a > a bit inconsistent.
>    >>>>
>    >>>> > 1. Inf values are not removed if paired=TRUE
>    >>>>
>    >>>> > # returns different results (Inf is removed): >
>    >>>> wilcox.test(c(1,2,3,4), c(0,9,8,7)) >
>    >>>> wilcox.test(c(1,2,3,4), c(0,9,8,Inf))
>    >>>>
>    >>>> > # returns the same result (Inf is left as value with
>    >>>> highest rank): > wilcox.test(c(1,2,3,4), c(0,9,8,7),
>    >>>> paired=TRUE) > wilcox.test(c(1,2,3,4), c(0,9,8,Inf),
>    >>>> paired=TRUE)
>    >>>>
>    >>>> Now which of the two cases do you consider correct ?
>    >>>>
>    >>>> IHMO, the 2nd one is correct: it is exactly one
>    >>>> property of the *robustness* of the wilcoxon test and
>    >>>> very desirable that any (positive) outlier is treated
>    >>>> the same as just "the largest value" and the test
>    >>>> statistic (and hence the p-value) should not change.
>    >>>>
>    >>>> So I think the first case is wrong, notably if
>    >>>> modified, (such that the last y is the overall maximal
>    >>>> value (slightly larger sample):
>    >>>>
>    >>>>> wilcox.test(1:7, 1/8+ c(9:4, 12))
>    >>>>
>    >>>> Wilcoxon rank sum test
>    >>>>
>    >>>> data: 1:7 and 1/8 + c(9:4, 12) W = 6, p-value = 0.01748
>    >>>> alternative hypothesis: true location shift is not
>    >>>> equal to 0
>    >>>>
>    >>>>> wilcox.test(1:7, 1/8+ c(9:4, 10000))
>    >>>>
>    >>>> Wilcoxon rank sum test
>    >>>>
>    >>>> data: 1:7 and 1/8 + c(9:4, 10000) W = 6, p-value =
>    >>>> 0.01748 alternative hypothesis: true location shift is
>    >>>> not equal to 0
>    >>>>
>    >>>>> wilcox.test(1:7, 1/8+ c(9:4, Inf))
>    >>>>
>    >>>> Wilcoxon rank sum test
>    >>>>
>    >>>> data: 1:7 and 1/8 + c(9:4, Inf) W = 6, p-value =
>    >>>> 0.03497 alternative hypothesis: true location shift is
>    >>>> not equal to 0
>    >>>>
>    >>>> The Inf case should definitely give the same as the
>    >>>> 10'000 case.  That's exactly one property of a robust
>    >>>> statistic.
>    >>>>
>    >>>> Thank you, Karolis, this is pretty embarrassing to only
>    >>>> be detected now after 25+ years of R in use ...
>    >>>>
>    >>>> The correct fix starts with replacing the is.finite()
>    >>>> by !is.na() and keep the 'Inf' in the rank
>    >>>> computations...  (but then probably also deal with the
>    >>>> case of more than one Inf, notably the Inf - Inf
>    >>>> "exception" which is not triggered by your example...)
>    >>>>
>    >>>>
>    >>>> ---
>    >>>>
>    >>>> Ben addressed the "rounding" / numerical issues
>    >>>> unavoidable for the other problems.
>    >>>>
>    >>>> > 2. tolerance issues with paired=TRUE.
>    >>>>
>    >>>> > wilcox.test(c(4, 3, 2), c(3, 2, 1), paired=TRUE) > #
>    >>>> ...  > # Warning: cannot compute exact p-value with
>    >>>> ties
>    >>>>
>    >>>> > wilcox.test(c(0.4,0.3,0.2), c(0.3,0.2,0.1),
>    >>>> paired=TRUE) > # ...  > # no warning
>    >>>>
>    >>>> > 3. Always 'x observations are missing' when
>    >>>> paired=TRUE
>    >>>>
>    >>>> > wilcox.test(c(1,2), c(NA_integer_,NA_integer_),
>    >>>> paired=TRUE) > # ...  > # Error: not enough (finite)
>    >>>> 'x' observations
>    >>>>
>    >>>> > 4. No indication if normal approximation was used:
>    >>>>
>    >>>> > # different numbers, but same "method" name >
>    >>>> wilcox.test(rnorm(10), exact=FALSE, correct=FALSE) >
>    >>>> wilcox.test(rnorm(10), exact=TRUE, correct=FALSE)
>    >>>>
>    >>>>
>    >>>> > From all of these I am pretty sure the 1st one is
>    >>>> likely unintended, > so attaching a small patch to
>    >>>> adjust it. Can also try patching others if > consensus
>    >>>> is reached that the behavioiur has to be modified.
>    >>>>
>    >>>> > Kind regards, > Karolis Koncevi?ius.
>    >>>>


From kry|ov@r00t @end|ng |rom gm@||@com  Sun Dec 15 17:41:17 2019
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Sun, 15 Dec 2019 19:41:17 +0300
Subject: [Rd] system2 doesn't quote stdin on unix, unlike stdout,
 stderr & input and on Windows
Message-ID: <20191215194117.425711bf@Tarkus>

Hi again!

While investigating the bug report [*] I found out that on unix, system2
does not quote its `stdin` argument while preparing the command line to launch.

It does shQuote the `stdout` and `stderr` arguments, and also the `f <-
tmpfile()` variable (which is used if `input` argument is provided),
which seems to set a precedent. On Windows, stdin, stdout, and stderr are handled independently of the shell, so it also just works without the use of shQuote by the caller.

Have people been relying on system2 not quoting the `stdin` argument, but
quoting `stdout` and `stderr`? For what it's worth, neither R_runR in
src/library/tools/R/check.R, nor .system_with_capture in
src/library/tools/R/utils.R (the only callers of system2(..., stdin = ...)),
nor their callers seem to be shQuote'ing the `stdin` argument.

Nor the rare system2(..., stdin = ...) callers (or their callers) on CRAN
seem to be quoting the `stdin` argument (I did find one exception [**]), it usually being "" or tmpfile() passed across a few function calls.

Given the considerations above, would the following patch be a good idea?

Index: src/library/base/R/unix/system.unix.R
===================================================================
--- src/library/base/R/unix/system.unix.R	(revision 77566)
+++ src/library/base/R/unix/system.unix.R	(working copy)
@@ -102,7 +102,7 @@
         writeLines(input, f)
         ## here 'command' is a single command, unlike system()
         command <- paste(command, "<", shQuote(f))
-    } else if (nzchar(stdin)) command <- paste(command, "<", stdin)
+    } else if (nzchar(stdin)) command <- paste(command, "<", shQuote(stdin))
     if(!wait && !intern) command <- paste(command, "&")
     .Internal(system(command, intern, timeout))
 }

-- 
Best regards,
Ivan

[*] https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17673

[**] https://github.com/search?q=org%3Acran+system2%28+stdin&type=Code
The search is probably computationally expensive and thus might only be available to GitHub account holders. The results are:

 - BatchJobs: R/WorkerLinux.R; stdin is "" by default, filenames generated by
   cfBrewTemplate aren't quoted
 - batchtools: callers of runOSCommand actually quote the stdin argument!
   https://github.com/mllg/batchtools/commit/4a5818d70c82c8842c0b8bded224dbb423b79f33
 - nat: R/cmtk.R, R/xformpoints.R; stdin is tempfile(...)
 - credentials: R/credential-api.R; stdin is passed as-is, tempfile() or
   "" in default arguments
 - runjags: R/setup.jags.jagsfile.R; stdin is constant "script.cmd"
 - m2r: R/m2.R; stdin is constant ""
 - scriptexec: R/scriptexec.R; stdin is passed as-is or default value retained
 - BioInstaller: inst/extdata/shiny/global_var.R; stdin is "" by default and
   passed as-is, callers of the sql2sqlite function don't quote the sql.file
   argument
 - annovarR: R/build.R: same sql2sqlite function as above


From d@n@kort@ch@k @end|ng |rom @de|@|de@edu@@u  Sun Dec 15 11:47:11 2019
From: d@n@kort@ch@k @end|ng |rom @de|@|de@edu@@u (Dan Kortschak)
Date: Sun, 15 Dec 2019 10:47:11 +0000
Subject: [Rd] source definition for R_NilValue/return from TYPEOF(R_NilValue)
Message-ID: <daf586e7f4804036b8bb135226140bf0b77e2872.camel@adelaide.edu.au>

Hello,

for reasons I want to know the return value of TYPEOF(R_NilValue), I
expect it to be NILSXP, but I can't find this documented anywhere.
Ideally, I'd like to see the source definition of R_NilValue, but after
fair bit of searching I cannot find an obviously location for this.

Would someone please point me in the right direction?

thanks
--
CRICOS provider code 00123M


From c@@rd|@g@bor @end|ng |rom gm@||@com  Mon Dec 16 11:02:36 2019
From: c@@rd|@g@bor @end|ng |rom gm@||@com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Mon, 16 Dec 2019 10:02:36 +0000
Subject: [Rd] source definition for R_NilValue/return from
 TYPEOF(R_NilValue)
In-Reply-To: <daf586e7f4804036b8bb135226140bf0b77e2872.camel@adelaide.edu.au>
References: <daf586e7f4804036b8bb135226140bf0b77e2872.camel@adelaide.edu.au>
Message-ID: <CABtg=KnOY2udg76DgVht6keiP_=45tw3J9=r_fnj1uFA+2v15g@mail.gmail.com>

It is in the source:
https://github.com/wch/r-source/blob/ea8c13aef93058c71d647619583b561567856584/src/include/Rinternals.h#L110
https://github.com/wch/r-source/blob/ea8c13aef93058c71d647619583b561567856584/src/include/Rinternals.h#L1798

It could probably be in
https://cran.r-project.org/doc/manuals/r-devel/R-lang.html#NULL-object

Gabor

On Mon, Dec 16, 2019 at 9:59 AM Dan Kortschak
<dan.kortschak at adelaide.edu.au> wrote:
>
> Hello,
>
> for reasons I want to know the return value of TYPEOF(R_NilValue), I
> expect it to be NILSXP, but I can't find this documented anywhere.
> Ideally, I'd like to see the source definition of R_NilValue, but after
> fair bit of searching I cannot find an obviously location for this.
>
> Would someone please point me in the right direction?
>
> thanks
> --
> CRICOS provider code 00123M
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From kry|ov@r00t @end|ng |rom gm@||@com  Mon Dec 16 11:33:34 2019
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Mon, 16 Dec 2019 13:33:34 +0300
Subject: [Rd] source definition for R_NilValue/return from
 TYPEOF(R_NilValue)
In-Reply-To: <daf586e7f4804036b8bb135226140bf0b77e2872.camel@adelaide.edu.au>
References: <daf586e7f4804036b8bb135226140bf0b77e2872.camel@adelaide.edu.au>
Message-ID: <20191216133334.582b290d@trisector>

On Sun, 15 Dec 2019 10:47:11 +0000
Dan Kortschak <dan.kortschak at adelaide.edu.au> wrote:

> I'd like to see the source definition of R_NilValue, but after
> fair bit of searching I cannot find an obviously location for this.
> 
> Would someone please point me in the right direction?

As far as I understand, the assignment to R_NilValue happens in
src/main/memory.c:

https://github.com/wch/r-source/blob/776929704cb4f9398f52805f48f2c93582ec3d38/src/main/memory.c#L2186

(see the definition of GET_FREE_NODE(s) in the same file)

Besides declaring R_NulValue as "extern" and assignments in void
InitMemory(), there doesn't seem to be anything else.

-- 
Best regards,
Ivan


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec 16 12:32:45 2019
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 16 Dec 2019 12:32:45 +0100
Subject: [Rd] Windows check problems.
In-Reply-To: <72f873b4-0d5c-18ef-1c9b-3495b1d37d81@gmail.com>
References: <72f873b4-0d5c-18ef-1c9b-3495b1d37d81@gmail.com>
Message-ID: <6f7a58a7-afac-fa4a-4b0d-2f9f7aa6eb95@gmail.com>

For reference, this has been addressed in R-devel, R now falls back to 
copy when symlinking of the package directory silently fails.

Thanks to Duncan for his analysis and a patch that fixed this.
Tomas

On 12/11/19 5:22 PM, Duncan Murdoch wrote:
> The thread starting with this message:
>
> https://stat.ethz.ch/pipermail/r-package-devel/2019q4/004745.html
>
> described problems Rich Heiberger was having with package checking on 
> Windows.? It appeared that during the tests of examples, an old 
> version of the package was loaded but the new tests were being run, 
> causing lots of confusion and trouble.
>
> I reproduced the error, and I think I've found the cause.? I had his 
> package tarball on a network drive, with a local drive being used for 
> the session temporary directory.? The check code needs a copy of the 
> package installed in the temporary directory, and already has one in 
> the pkg.Rcheck directory where the check is taking place, so it tries 
> to create a junction linking them.? (On non-Windows systems it uses a 
> symlink.)
>
> Apparently the junction creation silently fails:? an empty directory 
> appears on the temp dir.? When R loads the package code, it doesn't 
> find it in the temp dir, and goes looking in other libraries, where it 
> found an older versions of the package.
>
> A workaround for this issue is to set the environment variable
>
> ? R_WIN_NO_JUNCTIONS=yes
>
> before doing the check.? This causes the check code to copy all the 
> files into the temp dir and things are fine.
>
> I don't know whether the junction creation should have succeeded, or 
> whether it should have signalled an error when it didn't, but it might 
> make sense for R to do a simple sanity check after trying to create 
> the junction (e.g. test for the presence of DESCRIPTION in the newly 
> created location), falling back to a copy if things didn't succeed.
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


